{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n 1\u00ba de DAM","text":"<p>Este sitio contiene los apuntes del m\u00f3dulo de programaci\u00f3n para 1\u00ba DAM Dual del IES Armando Cotarelo Valledor curso 2022-2023.</p>"},{"location":"about/","title":"A cerca de","text":"<p>El contenido de este sitio web </p>"},{"location":"about/#proyectos-empleados","title":"Proyectos empleados","text":""},{"location":"about/#mkdocs","title":"MKDocs","text":"<p>El projecto (MKDocs)[https://www.mkdocs.org] se distribuye bajo la licencia (BSD)[https://es.wikipedia.org/wiki/Licencia_BSD]</p>"},{"location":"about/#material-for-mkdocs","title":"Material for MKDocs","text":"<p>El tema utilizado es el tema por defecto de (Material for MKDocs)[https://squidfunk.github.io/mkdocs-material].</p> <p>Material for MKDocs se distribuye bajo la licencia (MIT)[https://es.wikipedia.org/wiki/Licencia_MIT].</p> <p>Este obra est\u00e1 bajo una licencia de Creative Commons Reconocimiento 4.0 Internacional.</p>"},{"location":"licencia/","title":"Licencia","text":""},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/","title":"Examen Java: Estructuras de datos y acceso a ficheros","text":""},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#estructuras-de-datos","title":"Estructuras de datos","text":""},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#1-genericos-uno","title":"1 Gen\u00e9ricos: Uno","text":"<p>Empleando gen\u00e9ricos define una clase que pueda guardar cualquier tipo de dato.</p> <p>(Constructor, getters y setters, y un m\u00e9todo que indique si est\u00e1 vac\u00eda).</p>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#2-collections-listas","title":"2 <code>Collections</code>: Listas","text":"<p>2.1. Indica qu\u00e9 tipo de lista (<code>ArrayList</code> o <code>LinkedList</code>) deber\u00edas utilizar y por qu\u00e9 en cada una de las siguientes situaciones:</p> <p>a) Queremos almacenar en una lista el cat\u00e1logo de una biblioteca al que accederemos constantemente indicando el n\u00famero del libro.</p> <p>b) Queremos almacenar resultados de varias b\u00fasquedas de art\u00edculos en una base de datos que iremos a\u00f1adiendo a la lista. Tambi\u00e9n haremos filtrados que eliminar\u00e1n grandes cantidades de elementos de la lista resultado.</p> <p>2.2. Crea una estructura que funcione como una cola extendiendo <code>LinkedList</code>. Tendr\u00e1 dos m\u00e9todos <code>encolar</code> y <code>desencolar</code>. El primero a\u00f1adir\u00e1 un elemento al final de la cola y el segundo devolver\u00e1 el primer elemento de la cola.</p> <p>2.3. A\u00f1ade el c\u00f3digo que estimes necesario para que la siguiente lista se ordene de mayor a menor.</p> <pre><code>List&lt;Integer&gt; lista = new ArrayList&lt;&gt;();\n\nfor (int i = 0; i &lt; 10; i++) {\n    lista.add(i);\n}\n</code></pre>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#3-collections-conjuntos","title":"3 <code>Collections</code>: Conjuntos","text":"<p>3.1. \u00bfEs posible listar el contenido de un conjunto?</p> <p>3.2. \u00bfC\u00f3mo lo har\u00edas? (escribe un programa que liste el contenido de un conjunto)</p> <p>3.3. \u00bfEn qu\u00e9 orden se mostrar\u00edan los datos si recorremos en el siguiente conjunto?</p> <pre><code>Set&lt;String&gt; conjunto = new HashSet&lt;&gt;();\n\nconjunto.add(\"uno\");\nconjunto.add(\"dos\");\nconjunto.add(\"tres\");\nconjunto.add(\"cuatro\");\nconjunto.add(\"cinco\");\n</code></pre> <p>3.4. \u00bfA qu\u00e9 se debe esto?</p>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#4-mapas-uno","title":"4 Mapas: uno","text":"<p>4.1. Declara un mapa que acepte cadenas como clave y listas de enteros como valor.</p> <p>4.2. Inserta tres elementos en dicho mapa.</p> <p>4.3. Cambia el valor del segundo elemento.</p> <p>4.4. Escribe un programa que recorra y muestre el contenido del mapa anterior (tendr\u00e1 que funcionar independientemente del tama\u00f1o del mapa).</p> <p>4.5. \u00bfIndica en qu\u00e9 orden se mostrar\u00edan los elementos del siguiente mapa y por qu\u00e9?</p> <pre><code>Map&lt;Integer, String&gt; mapa = new LinkedHashMap&lt;&gt;();\n\nmapa.put(3, \"tres\");\nmapa.put(2, \"dos\");\nmapa.put(1, \"uno\");\n</code></pre>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#ficheros","title":"Ficheros","text":"<p>1.1. Escribe un programa que inserte esta l\u00ednea como la primera de un fichero de texto: \"\u00a1Hola mundo!\".</p> <p>1.2. Escribe un programa que haga lo mismo pero leyendo y escribiendo arrays de bytes en el fichero.</p> <p>1.3. Aseg\u00farate de que se liberan correctamente los recursos utilizados.</p>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#getting-started","title":"Getting Started","text":"<p>Welcome to the VS Code Java world. Here is a guideline to help you get started to write Java code in Visual Studio Code.</p>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#folder-structure","title":"Folder Structure","text":"<p>The workspace contains two folders by default, where:</p> <ul> <li><code>src</code>: the folder to maintain sources</li> <li><code>lib</code>: the folder to maintain dependencies</li> </ul> <p>Meanwhile, the compiled output files will be generated in the <code>bin</code> folder by default.</p> <p>If you want to customize the folder structure, open <code>.vscode/settings.json</code> and update the related settings there.</p>"},{"location":"Examenes/Correccion/Segundo_trimestre/Examen_segunda_evaluacion/#dependency-management","title":"Dependency Management","text":"<p>The <code>JAVA PROJECTS</code> view allows you to manage your dependencies. More details can be found here.</p>"},{"location":"Tareas/Tarea%201%20-%20Enunciado/","title":"Tarea 1: Programaci\u00f3n b\u00e1sica, bucles y arrays","text":""},{"location":"Tareas/Tarea%202%20-%20Enunciado/","title":"Tarea2: Orientaci\u00f3n a objetos","text":"<p>Necesitamos crear una jerarqu\u00eda de clases que represente la situaci\u00f3n de alumnos, profesores, ciclos, m\u00f3dulos y aulas.</p> <p>Todas los objetos han de poder generar una cadena de caracteres que los represente (m\u00e9todo <code>toString</code>).</p>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#objetivos-requerimientos","title":"Objetivos / requerimientos","text":"<ul> <li>Se ha de poder almacenar informaci\u00f3n de alumnos, ciclos y m\u00f3dulos.</li> <li>Se ha de poder mostar el ciclo y los m\u00f3dulos en los que est\u00e1 matriculado un alumno.</li> <li>Se ha de poder mostar los alumnos que est\u00e1n matriculados en un ciclo.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#alumnos","title":"Alumnos","text":"<ul> <li>Un alumno estar\u00e1 matriculado en un ciclo.</li> <li>Un alumno tendr\u00e1 nombre y apellidos adem\u00e1s de un DNI (\u00fanico).</li> <li>Un alumno tendr\u00e1 una fecha de nacimiento.</li> <li>Un alumno tendr\u00e1 informaci\u00f3n de contacto:</li> <li>Tel\u00e9fono</li> <li>e-mail.</li> <li>Direcci\u00f3n.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#delegados","title":"Delegados","text":"<ul> <li>Un alumno puede ser delegado de un \u00fanico ciclo y curso.</li> <li>Solo habr\u00e1 un delegado por ciclo y curso.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#profesores","title":"Profesores","text":"<ul> <li>Un profesor estar\u00e1 asignado a uno o m\u00e1s m\u00f3dulos.</li> <li>Un profesor tendr\u00e1 nombre y apellidos adem\u00e1s de un DNI (\u00fanico).</li> <li>Un profesor tendr\u00e1 una fecha de nacimiento.</li> <li>Un profesor tendr\u00e1 informaci\u00f3n de contacto:</li> <li>Tel\u00e9fono</li> <li>e-mail.</li> <li>Direcci\u00f3n.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#tutores","title":"Tutores","text":"<ul> <li>Un tutor ha de ser profesor del ciclo y curso.</li> <li>Un tutor est\u00e1 asociado a un ciclo y curso.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#ciclos","title":"Ciclos","text":"<ul> <li>Un ciclo ha de tener un nombre.</li> <li>Un ciclo tiene un c\u00f3digo \u00fanico.</li> <li>Un ciclo podr\u00e1 ser de tipo \"modular\", \"ordinario\" o \"dual\" (que es el mejor).</li> <li>Un ciclo tiene uno o m\u00e1s m\u00f3dulos.</li> <li>Un ciclo tendr\u00e1 dos os tres cursos.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#modulos","title":"Modulos","text":"<ul> <li>Un m\u00f3dulo tiene un nombre.</li> <li>Un m\u00f3dulo tiene un c\u00f3digo \u00fanico.</li> <li>Un m\u00f3dulo tendr\u00e1 un n\u00famero de horas asignado.</li> <li>Un m\u00f3udlo ha de estar asignado a un curso (1\u00ba, 2\u00ba o 3\u00ba).</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#aulas","title":"Aulas","text":"<ul> <li>Un aula tendr\u00e1 un \"nombre de planta\" y un \"numero\" asociado.</li> <li>Un aula tendr\u00e1 una capcidad de alumnos.</li> <li>Un aula tendr\u00e1 material.</li> <li>Un aula tendr\u00e1 asignado uno o m\u00e1s m\u00f3dulos.</li> </ul>"},{"location":"Tareas/Tarea%202%20-%20Enunciado/#relacion-aula-modulo","title":"Relaci\u00f3n aula-modulo","text":"<p>Para reflejar la relaci\u00f3n entre aulas y m\u00f3dulos podremos utilizar la clase <code>AulaModulo</code> que almacenar\u00e1 pares \"Aula\" / \"Modulo\".</p> <p>Un m\u00f3dulo solo se impartir\u00e1 en un aula.</p> <p>Un aula podr\u00e1 utilizarse en varios m\u00f3dulos.</p>"},{"location":"Tareas/Tarea%203%20-%20Enunciado/","title":"Tema 7 - Tarea 1: Iterables","text":"<p>La tarea 1 estar\u00e1 dividida en tres partes:</p> <ol> <li>Crea una clase Abecedario que implemente el interfaz Iterable y que permita iterar sobre las letras del abecedario.</li> <li>Modifica la clase interna que implementa Iterator a\u00f1adiendo dos nuevos m\u00e9todos:</li> <li><code>hasNextVocal()</code>: Que indicar\u00e1 si existe una nueva vocal.</li> <li><code>nextVocal()</code>: Que devolver\u00e1 la siguiente vocal.</li> <li>Utiliza el iterador modificado para iterar sobre las vocales. Puedes realizar m\u00e1s modificaciones en la clase si lo estimas oportuno.</li> <li>Crea una subclase Vocales de la clase Abecedario que permita iterar (utilizando el bucle for-each) sobre las vocales.</li> </ol> <p>La entrega se realizar\u00e1 mediante un archivo comprimido con el c\u00f3digo fuente.</p> <p>Fecha de entrega l\u00edmite: domingo 22 de enero a las 00:00.</p>"},{"location":"Tareas/Tarea%203%20-%20Enunciado/#ejemplos","title":"Ejemplos","text":"<p>La implementaci\u00f3n de las clases ha de cumplir:</p> <pre><code>Abecedario abc = new Abecedario();\n   for (char x : abc) { System.out.println(\"caracter: \" + x);\n}\n// La salida por consola deber\u00eda ser:\n// caracter: a\n// caracter: b\n// caracter: c\n// caracter: d\n// caracter: e\n// ...\n\nAbecedarioB abcb = new AbecedarioB();\nAbecedarioB.VocIt iter = abcb.iterator();\nwhile(iter.hasNextVocal()) {\n   System.out.println(\"vocal: \" + iter.nextVocal());\n}\n// La salida por consola deber\u00eda ser:\n// vocal: a\n// vocal: e\n// vocal: i\n// ...\n\nVocales voc = new Vocales();\nfor (char x : voc) {\n   System.out.println(\"Vocal: \" + x);\n}\n// La salida por consola deber\u00eda ser:\n// Vocal: a\n// Vocal: e\n// Vocal: i\n// ...\n</code></pre>"},{"location":"Tareas/Tarea%204%20-%20Enunciado/","title":"Tema 7 - tarea 4: Calculo tiempos","text":"<p>Se han de crear dos listas: <code>ArrayList</code> y <code>LinkedList</code>.</p> <p>Se pedir\u00e1 por pantalla un tama\u00f1o para ambas listas.</p> <p>Se pedir\u00e1 tambi\u00e9n el n\u00famero de veces que se han de repetir las pruebas.</p> <p>Se calcular\u00e1 y mostrar\u00e1 el resultado medio para cada tipo de prueba realizado.</p> <p>Se realizar\u00e1n las siguientes operaciones con cada lista:</p> <ol> <li>Se insertar\u00e1 en cada una de las listas tantos elementos (n\u00fameros enteros) como su tama\u00f1o.</li> <li>Recorreremos cada lista desde el final al principio.</li> <li>Comprobar (<code>contains()</code>) que contiene todos los elementos.</li> <li>Eliminar los elementos de la lista:<ul> <li>Comenzando por el principio.</li> <li>Comenzando por el final.</li> </ul> </li> </ol> <p>Mediremos el tiempo que se tarda en realizar cada operaci\u00f3n (para todos los elementos).</p> <p>Nota: Para medir tiempos se recomienda usar <code>System.nanoTime</code> o <code>System.currentTimeMillis()</code>.</p> <pre><code>// Apunto el tiempo en este instante: t0\nlong t0 = System.nanoTime();\n// Ejecuto lo que quiero medir\n\n// Apunto el tiempo en este instante: t1\nlong t1 = System.nanoTime();\n\n// Calculo el tiempo pasado entre t0 y t1: t1 - t0.\nlong tiempoTranscurrido = t1 - t0;\n</code></pre>"},{"location":"Tareas/Tarea%205%20-%20Enunciado/","title":"Tema 7 - Tarea 2: Pilas","text":"<p>Utilizando alguna de las clases que hemos visto hasta el momento (<code>ArrayList</code>, <code>LinkedList</code>, etc.) construye una clase <code>Pila</code> que e comporte como tal:</p> <ol> <li>Cuando se inserta un elemento en la pila, se inserta al final de la lista.</li> <li>Cuando se extrae un elemento de la pila, se extrae el \u00faltimo elemento de la lista.</li> </ol> <p>Para ello hemos de implementar los siguientes m\u00e9todos:</p> <ol> <li><code>push(T elemento)</code>: Que inserte un elemento en la pila.</li> <li><code>T pop()</code>: Que extraiga un elemento de la pila.</li> </ol> <p>La pila ha de poder contener cualquier tipo de elementos (po lo que hemos de utilizar gen\u00e9ricos).</p>"},{"location":"Tareas/Tarea%206%20-%20Enunciado/","title":"Tema 7 - Tarea 3: Lambdas y cosas","text":"<p>Crea una clase <code>ListaPersonas</code> permita almacenar una lista de personas. La clase ha de extender <code>PriorityQueue</code> y se le han de crear dos <code>Comparator</code>. Uno que permita comparar las edades de las personas. Y otro que permita ordenar las personas por su primer apellido.</p> <p>Nota: No se ha de guardar la edad de la persona si no su fecha de nacimento. La edad se ha de calcular a partir de la fecha de nacimiento a trav\u00e9s del m\u00e9todo <code>int getEdad()</code> que tendr\u00e9is que implementar.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/","title":"Tema 8 - Tarea1: Lectura y escritura","text":"<p>Crea una clase <code>Main</code> y dentro de ella los m\u00e9todos est\u00e1ticos que se indican en los siguientes apartados.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/#ejercicio-1-escribe-texto-a-un-fichero","title":"Ejercicio 1: Escribe texto a un fichero","text":"<p>Crea un m\u00e9todo con la siguiente firma <code>public static void writeTextToFile(String fn, String txt)</code> donde <code>fn</code> ser\u00e1 el nombre de un fichero y <code>txt</code> un texto. Este m\u00e9todo escribir\u00e1 el text <code>txt</code> dentro del fichero de nombre <code>fn</code>.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/#ejercicio-2-anadir-texto-a-un-fichero","title":"Ejercicio 2: A\u00f1adir texto a un fichero","text":"<p>Escribe un m\u00e9todo con la siguiente firma <code>public static void appendTextToFile(String fn, String txt)</code> de modo que a\u00f1ada el texto <code>txt</code> al fichero de nombre <code>fn</code>.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/#ejercicio-3-anadir-varias-lineas-a-un-fichero","title":"Ejercicio 3: A\u00f1adir varias l\u00edneas a un fichero","text":"<p>Escribe un m\u00e9todo con la siguiente declaraci\u00f3n <code>public static void appendLinesToFile(String fn, List&lt;String&gt; lines)</code> de modo que a\u00f1ada las cadenas de la lista al fichero.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/#ejercicio-4-leer-texto-de-un-fichero","title":"Ejercicio 4: Leer texto de un fichero","text":"<p>Escribe un m\u00e9todo con la forma <code>public static List&lt;String&gt; readLinesFromFile(String fn)</code> que devuelva en una lista las l\u00edneas del fichero de nombre <code>fn</code>.</p>"},{"location":"Tareas/Tarea%207%20-%20Enunciado/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>En el m\u00e9todo <code>public static void main(String[] args)</code> de nuestra clase <code>Main</code> se escribir\u00e1 el c\u00f3digo necesario para probar el correcto funcionamiento de los ejercicios:</p> <ol> <li>Ejercicio 1: Se pedir\u00e1 el nombre de un fichero donde escribir texto. Se pedir\u00e1 tambi\u00e9n texto para escribir en el fichero.</li> <li>Ejercicio 2: Se pedir\u00e1 el nombre del fichero donde se escribir\u00e1 (deber\u00e1 tener texto previo) y a continuaci\u00f3n se pedir\u00e1 el texto a a\u00f1adir (en una nueva l\u00ednea).</li> <li>Ejercicio 3: Se pedir\u00e1 el nombre del fichero donde se escribir\u00e1n las nuevas l\u00edneas. A continuaci\u00f3n se pedir\u00e1 el n\u00famero de l\u00edneas a a\u00f1adir y el contenido de cada una de ellas.</li> </ol>"},{"location":"Tareas/Tarea%208%20-%20Enunciado/","title":"Tema 8 - Tarea 2: Lectura y escritura en binario","text":""},{"location":"Tareas/Tarea%208%20-%20Enunciado/#ejercicio-copia-de-un-fichero","title":"Ejercicio: Copia de un fichero","text":"<p>Crea o copia un fichero dentro del directorio donde vas a escribir el c\u00f3digo de este ejercicio.</p> <p>Se han de crear dos m\u00e9todos:</p> <ul> <li>El primer m\u00e9todo recibir\u00e1 como argumento el nombre de un fichero y leer\u00e1 su contenido devolvi\u00e9ndolo como un array de bytes.</li> <li>El segundo m\u00e9todo aceptar\u00e1 como argumento el nombre de un fichero y un array de bytes y guardar\u00e1 dicho array como contenido del fichero.</li> </ul>"},{"location":"Tareas/Tarea%208%20-%20Enunciado/#ejemplo","title":"Ejemplo","text":"<pre><code>// Primer m\u00e9todo:\nstatic byte[] leeDatos(String nombreFichero) {\n    //...\n}\n\n// Segundo m\u00e9todo:\nstatic void escribeDatos(String nombreFichero, byte[] datos) {\n    //...\n}\n</code></pre>"},{"location":"Tareas/Tarea%209%20-%20Enunciado/","title":"Tema 9 - Tarea 1: C# Clases, Propiedades, Listas","text":"<p>En esta tarea nos familiarizaremos con el uso de clases, variables de case e instancia as\u00ed como de propiedades y m\u00e9todos.</p>"},{"location":"Tareas/Tarea%209%20-%20Enunciado/#primera-parte-clases","title":"Primera parte (clases)","text":"<p>Crea una clase <code>Persona</code> que cumpla las siguientes condiciones:</p> <ol> <li>Todas la variables tanto de clase como de instancia han de declararse como privadas.</li> <li>Ha de tener una variable de clase que lleve cuenta del n\u00famero de personas creadas.</li> <li>Cada persona tendr\u00e1:<ol> <li>Nombre.</li> <li>Primer apellido.</li> <li>Segundo apellido.</li> <li>Hombre (podr\u00e1 ser verdadero o falso).</li> <li>Mujer (podr\u00e1 ser verdadero o falso).</li> <li>Fecha de nacimiento (se usar\u00e1 un objeto de la clase <code>DateTime</code>).</li> <li>Dni.</li> <li>Sueldo.</li> </ol> </li> <li>La clase dispondr\u00e1 de un m\u00e9todo para validad el DNI.</li> <li>Todo elemento de la clase <code>Persona</code> dispondr\u00e1 de las siguiente propiedades:<ol> <li><code>Nombre</code>, <code>PrimerApellido</code>, <code>SegundoApellido</code>: <code>string</code> y de lectura y escritura.</li> <li><code>Sueldo</code>: <code>float</code> de lectura y escritura.</li> <li><code>Sexo</code>: <code>string</code> de lectura y escritura (admitir\u00e1 dos posibles valores: hombre o mujer).</li> <li><code>NombreCompleto</code>: <code>string</code> de s\u00f3lo lectura que devolver\u00e1 el nombre de la forma: \"[nombre] [primerApellido] [segundoApellido]\".</li> <li><code>Edad</code>: <code>int</code> de s\u00f3lo lectura que devolver\u00e1 la edad de la persona.</li> <li><code>FechaDeNacimiento</code>: <code>string</code> de lectura y escritura.</li> </ol> </li> <li>Dispondremos tambi\u00e9n de un m\u00e9todo de clase <code>CuantasPersonas</code> que nos devolver\u00e1 el n\u00famero de personas creadas.</li> </ol>"},{"location":"Tareas/Tarea%209%20-%20Enunciado/#segunda-parte-listas","title":"Segunda parte (listas)","text":"<p>Crearemos una lista de personas sobre la que aplicaremos las funciones <code>Select</code>, <code>Where</code> y <code>Aggregate</code> para obtener la informaci\u00f3n siguiente:</p> <ol> <li>Las personas con mayor y menor edad de la lista.</li> <li>La edad media de las personas de la lista.</li> <li>Sueldo medio de las personas menores de 30 a\u00f1os.</li> <li>Sueldo medio de las personas mayores de 30 a\u00f1os.</li> <li>Sueldo medio de las personas con edad comprendida entre 35 y 45 a\u00f1os.</li> </ol>"},{"location":"Tareas/Tarea%209%20-%20Enunciado/#codigo-para-crear-una-lista-de-personas","title":"C\u00f3digo para crear una lista de personas","text":"<pre><code>List&lt;Persona&gt; personas = new List&lt;Persona&gt;(10);\n\npersonas.Add(new Persona(\"Manuel\", \"Pi\u00f1eiro\", \"Mourazos\", \"1977, 5, 15\", \"hombre\", 1500));\npersonas.Add(new Persona(\"Cristina\", \"Fernadez\", \"Garrido\", \"2001, 8, 25\", \"mujer\", 2500));\npersonas.Add(new Persona(\"\u00c1lvaro\", \"Pose\", \"Castro\", \"1997, 10, 7\", \"hombre\", 1800.5f));\npersonas.Add(new Persona(\"Tristan\", \"G\u00f3mez\", \"P\u00e9rez\", \"2010, 1, 30\", \"hombre\", 300.9f));\npersonas.Add(new Persona(\"Sara\", \"Salamanca\", \"Torres\", \"1999, 12, 31\", \"mujer\", 3750.66f));\npersonas.Add(new Persona(\"Fernando\", \"Fernandez\", \"Fernandez\", \"2000, 1, 11\", \"hombre\", 2220.20f));\npersonas.Add(new Persona(\"C\u00e1rmen\", \"Abrente\", \"Montiel\", \"1992, 3, 17\", \"mujer\", 1770.5f));\npersonas.Add(new Persona(\"Cristiano Ronaldo\", \"dos Santos\", \"Aveiro\", \"1985, 2, 5\", \"hombre\", 999999.999f));\npersonas.Add(new Persona(\"Bat\", \"Man\", \"Wayne\", \"1915, 3, 7\", \"hombre\", 000.0f));\n</code></pre>"},{"location":"Tema%2001%20-%20Introducci%C3%B3n/Introduccion_a_la_programcacion/","title":"Tema 1: Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"Tema%2001%20-%20Introducci%C3%B3n/Introduccion_a_la_programcacion/#historia","title":"Historia","text":""},{"location":"Tema%2001%20-%20Introducci%C3%B3n/Introduccion_a_la_programcacion/#paradigmas","title":"Paradigmas","text":""},{"location":"Tema%2001%20-%20Introducci%C3%B3n/Introduccion_a_la_programcacion/#lenguajes","title":"Lenguajes","text":""},{"location":"Tema%2001%20-%20Introducci%C3%B3n/Introduccion_a_la_programcacion/#generaciones-o-niveles","title":"Generaciones o niveles","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/","title":"Tema 2: Introducci\u00f3n a Java","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#hola-mundo","title":"Hola mundo","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#como-escribir-un-programa-java","title":"\u00bfC\u00f3mo escribir un programa Java?","text":"<p>Un programa en c\u00f3digo Java no es m\u00e1s que un documento de texto con sentencias y sintaxis de Java que puedan ser comprendidas por el compilador.</p> <p>Este fichero de c\u00f3digo fuente ha de tener la extensi\u00f3n <code>.java</code> para que pueda ser reconocido por los IDE (Entornos integrados de desarrollo).</p> <p>As\u00ed, para crear nuestro primer programa Java lo \u00fanico que hemos de hacer es escribir las siguientes l\u00edneas de c\u00f3digo en un fichero de nombre <code>HolaMundo.java</code> (es necesario el nombre <code>HolaMundo</code> como explicaremos m\u00e1s adelante):</p> <pre><code>public class HolaMundo {\n    public static void main(String[] args) {\n        System.out.println(\"Hola mundo.\");\n    }\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#como-compilar-ejecutar-un-programa","title":"\u00bfC\u00f3mo compilar / ejecutar un programa?","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#que-significa-compilar","title":"\u00bfQu\u00e9 significa compilar?","text":"<p>Compilar un programa consiste en convertir el c\u00f3digo fuente en c\u00f3digo binario. El c\u00f3digo fuente es el programa tal como nosotros lo hemos escrito en el editor de c\u00f3digo, de manera que es legible por los seres humanos. Por el contrario el c\u00f3digo binario normalmente es \u00fanicamente comprensible por el Sistema Operativo que puede procesarlo y enviarlo al procesador del ordenador para que se ejecuten las instrucciones que escribi\u00f3 el programador.</p> <p>Como podemos ver el c\u00f3digo binario (o simplemente binario) de un programa es dependiente del sistema operativo y el tipo de procesador (arquitectura) de la m\u00e1quina en la que se quiera ejecutar.</p> <p>En Java este proceso es algo diferente. En lugar de compilar para un sistema operativo / arquitectura lo que hace el compilador de Java es crear un binario para ser ejecutado en la m\u00e1quina virtual de java (JVM). Esta m\u00e1quina virtual de java no es m\u00e1s que un programa que entiende el c\u00f3digo binario de Java (Java bytecode).</p> <p>De modo que un programa Java, una vez compilado, podr\u00e1 ser ejecutado por cualquier JVM. Lo que necesitaremos para poder ejecutar un bytecode de Java en cualquier arquitectura es una JVM que corra sobre ella.</p> <p></p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#entonces-para-ejecutar-un-programa-java-que","title":"Entonces... para ejecutar un programa Java \u00bfQu\u00e9?","text":"<p>Para ejecutar un programa Java hemos de seguir los siguientes pasos:</p> <ol> <li>Compilar a bytecode de Java: <code>javac -verbose HolaMundo.java</code>.</li> <li>Enviarle el bytecode de Java (<code>HolaMundo.class</code>) a la m\u00e1quina virtual: <code>java HolaMundo</code>.</li> </ol> <p>Nota: al ejecutar el segundo paso no se ha de incluir el .class al indicar la clase que queremos ejecutar.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#codificacion-de-texto-y-compilacion","title":"Codificaci\u00f3n de texto y compilaci\u00f3n","text":"<p>Cuando tenemos un fichero de c\u00f3digo fuente podemos verlo como un fichero que contiene texto. Pero en inform\u00e1tica el texto, como cualquier otro contenido: audio, video, im\u00e1genes, gr\u00e1ficos, etc. estar\u00e1 codificado en binario. Y al igual que el audio o el v\u00eddeo hay distintos tipos de codificaci\u00f3n.</p> <p>El programa <code>javac</code>,  compilador de java, por defecto interpreta que los archivos de texto <code>.java</code> que le pasamos est\u00e1n codificados en el formato <code>ASCII</code> por lo que, si tenemos tildes o \"\u00f1\" en nuestro c\u00f3digo este se mostrar\u00e1 incorrectamente (<code>ASCII</code> no soporta tildes ni caracteres distintos de los n\u00famero y el alfabeto ingl\u00e9s) al ejecutarlo. Por ejemplo, si tenemos un archivo (codificado en Unicode) con el siguiente c\u00f3digo fuente:</p> <pre><code>public Class MiClase {\n    public static void main(String[] args) {\n        System.out.println(\"Espa\u00f1a es as\u00ed.\");\n    }\n}\n</code></pre> <p>y lo compilamos con: <code>javac .\\MiClase.java</code>.</p> <p>Obtendremos la clase <code>MiClase.class</code>, que al ejecutar con el comando <code>java MiClase</code> mostrar\u00e1 por pantalla <code>Espa\u00c3\u00b1a es as\u00c3\u00ad.</code>.</p> <p>Para corregir esto hemos de indicarle al compilador que nuestro c\u00f3digo fuente est\u00e1 codificado con formato Unicode de la siguiente manera: <code>javac -encoding utf8 MiClase.java</code>. Si a continuaci\u00f3n ejecutamos el programa:</p> <pre><code>java MiClase\nEspa\u00f1a es as\u00ed.\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#clases-jars-classpath-y-otras-cosas-de-meter","title":"Clases, JARs, <code>CLASSPATH</code> y otras cosas de meter","text":"<p>Cuando empecemos a programar usando el modelo de orientaci\u00f3n a objetos nos encontraremos creado librer\u00edas para nuestro proyecto, as\u00ed como utilizando librer\u00edas de terceros. Para que <code>javac</code> y luego <code>java</code> puedan localizar las librer\u00edas que utilizamos (en definitiva los archivos <code>.class</code>) hemos de indic\u00e1rselo y para ello disponemos de dos formas (cada una con sus cosas):</p> <ul> <li>Variable de entorno <code>CLASSPATH</code>. NO RECOMENDABLE.</li> <li>Opciones <code>-cp</code>, <code>-classpath</code> o <code>-class-path</code> (son sin\u00f3nimos) tanto para <code>javac</code> como para <code>java</code>.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#variable-classpath","title":"Variable <code>CLASSPATH</code>","text":"<p>La variable <code>CLASSPATH</code> contendr\u00e1 una lista de uno o m\u00e1s directorios. Estos directorios son en los que <code>javac</code> y <code>java</code> buscar\u00e1n las clases que indiquemos en las sentencias <code>import</code> de nuestro c\u00f3digo. Com\u00fanmente hemos de indicar el directorio <code>lib</code> de nuestra instalaci\u00f3n de JDK (<code>C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.4.101-hotspot\\lib</code> en nuestro caso), tambi\u00e9n a\u00f1adiremos el directorio actual <code>.</code> para que se puedan encontrar las clases de nuestro directorio. Adem\u00e1s deberemos de indicar el directorio a donde vayamos a guardar las clases de terceros / librer\u00edas que vayamos a utilizar.</p> <p>Si hacemos esto en principio no deber\u00edamos de tener ning\u00fan problema... NING\u00daN PROBLEMA** (JA JA JA JA JA...).</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#opcion-cp","title":"Opci\u00f3n <code>-cp</code>","text":"<p>La opci\u00f3n <code>-cp</code> sobrescribe a <code>CLASSPATH</code>. De manera que si usamos <code>-cp</code> el valor que tenga <code>CLASSPATH</code> ser\u00e1 irrelevante. Con esta opci\u00f3n indicamos expl\u00edcitamente los directorios donde se encontrar\u00e1n las clases que usamos en nuestro proyecto.</p> <p>La sintaxis en la siguiente:</p> <ul> <li>Linux: <code>-cp &lt;directorio de clases 1&gt;:&lt;directorio de clases 2&gt;:...</code>.</li> <li>Windows <code>-cp &lt;directorio de clases 1&gt;;&lt;directorio de clases 2&gt;;...</code>.</li> </ul> <p>N\u00f3tese la diferencia en el separador de directorios \":\" en sistemas Linux y \";\" en Windows.</p> <p>Adem\u00e1s de esto es conveniente entrecomillar la lista:</p> <pre><code>javac -cp './lib;.' ./MiClase.java\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#whiskey-in-the-jars","title":"Whiskey in the JARs","text":"<p>Los archivos <code>.jar</code> consisten fundamentalmente en la estructura de directorios-paquetes de un conjunto de clases de Java (= librer\u00edas). Lo m\u00e1s importante que hemos de tener en cuenta es que, a efectos del CLASSPATH y la opci\u00f3n -cp, un JAR  es un directorio.</p> <p>Repito.</p> <p>UN .jar CUENTA COMO SI FUESE UN DIRECTORIO.</p> <p>Esto implica que si hemos descargado un archivo <code>jar</code> de terceros para usar en nuestro proyecto hemos de realizar alguna de las siguientes acciones:</p> <ul> <li>A\u00f1adirlo a nuestra variable <code>CLASSPATH</code> (<code>CLASSPATH=C:\\libs\\libreria_descargada1.jar;C:\\libs\\libreria_descargada2.jar</code>).</li> <li>Indicarlo expl\u00edcitamente en la opci\u00f3n <code>-cp</code>: <code>-cp 'C:\\libs\\libreria_descargada.jar;.</code>.</li> <li>Descomprimirla dentro de un directorio incluido en <code>CLASSPATH</code> o <code>-cp</code>.</li> <li>O decirle a nuestro EID que lo incluya. LA M\u00c1S RECOMENDABLE.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.0%20-%20Primeros_pasos_java/#comentarios","title":"Comentarios","text":"<p>Cuando escribamos c\u00f3digo en cualquier lenguaje hemos de tener presente que no seremos \u00fanicamente nosotros los que tendremos que entender y posiblemente modificar ese c\u00f3digo. Para ello, cuando estimemos que algo puede ser confuso (para nuestro yo futuro o para otra persona), es conveniente comentar el c\u00f3digo.</p> <p>En Java hay tres tipos de comentarios:</p> <ul> <li>Comentario de una l\u00ednea: Se indica escribiendo <code>//</code> antes de comenzar a escribir el comentario.</li> </ul> <pre><code>int a = 10;\nint b = 10;\nint c = a + b; // Esto no hace falta ni comentarlo.\n</code></pre> <ul> <li>Comentario de varias l\u00edneas: Se indica escribiendo <code>/*</code> al comienzo de las l\u00edneas de comentario y <code>*/</code> al final:</li> </ul> <pre><code>/* Y esto es un ejemplo de como se puede escribir un comentario\nque se extienda varias l\u00edneas. */\nString str = \"Hola mundo\";\nSystem.out.println(str);\n</code></pre> <ul> <li>Comentarios para Javadoc: Los comentarios para Javadoc son similares a los comentarios para varias l\u00edneas pero comienzan con <code>/**</code> en lugar de <code>/*</code>.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.1%20-%20Variables/","title":"Tema 2.1: Variables","text":"<p>Una variable es un nombre que estar\u00e1 enlazado con un espacio de memoria donde se podr\u00e1 almacenar alg\u00fan dato.</p> <p>Para poder utilizar una variable en Java habr\u00e1 de declararla antes.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.1%20-%20Variables/#declaracion-de-una-variable","title":"Declaraci\u00f3n de una variable","text":"<p>Para declarar una variable lo primero que hemos de indicar es el tipo de dato de la misma. El tipo de dato determina que tipo de valores podr\u00e1 contener la variable.</p> <p>A continuaci\u00f3n indicaremos el nombre de la variable.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.1%20-%20Variables/#limitaciones-en-nombres-de-variables","title":"Limitaciones en nombres de variables","text":"<p>La reglas que rigen el nombrado de las variables son las siguiente:</p> <ul> <li>Los nombres de variables distinguen entre may\u00fasculas y min\u00fasculas (La variable <code>Hola</code> es distinta de <code>hola</code>).</li> <li>Una variable ha de empezar con un car\u00e1cter unicode, el s\u00edmbolo <code>$</code> o el car\u00e1cter subrayado <code>_</code>.</li> <li>La convenci\u00f3n dice que el nombre de una variable ha de empezar con una letra min\u00fascula (y no con <code>$</code> o <code>_</code> aunque est\u00e9 permitido).</li> <li>No se permite el uso de espacios en blanco.</li> <li>Si el nombre elegido para la variable consta de varias palabras (\"c\u00f3digo\" \"libro\" por ejemplo) se pone en may\u00fasculas la primera letra de cada palabra a partir de la primera (\"codigoLibro\").</li> <li>Si la variable almacena una constante, se escribe todo el nombre con MAY\u00daSCULAS y se separar\u00e1n las palabras mediante el car\u00e1cter subrayado <code>_</code> (\"CODIGO_LIBRO\").</li> </ul> <p>Finalmente, y de manera opcional, podremos asignar un valor inicial al la variable utilizando el operador de asignaci\u00f3n <code>=</code>.</p> <pre><code>&lt;tipo de dato&gt; &lt;nombre de la variable&gt; [= valor];\n</code></pre> <pre><code>int x = 1;\nfloat y = 1.5;\nString texto = \"Hola mundo.\";\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.1%20-%20Variables/#variables-inferidas-var","title":"Variables inferidas: <code>var</code>","text":"<p>Desde la versi\u00f3n 10 del JDK tambi\u00e9n se pueden declarar variables utilizando la palabra clave <code>var</code>:</p> <pre><code>var a = 10;\n</code></pre> <p>En este caso el tipo de la variable <code>a</code> de determinar\u00e1 en el momento en que Java vea que se le est\u00e1 asignando el valor 10 (entero). Es decir, la m\u00e1quina virtual infiere el tipo de la variable y se lo asigna.</p> <p>Una vez se le a asignado un tipo la variable <code>a</code> s\u00f3lo podr\u00e1 contener valores de dicho tipo.</p> <p>En nuestro ejemplo el siguiente c\u00f3digo dar\u00eda error de compilaci\u00f3n:</p> <pre><code>var a = 10;\n//...\na = 1.5;\n</code></pre> <p><code>Type mismatch: cannot convert from double to int\"</code>.</p> <p>Ya que en Java los n\u00fameros con cifras decimales se consideran del tipo <code>double</code> (n\u00famero en coma flotante de doble precisi\u00f3n) y <code>a</code> ser\u00e1 una variable de tipo <code>int</code> ya que le asignamos un valor entero.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/","title":"Tema 2.2: Tipos de datos","text":"<p>Java es un lenguaje de tipado est\u00e1tico. Esto quiere decir que hay que indicar siempre el tipo de dato de una variable.</p> <p>Por esto se dice tambi\u00e9n que Java es fuertemente tipado.</p> <p>Un tipo de dato es una declaraci\u00f3n mediante la que se indica el contenido que podr\u00e1 tener una variable.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#consecuencias","title":"Consecuencias","text":"<p>Si intentamos guardar en una variable un dato que no encaja con el que hemos indicado en la declaraci\u00f3n se producir\u00e1 un error de compilaci\u00f3n.</p> <pre><code>int x;\nx = 12.5;\n</code></pre> <pre><code>.\\tarea1\\MiNombre.java:4: error: incompatible types: possible lossy conversion from double to int\n        x = 1.2;\n            ^\n1 error\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#tipos-primitivos","title":"Tipos primitivos","text":"<p>Estos tipos de datos de base tienen como \u00fanica caracter\u00edstica que no son objetos. El resto de elementos del lenguaje Java son objetos.</p> <ul> <li>byte: n\u00fameros enteros que se pueden representar mediante un byte (8 bits). Es decir, los n\u00fameros entre el -128 y el 127 (ambos inclusive).</li> <li>short: n\u00fameros enteros de 16 bits. Los valores enteros entre -32 768 y 32 767.</li> <li>int: similar a los anteriores pero usando 32 bits ($-2^31$)</li> <li>long: lo mismo pero con 64 bits.</li> <li>float: n\u00fameros reales expresados mediante 32 bits.</li> <li>double: n\u00fameros reales representados mediante 64 bits.</li> <li>boolean: dos valore (l\u00f3gicos) posibles: true y false. Utiliza un bit de datos.</li> <li>char*: representa un car\u00e1cter Unicode de 16 bits.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#nota","title":"Nota","text":"<p>Java toma cualquier dato entero como <code>10.5</code> por defecto como <code>double</code> (aunque pueda ser almacenado sin problemas como <code>float</code>). Lo normal es que siempre se use <code>double</code> cuando trabajemos con n\u00fameros reales.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#y-no-hay-mas-tipos-de-datos","title":"\u00bfY no hay m\u00e1s tipos de datos?","text":"<p>El resto de tipos de datos en Java son objetos.</p> <p>Algunos tipos de datos, aunque sean objetos, tienen comportamientos especiales para facilitar la escritura de c\u00f3digo. Un ejemplo son los tipos String y Array.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#tipo-string","title":"Tipo <code>String</code>","text":"<p>El tipo String se utiliza para almacenar y realizar operaciones sobre cadenas de caracteres.</p> <p>Para crear una variable que haga referencia a una cadena de caracteres escribiremos los siguiente:</p> <pre><code>String str = \"Hola mundo.\";\n</code></pre> <p>Esta es la forma abreviada de escribir el c\u00f3digo. La forma correcta teniendo en cuenta que String es un objeto ser\u00eda:</p> <pre><code>String str = new String(\"Hola mundo.\");\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#tipo-array","title":"Tipo Array","text":"<p>El tipo array (que veremos en detalle m\u00e1s adelante) consiste en una lista de tama\u00f1o fijo de elementos del mismo tipo.</p> <pre><code>// Para definir un array de 10 elementos int:\nint[] enteros = new int[10];\n// Para crearlo con valores iniciales:\nint[] tresEnteros = {1, 2, 3};\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores","title":"Operadores","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-postfijo-post-indecremento","title":"Operadores postfijo / post-(in/de)cremento","text":"<p>Estos operadores valen para incrementar (<code>++</code>) o decrementar (<code>--</code>) en una unidad el valor de una variable.</p> <p>Tambi\u00e9n se llaman incremento (decremento) diferido.</p> <pre><code>int x = 1;\nx++; // x pasa a valer 2.\nSystem.out.println(x); // Se mostrar\u00e1 el valor 2.\nx--; // x pasa a valer 1.*\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-prefijo-pre-indecremento","title":"Operadores prefijo / pre-(in/de)cremento","text":"<p>Son similares a los anteriores pero con menor prioridad:</p> <pre><code>int x = 1;\n++x; // x pasa a valer 2.\n--x; // x pasa a valer 1.\n</code></pre> <p>La diferencia entre los operadores unarios pre y post incremento / decremento es la siguiente:</p> <ul> <li>pre-incremento/decremento se modifica directamente el valor de la variable.</li> <li>post-incremento/decremento primero se usa el valor actual de la variable y a continuaci\u00f3n se incrementa.</li> </ul> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>// Pre-incremento.\nint x = 0;\nint y = 0;\nint z = ++x + ++y;\n// z tiene el valor 2.\n// x e y tienen el valor 1.\nSystem.out.println(\"z = \" + z);\nSystem.out.println(\"x = \" + z);\nSystem.out.println(\"y = \" + z);\n</code></pre> <pre><code>// Post-incremento.\nint x = 0;\nint y = 0;\nint z = x++ + y++;\n// Primero se usan los valores ACTUALES de x e y para la operaci\u00f3n (suma).\n// por lo que z tomar\u00e1 el valor 0.\n// A continuaci\u00f3n se incrementan.\nSystem.out.println(\"z = \" + z);\nSystem.out.println(\"x = \" + z);\nSystem.out.println(\"y = \" + z);\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos sirven, como su nombre indica, para realizar operaciones aritm\u00e9ticas. La prioridad de ejecuci\u00f3n entre ellos es la com\u00fan entre las calculadores y el uso general:</p> <pre><code>int a = 10; // Operador de asignaci\u00f3n =. Asigna a una variable un valor.\nint b = 20;\nint d = 30;\n\nd = a * b; // Asignamos a c el producto de a por b.\nd = a / b; \nd = a % b; // Operador m\u00f3dulo que guarda en c el RESTO de la division de a entre b.\nd = a + b * c; // Primero multiplicamos b por c y al resultado le a\u00f1adimos a.\nd = a - b * c; // Le restamos a a el producto de b por c.\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-a-nivel-de-bit","title":"Operadores a nivel de bit","text":"<ul> <li><code>&lt;&lt;</code>: Desplaza el n\u00famero a su izquierda tantas posiciones como indique el n\u00famero a su derecha:</li> </ul> <pre><code>int a = 1; // 0001 en binario.\nint b = 3; \nint c = a &lt;&lt; b;\nSystem.out.println(c); // Mostrar\u00e1 el valor 8 (1000)\n</code></pre> <ul> <li><code>&gt;&gt;</code>: Igual que el anterior pero desplazando a la derecha:</li> </ul> <pre><code>int a = 8; // 1000.\nint b = 3;\ninc c = a &gt;&gt; b;\nSystem.out.println(c); // Mostrar\u00e1 1 en pantalla.\n</code></pre> <ul> <li> <p><code>&amp;</code>: And a nivel de bits.</p> </li> <li> <p><code>|</code>: Or a nivel de bits.</p> </li> <li> <p><code>^</code>: Xor a nivel de bits.</p> </li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores sirven para comparar dos valores. Devolver\u00e1n true o false dependiendo de si la comparaci\u00f3n es cierta o no.</p> <ul> <li><code>==</code>: El operador igual compara si dos valores son iguales.</li> </ul> <pre><code>int a = 1;\nint b = 2;\nSystem.out.println(a == b); // Mostrar\u00e1 false.\nSystem.out.println(a == b - 1); // Mostrar\u00e1 true.\n</code></pre> <ul> <li><code>!=</code>: El operador distinto devolver\u00e1 cierto cuando los dos valores comparados sean distintos:</li> </ul> <pre><code>int a = 1;\nint b = 2;\nSystem.out.println(a != b); // Mostrar\u00e1 true.\nSystem.out.println(a != b - 1); // Mostrar\u00e1 false.\n</code></pre> <ul> <li><code>&gt;</code> y <code>&gt;=</code>: Los operadores mayor y mayor o igual realizan dicha comparaci\u00f3n:</li> </ul> <pre><code>int a = 0;\nint b = 10;\nint c = 10;\nboolean resultado = a &gt; b; // resultado ser\u00e1 igual a false.\nresultado = b &gt;= c; // resultado ser\u00e1 igual a true.\n</code></pre> <ul> <li><code>&lt;</code> y <code>&lt;=</code>: Son similares a los anteriores.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores sirven para:</p> <ul> <li>negar (operador <code>!</code>) un valor:</li> </ul> <pre><code>boolean t = true; // Asignamos verdadero a t.\nboolean f = !b; // Asignamos no verdadero (= falso) a f.\nSystem.out.prinln(f); // Mostrar\u00e1 false por pantalla.\n</code></pre> <ul> <li>Hacer la operaci\u00f3n y (and) de dos valores (operador <code>&amp;&amp;</code>):</li> </ul> <pre><code>boolean t = true;\nboolean f = false;\nSystem.out.println(t &amp;&amp; f); // true &amp;&amp; false es igual a false.\nSystem.out.pringln(t &amp;&amp; t); // true &amp;&amp; true es igual a true.\n</code></pre> <ul> <li>Hacer la operaci\u00f3n o (or) de dos valores (operador <code>||</code>):</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operador-ternario","title":"Operador ternario","text":"<p>No es conveniente usarlo ya que vuelve el c\u00f3digo dif\u00edcil de seguir.</p> <p>Tiene tres partes: (condici\u00f3n) ? (resultado si condici\u00f3n true) : (resultado si condici\u00f3n false);</p> <pre><code>int a = 10;\nint b = 20;\nSystem.out.println(a == b ? \"a igual a b\" : \"a distinto de b.\"); // Mostrar\u00e1 \"a distinto de b.\" por pantalla.\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#operador-de-asignacion","title":"Operador de asignaci\u00f3n","text":"<p>S\u00f3lo hay uno <code>=</code> y sirve para asignar un valor a una variable:</p> <pre><code>String a = \"un valor\";\nString b = a;\nboolean c = a == b; // \u00bfCu\u00e1l ser\u00e1 el valor de c?\nb = \"un valor\";\nc = a == b; // \u00bfY ahora?\nb = new String(\"un valor\");\nc = a == b; // \u00bf\u00bfY AHORA??\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.2%20-%20Tipos%20de%20datos/#nota-1","title":"NOTA 1","text":"<p>El operador de asignaci\u00f3n, adem\u00e1s de asignar un valor a una variable, devuelve dicho valor como resultado:</p> <pre><code>int x, y, z;\n\nx = 10;\ny = 20;\n\nint k = (z = x + y);\n\n// Primero se asigna el valor 10 + 20 a z.\n// Despu\u00e9s, el operador = devuelve el valor 30.\n// Finalmente se asigna 30 a k.\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.3%20-%20Tipos_envoltorio/","title":"Tema 2.3: Tipos envoltorio","text":"<p>Vimos en el cap\u00edtulo anterior que en Java existen unos tipos de datos b\u00e1sicos o primitivos (byte, short, int, long, float, double y boolean) que no son objetos. Esto permite que las operaciones con estos tipos sean m\u00e1s \u00e1giles que si tuvi\u00e9semos que operar utilizando clases que los representasen.</p> <p>Una de las recomendaciones para escribir programas Java que sean efectivos (en tiempo y memoria) es evitar la construcci\u00f3n de objetos innecesaria. La existencia de tipos primitivos facilita cumplir esta recomendaci\u00f3n.</p> <p>No obstante sigue siendo necesario disponer de funciones para realizar operaciones con valores de estos tipos de datos, como por ejemplo convertir una cadena de texto a un valor entero o la operaci\u00f3n inversa:</p> <pre><code>String input_num = c.readLine();\nint i = Integer.parseInt(input_num);\n// o el paso inverso:\nString str_int = Integer.toString(i);\n</code></pre> <p>Para centralizar todas estas operaciones se crearon las clases envoltorio (wrapper):</p> <ul> <li><code>Byte</code> para el tipo primitivo <code>byte</code>.</li> <li><code>Short</code> para <code>short</code></li> <li><code>Integer</code> para <code>int</code></li> <li><code>Long</code> para <code>long</code></li> <li><code>Float</code> para <code>float</code></li> <li><code>Double</code> para <code>double</code></li> <li><code>Character</code> para <code>char</code></li> <li><code>Boolean</code> para <code>boolean</code></li> </ul> <p>Las clases envoltorio tambi\u00e9n se pueden usar para crear objetos que representen datos de los tipos a los que envuelven. As\u00ed:</p> <pre><code>Integer diez = new Integer(10);\ndiez.toString();\nbyte_diez = diez.byteValue();\n</code></pre> <p>el c\u00f3digo anterior crea un objeto, <code>diez</code>, de la case <code>Integer</code> que contiene el valor entero 10 y sobre el que se pueden invocar m\u00e9todos como convertirlo a cadena de caracteres o a un tipo <code>byte</code>.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.3%20-%20Tipos_envoltorio/#tamano-en-bytes-valores-maximos-y-minimos","title":"Tama\u00f1o en bytes, valores m\u00e1ximos y m\u00ednimos","text":"<p>Los tipos envoltorio, adem\u00e1s de disponer de m\u00e9todos para convertir un texto en el valor representado y viceversa, tambi\u00e9n contienen cierta informaci\u00f3n sobre el tipo de datos que almacenan. As\u00ed, <code>Integer</code> por ejemplo, tiene las constantes:</p> <ul> <li><code>SIZE</code>: Indica el tama\u00f1o en bits del tipo de datos.</li> <li><code>BYTES</code>: El n\u00famero de bytes que ocupa el dato.</li> <li><code>MAX_VALUE</code>: El valor m\u00e1ximo que puede almacenar.</li> <li><code>MIN_VALUE</code>: El menor valor.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/","title":"Tema 2.4: Cadenas de caracteres","text":"<p>Las cadenas de caracteres se utilizan en los lenguajes de programaci\u00f3n para, b\u00e1sicamente, almacenar texto.</p> <p>La representaci\u00f3n interna de las mismas var\u00eda de lenguaje a lenguaje y, en el caso de Java, se implementan utilizando la case <code>String</code>.</p> <p>La clase <code>String</code> representa secuencias de caracteres. Todos los literales cadena como \"abc\" se implementan mediante instancias de la clase <code>String</code>.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#la-clase-string","title":"La clase <code>String</code>","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#inmutables","title":"Inmutables","text":"<p>Video sobre la inmutabilidad de las cadenas en Java</p> <p>Los cadenas de tipo <code>String</code> son inmutables. Sus valores no pueden ser modificados despu\u00e9s de su creaci\u00f3n.</p> <p>Gracias a esto, si utilizamos el mismo texto varias veces en nuestro programa, en lugar de crear una cadena nueva la JVM mirar\u00e1 en la lista de palabras usadas si existe un text igual al que queremos utilizar y devolver\u00e1 una referencia al mismo.</p> <p>De este modo si creamos 1000 cadenas con el contenido \"hola mundo\" Java s\u00f3lo guardar\u00e1 este texto una vez en memoria.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#que-quiere-decir-inmutable-exactamente","title":"\u00bfQu\u00e9 quiere decir inmutable exactamente?","text":"<p>Cuando creamos un Objeto String, sus datos no podr\u00e1n ser modificados. En lugar de ello, siempre que modifiquemos una cadena lo que estaremos haciendo en realidad es crear una cadena nueva con los nuevos cambios:</p> <pre><code>String str1 = \"Hola mundo\"; // Creamos un objeto cadena con el contenido \"Hola mundo\".\nString str2 = \"Hola mundo\"; // Creamos otro objeto cadena con el mismo contenido.\nstr1 = str1.toUpperCase();\n\nSystem.out.printf(\"%s.%n\", str1); // Mostrar\u00e1 el texto: \"HOLA MUNDO.\".\nSystem.out.printf(\"%s.%n\", str2); // Mostrar\u00e1 el texto: \"Hola Mundo.\".\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#impacto-en-la-memoria","title":"Impacto en la memoria","text":"<p>Como dijimos antes Java, en lugar de crear una cadena directamente mira en su lista de palabras a ver si ya existe. Si no existe reserva memoria para ella y la guarda en la lista de palabras por si habr\u00e1 que hacer uso de ella m\u00e1s tarde.</p> <p>Esto significa tambi\u00e9n que si leemos 1000 000 DNIs de una base de datos, aunque solo nos quedemos con el \u00faltimo, todos esos valores ser ir\u00e1n a\u00f1adiendo a la lista de palabras usadas. Lo que podr\u00eda hacer que esta lista (y la memoria que ocupa) fuese creciendo indefinidamente.</p> <p>Adem\u00e1s si nuestro programa fuese a hacer muchos cambios a cadenas de texto (quitarle la letra al DNI pro ejemplo) podr\u00edamos usar mucha memoria ya que cada cambio supondr\u00eda crear una nueva cadena (DNI y DNI sin letra).</p> <p>Para evitar esto Java, adem\u00e1s de la clase <code>String</code> para tratar con cadenas tambi\u00e9n tiene la clase <code>StringBuffer</code> que permite modificar cadenas sin generar nuevas cadenas inmutables en el proceso.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#caracteres-especiales","title":"Caracteres especiales","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#caracter-de-escape","title":"Car\u00e1cter de escape","text":"<p>El car\u00e1cter \\ se denomina backslash y sirve para escapar caracteres que de otra forma no podr\u00edan escribirse en una cadena.</p> <p>Por ejemplo, si queremos escribir \" dentro de una cadena Java interpretar\u00eda estas comillas como el indicador de fin de cadena. Para evitar eso usaremos el car\u00e1cter de escape:</p> <pre><code>String ejemplo = \"Ella me dijo \\\"no te preocupes\\\"\";\n</code></pre> <p>Lo mismo sucede con \\ y '. Que han de ir precedidos del car\u00e1cter de escape para que se muestren correctamente.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#secuencias-de-escape-comunes","title":"Secuencias de escape comunes","text":"<p>Otros s\u00edmbolos que se escriben utilizando el car\u00e1cter de escape son los siguientes:</p> <ul> <li>\\n Nueve l\u00ednea.</li> <li>\\r Retorno de carro.</li> <li>\\t Tabulaci\u00f3n.</li> <li>\\b Borrar.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#funciones-de-string","title":"Funciones de <code>String</code>","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#longitud-de-una-cadena","title":"Longitud de una cadena","text":"<p>El m\u00e9todo <code>length</code> nos devuelve un valor entero que indica cuantos caracteres contiene la cadena:</p> <pre><code>String cadena = \"Hola mundo\";\nint longitud = cadena.length();\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#pasar-a-mayusculas-minusculas","title":"Pasar a may\u00fasculas / min\u00fasculas","text":"<p>Los m\u00e9todos <code>toUpperCase</code> y <code>toLowerCase</code> nos devolver\u00e1n una cadena similar a la nuestra pero con todos los caracteres en may\u00fasculas o min\u00fasculas.</p> <pre><code>String error = \"ERROR\";\nSystem.out.println(\"Has cometido un \" + error.toUpperCase());\n/*\n   Mostrar\u00e1: \"Has cometido un ERROR\".\n*/\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#encontrar-una-cadena-dentro-de-otra","title":"Encontrar una cadena dentro de otra","text":"<p>Para comprobar si una cadena aparece dentro de otra cadena podemos usar el m\u00e9todo <code>indexOf</code>. El m\u00e9todo <code>indexOf</code> devuelve la posici\u00f3n (empezando a contar en 0) donde aparece la primera ocurrencia de la cadena buscada y -1 en caso de no encontrar la cadena.</p> <pre><code>String txt = \"La raz\u00f3n de la sinraz\u00f3n...\";\n\nint position = txt.indexOf(\"sinraz\u00f3n\");\n\nSystem.out.printf(\"La palabra sinraz\u00f3n se encuentra el la posici\u00f3n: %d.%n\", position);\n</code></pre> <p>Si lo \u00fanico que queremos es saber si una cadena contiene a otra podremos usar el m\u00e9todo <code>contains</code> que devolver\u00e1 simplemente <code>true</code> o <code>false</code>.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#obtener-un-fragmento-de-la-cadena","title":"Obtener un fragmento de la cadena","text":"<p>Para extraer un fragmento de una cadena podremos emplear el m\u00e9todo <code>subString</code>. \u00c9ste acepta dos valores enteros para indicar d\u00f3nde empezaremos a copiar y hasta donde. <code>subString</code> copia desde la posici\u00f3n inicial (incluy\u00e9ndola) hasta la posici\u00f3n final (sin incluirla). As\u00ed si queremos copiar el texto entre las posiciones 4 y 9 (inclusive) de la cadena \"ornitorrinco\" escribir\u00edamos:</p> <pre><code>String cadena = \"ornitorrinco\";\nString subCadena = cadena.subString(4, 10)\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#determinar-si-una-cadena-es-vacia","title":"Determinar si una cadena es vac\u00eda","text":"<p>Para determinar si tenemos una cadena vac\u00eda podemos usar el m\u00e9todo <code>isEmpty</code> que devolver\u00e1 <code>true</code> si la longitud de la cadena es 0 y <code>false</code> en caso contrario.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#comparacion-de-cadenas","title":"Comparaci\u00f3n de cadenas","text":"<p>Para comparar dos cadenas tenemos varias opciones.</p> <p>En primer lugar podr\u00edamos usar el operador de comparaci\u00f3n <code>==</code>. Este operador funciona perfectamente cuando comparamos variables que contienen tipos primitivos, pero hemos de recordar que las cadenas (<code>String</code>) no son tipos primitivos si no objetos.</p> <p>El operador <code>==</code>, cuando se aplica a variables que contienen objetos comprueba si los objetos contenidos por las variables son EL MISMO. Ve\u00e1moslo con un ejemplo:</p> <pre><code>// Declaramos una variable cadena:\nString str1 = \"hola\";\nString str2 = \"hola\";\n\n/* \nCuando creamos as\u00ed las cadenas Java no crea dos objetos.\nDetecta que ya tiene un objeto cadena con el texto \"hola\" y se la asigna a la variable str2.\nPor esto veremos que str1 == str2 ser\u00e1 cierto. Son el mismo objeto:\n*/\n\nif (str1 == str2) {\n  System.out.println(\"Los dos objetos son iguales.\"); // Se mostrar\u00e1 este mensaje.\n} else {\n  System.out.println(\"Los dos objetos son distintos.\");\n}\n\n// Ahora bien, si creamos la cadena usando el constructor `String()` s\u00ed se crear\u00e1 un nuevo objeto:\n\nstr2 = new String(\"hola\");\n\nif (str1 == str2) {\n  System.out.println(\"Los dos objetos son iguales.\");\n} else {\n  System.out.println(\"Los dos objetos son distintos.\"); // Esta vez se mostrar\u00e1 este otro.\n}\n</code></pre> <p>Para comparar el contenido de dos cadenas (sin importarnos si son el mismo objeto o no) hemos de usar el m\u00e9todo <code>equals</code>:</p> <pre><code>String str1 = new String(\"hola\");\nString str2 = new String(\"hola\");\n\nif (str1 == str2) {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" son el mismo objeto.\");\n} else if (str1.equals(str2)) {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" NO SON el mismo objeto pero son cadenas iguales.\"); // Se mostrar\u00e1 este texto.\n} else {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" NO SON el mismo objeto NI TIENEN el mismo contenido.\");\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.4%20-%20Cadenas_de_caracteres/#cadenas-con-formato","title":"Cadenas con formato","text":"<p>Hasta este momento estuvimos usando la concatenaci\u00f3n para mostrar cadenas con valores num\u00e9ricos y de otro tipo que hab\u00edamos calculado en nuestros programas:</p> <pre><code>System.out.println(\"Hola \" + nombre + \".\");\n</code></pre> <p>Otra forma de realizar esto es mediante el uso de cadenas con formato:</p> <pre><code>System.out.printf(\"Hola %s.%n\", nombre);\n</code></pre> <p>La forma t\u00edpica de crear cadenas con formato es usando el m\u00e9todo <code>format()</code> de la clase <code>String</code>:</p> <pre><code>String nombre = \"Manuel\";\nint numero = 7;\n\nString str_out = String.format(\"Hola %s tu n\u00famero de la suerte es %d.\", nombre, numero);\nSystem.out.println(str_out);\n</code></pre> <ul> <li><code>%a</code> : Acepta <code>float</code> y genera la representaci\u00f3n hexadecimal del n\u00famero.</li> </ul> <pre><code>System.out.printf(\"%a\", 1.25f);\n//Muestra: 0x1.0p4\n</code></pre> <ul> <li> <p><code>%b</code>: Acepta cualquier tipo y devuelve \"true\" si el argumento es true o no nulo y \"false\" en caso contrario.</p> </li> <li> <p><code>%c</code>: Acepta caracteres unicode y los representa.</p> </li> <li> <p><code>%d</code>: Acepta cualquier valor entero (byte, short, int, long o bigint) y lo representa.</p> </li> <li> <p><code>%e</code>: Acepta un float y lo representa en notaci\u00f3n cient\u00edfica:</p> </li> </ul> <pre><code>System.out.printf(\"%e\", 1.25f);\n// Muestra: 1,250000e+00\n</code></pre> <ul> <li> <p><code>%f</code>: Acepta y representa n\u00fameros float.</p> </li> <li> <p><code>%g</code>: Acepta n\u00fameros reales float y los representa de distintas formas dependiendo de la precisi\u00f3n.</p> </li> <li> <p><code>%h</code>: Acepta cualquier tipo y representa su c\u00f3digo hash (resultado del m\u00e9todo <code>hashCode()</code>).</p> </li> <li> <p><code>%n</code>: No acepta ning\u00fan argumento. Genera una separaci\u00f3n de l\u00edneas compatible con la plataforma en la que estemos programando.</p> </li> <li> <p><code>%o</code>:  Genera la representaci\u00f3n octal de un valor entero.</p> </li> <li> <p><code>%s</code>: Acepta cualquier tipo y lo representa como un cadena de caracteres.</p> </li> <li> <p><code>%t</code>:  Acepta un valor que represente una fecha u hora. La conversi\u00f3n es m\u00e1s compleja como veremos m\u00e1s adelante.</p> </li> <li> <p><code>%x</code>: Representa un valor entero en forma hexadecimal.</p> </li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/","title":"Tema 2.5: Arrays","text":"<p>Un array es una estructura de datos que permite almacenar una secuencia ordenada de elementos. En Java todos los elementos de un array han del ser del mismo tipo y la longitud del mismo ser\u00e1 determinada en el momento de su creaci\u00f3n.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#sintaxis","title":"Sintaxis","text":"<p>Para definir una variable de tipo <code>Array</code> hemos de escribir lo siguiente.</p> <pre><code>tipoDeDato[] nombre;\n</code></pre> <p>o bien:</p> <pre><code>tipoDeDato []nombre;\n</code></pre> <p>o bien:</p> <pre><code>tipoDeDato nombre[];\n</code></pre> <p>Para crear un objeto de la clase <code>Array</code> hemos de escribir:</p> <pre><code>arr = new tipoDeDato[tama\u00f1o];\n</code></pre> <p>As\u00ed, si queremos crear un array que pueda contener 100 n\u00fameros enteros escribiremos:</p> <pre><code>int[] enteros = new int[100];\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#manipular-un-array","title":"Manipular un array","text":"<p>Para acceder a cada posici\u00f3n del array lo haremos mediante la siguiente sintaxis:</p> <pre><code>String[] arrStr = {\"adi\u00f3s\", \"mundo\", \"cruel\"};\n\nString cadena = arrStr[0]; // guardamos la cadena \"adi\u00f3s\" en la variable \"cadena\".\n</code></pre> <p>Si queremos asignar un valor a una de las posiciones:</p> <pre><code>arrStr[0] = \"hola\";\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#recorrer-un-array","title":"Recorrer un array","text":"<p>Para recorrer todas las posiciones de un array hemos de usar un bucle.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#bucle-for","title":"Bucle <code>for</code>","text":"<p>Tradicionalmente para recorrer un array establec\u00edamos un bucle <code>for</code> y us\u00e1bamos un entero como \u00edndice avanzando desde cero hasta la longitud del array:</p> <pre><code>String[] strArr = new String[100];\n//...\n\nfor (int idx = 0; idx &lt; arr.length; ++idx) {\n    System.out.println(arr[idx]);\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#bucle-for-each","title":"Bucle \"for-each\"","text":"<p>Cuando lo \u00fanico que nos interesa es recorrer todas las posiciones del array podemos usar una versi\u00f3n especial del bucle for dise\u00f1ada especialmente para tal tarea:</p> <pre><code>int[] intArr = new int[100];\n\nfor (int value : arr) {\n    System.out.println(value);\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.5%20-%20Arrays/#arrays-multi-dimensionales","title":"Arrays multi-dimensionales","text":"<p>Un array multidimensional es un array que a su vez est\u00e1 compuesto de arrays:</p> <pre><code>int[][] intArrMulti = {{1, 2, 3}, {4, 5, 6, 7}};\n\nintArrMulti[0][0] = 3;\n</code></pre> <p>Como se puede ver en el ejemplo, el array no tiene porque tener todas las filas de la misma longitud.</p> <p>Para recorrer un array de este tipo usaremos bucles anidados:</p> <pre><code>int[][] intArrMulti = {{1, 2, 3}, {4, 5, 6, 7}};\n\nfor (int idxFil = 0; idxFil &lt; intArrMulti.length; ++idxFil) {\n    for (int idxCol = 0; idxCol &lt; intArrMulti[idxFil].length; ++idxCol) {\n        System.out.printf(\"Fila %d, columna %d = %d.%n\", idxFil, idxCol, intArrMulti[idxFil][idxCol]);\n    }\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/","title":"Tema 2.6: Estructuras de control","text":"<p>En Java hay tres sentencias de control:</p> <ul> <li>Condicionales: Se determina la ejecuci\u00f3n de cierto c\u00f3digo fuente dependiendo de una condici\u00f3n:</li> <li><code>if else</code> / <code>else if</code></li> <li><code>switch</code></li> <li>Repetitiva: Se repetir\u00e1 una secuencia de c\u00f3digo tantas veces como se indique o hasta que se cumpla (o deje de cumplirse) una condici\u00f3n:</li> <li><code>for</code></li> <li><code>while</code></li> <li><code>do ... while</code></li> <li>Salto incondicional: Se utilizan principalmente para saltar o salir de la ejecuci\u00f3n de una iteraci\u00f3n de un bucle:</li> <li><code>break</code>: Interrumpe la ejecuci\u00f3n.</li> <li><code>continue</code>: Salta hasta la siguiente iteraci\u00f3n.</li> </ul> <p>A una estructura de control repetitiva se la llama tambi\u00e9n bucle.</p> <p>Cada una de las veces que se ejecuta el c\u00f3digo de un bucle se dice que se ha producido una iteraci\u00f3n.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#estructuras-condicionales","title":"Estructuras condicionales","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#if-else-else-if","title":"<code>if else</code> / <code>else if</code>","text":"<p>Esta estructura permitir\u00e1 que se ejecute un bloque de c\u00f3digo u otro dependiendo de la condici\u00f3n.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>if (age &gt;= 18) {\n    // Bloque de c\u00f3digo A.\n    System.out.println(\"Eres mayor de edad.\");\n} else {\n    // Bloque de c\u00f3digo B.\n    System.out.println(\"Eres menor de edad.\");\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#variantes","title":"Variantes","text":"<p>Una variante ser\u00eda omitir la rama del else:</p> <pre><code>if (age &lt; 18) {\n    System.out.println(\"Eres menor.\");\n}\n</code></pre> <p>Otra variante consiste en anidar ifs:</p> <pre><code>if (edad &lt; 12) {\n    System.out.println(\"Eres muy joven para la peli.\");\n} else if (edad &gt;= 12 &amp;&amp; edad &lt; 18) {\n    System.out.println(\"Esta peli es para ti.\");\n} else {\n    System.out.println(\"Eres muy viejo para la peli.\");\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#switch","title":"<code>switch</code>","text":"<p>La instrucci\u00f3n switch se puede realizar mediante if else consecutivos. La idea es que switch sea m\u00e1s legible.</p> <p>La sintaxis de switch es la siguiente:</p> <pre><code>switch (valor_a_comparar) {\n    case valor_de_comparaci\u00f3n_1:\n        // C\u00f3digo a ejecutar si valor_a_comparar == valor_de_comparaci\u00f3n_1.\n        break;\n    case valor_de_comparaci\u00f3n_2:\n        // C\u00f3digo a ejecutar si valor_a_comparar == valor_de_comparaci\u00f3n_2.\n        break;\n    default: // Opcional.\n        // C\u00f3digo a ejecutar en caso de que se haya cumplido ninguna de las igualdades anteriores.\n}\n</code></pre> <p>Un ejemplo del uso de switch ser\u00eda:</p> <pre><code>Console c = System.console();\n\nSystem.out.print(\"Introduzca un n\u00famero entre 1 y 3: \");\nint value = Integer.parseInt(c.readLine());\n\nswitch (value) {\n    case 1: \n        System.out.println(\"El n\u00famero introducido fue uno.\");\n        break;\n    case 2:\n        System.out.println(\"El n\u00famero introducido fue dos.\");\n        break;\n    case 3:\n        System.out.println(\"El n\u00famero introducido fue tres.\");\n        break;\n    default:\n        System.out.println(\"El n\u00famero introducido no estaba entre 1 y 3.\");\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#estructuras-repetitivas-estructuras-iterativas-o-bucles","title":"Estructuras repetitivas (estructuras iterativas o bucles)","text":"<p>Estas estructuras determinan cuantas veces ha de repetirse un bloque de c\u00f3digo. Puede indicarse un n\u00famero fijo de repeticiones, como es el caso del <code>for</code> o establecer una condici\u00f3n para la repetici\u00f3n como es el caso del <code>while</code> y el <code>do while</code>.</p> <p></p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#for","title":"<code>for</code>","text":"<p>El bucle <code>for</code> tiene la siguiente sintaxis:</p> <pre><code>for (&lt;sentencia&gt;; &lt;condici\u00f3n&gt;; &lt;modificaci\u00f3n de la condici\u00f3n&gt;) {\n    // Bloque de c\u00f3digo a repetir\n}\n</code></pre> <p>as\u00ed, un bucle for que muestre los n\u00fameros del 1 al 100 ser\u00eda:</p> <pre><code>for (int i = 1; i &lt;= 100; i += 1) {\n    System.out.println(i);\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#while","title":"<code>while</code>","text":"<p>El bucle <code>while</code> tiene la siguiente sintaxis:</p> <pre><code>while (&lt;condici\u00f3n&gt;) {\n    // Bloque a repetir mientras se cumpla la condici\u00f3n.\n}\n</code></pre> <p>El mismo c\u00f3digo que muestre los n\u00fameros del 1 al 100 con un bucle while ser\u00eda:</p> <pre><code>int i = 1;\nwhile (i &lt;= 100) {\n    System.out.println(i);\n    i = i + 1;\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#do-while","title":"<code>do while</code>","text":"<p>La \u00fanica diferencia con los bucles anteriores es que en este siempre se ejecuta el bloque de c\u00f3digo al menos una vez:</p> <p>Su sintaxis es la siguiente:</p> <pre><code>do {\n    // Bloque a repetir\n} while (&lt;condici\u00f3n&gt;);\n</code></pre> <p>El mismo ejemplo de los casos anteriores con un bucle do while ser\u00eda:</p> <pre><code>int i = 0;\n\ndo {\n    System.out.println(++i);\n} while (i &lt; 100);\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#bucle-for","title":"Bucle <code>for</code>","text":"<p>El bucle for est\u00e1 pensado para repetir un bloque de instrucciones un n\u00famero fijo de veces que conocemos de antemano. Por ejemplo, tantas veces como elementos tenga un array.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#sintaxis","title":"Sintaxis","text":"<pre><code>for ((primera sentencia); (segunda sentencia); (tercera sentencia)) {\n    // Bloque de c\u00f3digo a repetir.\n}\n</code></pre> <p>Cada sentencia ser\u00e1 un bloque de c\u00f3digo con el contenido que se indica a a continuaci\u00f3n.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#primera-sentencia","title":"primera sentencia","text":"<p>Esta sentencia se ejecuta \u00fanicamente una vez antes de iniciar el bucle. Normalmente se declara y se le da valor a una variable que ir\u00e1 modific\u00e1ndose con cada iteraci\u00f3n del bucle.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#condicion-de-continuacion","title":"condici\u00f3n de continuaci\u00f3n","text":"<p>Mientras se cumpla la condici\u00f3n indicada en esta secci\u00f3n el bucle seguir\u00e1 repiti\u00e9ndose. Normalmente es una comparaci\u00f3n respecto a la variable declarada en la primera sentencia.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#segunda-sentencia","title":"segunda sentencia","text":"<p>Esta sentencia se ejecutar\u00e1 cada vez que se ejecute una iteraci\u00f3n del bucle. Normalmente modifica el valor de la variable declarada en la primera sentencia de modo que se acerque cada vez m\u00e1s al fin del bucle (a que la condici\u00f3n de continuaci\u00f3n deje de cumplirse).</p> <p>Un ejemplo con c\u00f3digo real ser\u00eda el siguiente:</p> <pre><code>for (int i = 0; i &lt; 100; i++) {\n    // Mostremos una l\u00ednea de texto por cada iteraci\u00f3n del bucle.\n    System.out.println(\"Iteraci\u00f3n n\u00famero \" + i);\n}\n</code></pre> <ol> <li>En la primera sentencia <code>int i = 0;</code> declaramos y le damos un valor inicial a la variable <code>i</code>.</li> <li>En la segunda sentencia establecemos la condici\u00f3n de terminaci\u00f3n del bucle: <code>i &lt; 100</code>: el bucle se repetir\u00e1 mientras sea cierto que <code>i</code> es menor que <code>100</code>.</li> <li>En la tercera sentencia <code>++i</code> el valor la variable <code>i</code> se incrementa de manera que nos vayamos acercando a la condici\u00f3n de terminaci\u00f3n.</li> </ol>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#sentencias-break-y-continue","title":"Sentencias <code>break</code> y <code>continue</code>","text":"<p>En algunos casos es necesario alterar el normal funcionamiento de un bucle.</p> <p>Imaginemos que normalmente un bucle se ejecutar\u00e1 diez veces pero que deseamos que termine si el usuario introduce un valor que no sea v\u00e1lido. Para forzar la terminaci\u00f3n del bucle, es decir, para romper la repetici\u00f3n usaremos la sentencia <code>break</code>.</p> <p>En otros casos puede que no deseamos terminar el bucle definitivamente pero s\u00ed deseamos saltar el resto del c\u00f3digo y pasar a la siguiente iteraci\u00f3n (o repetici\u00f3n) del bucle. Para ello hemos de usar la sentencia <code>continue</code>.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#break","title":"<code>break</code>","text":"<p>Veamos algunos ejemplos del funcionamiento de la sentencia <code>break</code> de terminaci\u00f3n de un bucle:</p> <p>Si deseamos terminar el bucle si encontramos el valor que no sea v\u00e1lido:</p> <pre><code>do {\n    // Imaginemos que hay un m\u00e9todo que genera un valor.\n    int valor = generaValor();\n\n    // El m\u00e9todo \"esValido\" devolver\u00e1 \"true\" o \"false\" dependiendo de si el valor es o no v\u00e1lido.\n    if (!esValido(valor)) {\n        // Si el valor es no v\u00e1lido salimos fuera del bucle.\n        break;\n    }\n\n    // C\u00f3digo para procesar el valor.\n    // ...\n\n} while (true);\n// C\u00f3digo exterior al bucle.\n// ...\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#continue","title":"<code>continue</code>","text":"<p>Veamos algunos ejemplos del funcionamiento de la sentencia <code>continue</code> de salto a la siguiente iteraci\u00f3n de un bucle:</p> <p>Si quisi\u00e9semos crear un bucle que se saltase las iteraciones m\u00faltiplo de tres podr\u00edamos escribir:</p> <pre><code>for (int i = 0; i &lt; 10; ++i) {\n    if (i % 3 == 0) {\n        continue; // No saltamos todo el c\u00f3digo hasta el principio del siguiente bucle.\n    }\n\n    System.out.println(\"Iteraci\u00f3n n\u00famero \" + i + \".\");\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.6%20-%20Estructuras%20de%20control/#formas-de-terminar-un-bucle","title":"Formas de terminar un bucle","text":"<p>Todo bucle (en general) deber\u00eda de disponer de alg\u00fan mecanismo de terminaci\u00f3n. As\u00ed, los bucles <code>while</code> y <code>do while</code> se repetir\u00edan mientras se cumpla una condici\u00f3n y el bucle <code>for</code> (y el for-each) se repetir\u00edan un n\u00famero predeterminado de veces.</p> <p>No obstante a veces es conveniente terminar un bucle antes de que se alcance la condici\u00f3n de terminaci\u00f3n est\u00e1ndar. Para ello disponemos de varios m\u00e9todos:</p> <ul> <li>Podemos usar la sentencia que acabamos de ver <code>break</code>. Que nos mover\u00e1 a la primera sentencia exterior al bucle.</li> <li>Otra forma de terminar (si estamos dentro de un m\u00e9todo) es retornar el resultado del m\u00e9todo utilizando la sentencia <code>return</code>.</li> <li>Finalmente otra forma de terminar un bucle es terminar la ejecuci\u00f3n del programa mediante la sentencia <code>System.exit(0)</code>.</li> </ul> <p>Un ejemplo de la conveniencia de terminaci\u00f3n anticipada de un bucle es cuando estamos comprobando si un valor se encuentra en un array. Para ello, en principio, hemos de recorrer todo el array comprobando posici\u00f3n a posici\u00f3n (imaginemos un array no ordenado). Pero una vez hayamos encontrado el elemento no necesitamos seguir comprobando el resto de elementos del array. As\u00ed un m\u00e9todo que compruebe si un array contiene un elemento podr\u00eda ser:</p> <pre><code>public static boolean contains(Object[] arr, Object buscado) {\n    for (Object obj : arr) {\n        // Si encontramos dos objetos iguales retornamos true \n        // (el objeto buscado est\u00e1 en el array).\n        if (obj.equals(buscado)) return true;\n    }\n    // Si hemos recorrido todo el array y no hemos encontrado el objeto\n    // buscado retornamos false.\n    return false;\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/","title":"Tema 2.7: Documentaci\u00f3n en Java","text":"<p>Todos los lenguajes de programaci\u00f3n presentan mecanismos para documentar el c\u00f3digo fuente. Podemos decir que hay dos niveles cuando hablamos de documentaci\u00f3n:</p> <ul> <li>Documentaci\u00f3n de una aplicaci\u00f3n web: documentaci\u00f3n que se genera a partir del c\u00f3digo fuente de la aplicaci\u00f3n y que genera un documento que describe el funcionamiento de cada elemento de la aplicaci\u00f3n.</li> <li>Documentaci\u00f3n en el c\u00f3digo fuente: comentarios que se incluyen en el c\u00f3digo fuente.</li> </ul> <p>En Java, la documentaci\u00f3n se realiza mediante comentarios.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#comentarios","title":"Comentarios","text":"<p>Esta es la forma m\u00e1s simple de explicar el funcionamiento de un fragmento de c\u00f3digo. Los comentarios se pueden incluir en cualquier parte del c\u00f3digo fuente y no afectan al funcionamiento del programa. Hay dos tipos de comentarios:</p> <ul> <li>Comentarios de una l\u00ednea: se inician con <code>//</code> y finalizan al final de la l\u00ednea.</li> <li>Comentarios de varias l\u00edneas: se inician con <code>/*</code> y finalizan con <code>*/</code>.</li> </ul> <pre><code>// Comentario de una l\u00ednea:\n// Es conveniente que los comentarios de una l\u00ednea no superen los 80/120\n// caracteres.\n// Si se superan los 80 / 120 caracteres es conveniente dividir el comentario\n// en varias l\u00edneas.\n// Si no se hace es probable que el editor de c\u00f3digo *divida* las l\u00edneas de\n// forma autom\u00e1tica.\n</code></pre> <p>Aunque los comentarios son muy \u00fatiles para dejar recordatorios o explicaciones sobre el c\u00f3digo, no es recomendable abusar de ellos y aplicarlos s\u00f3lo a aquellos fragmentos de c\u00f3digo que lo necesiten (por complejidad o por ser dif\u00edciles de entender).</p> <pre><code>/*\n * Comentario de varias l\u00edneas:\n * Es conveniente que los comentarios de varias l\u00edneas no superen los 80 / 120\n * caracteres.\n * Si se superan los 80 / 120 caracteres es conveniente dividir el comentario\n * en varias l\u00edneas.\n * Si no se hace es probable que el editor de c\u00f3digo *divida* las l\u00edneas de\n * forma autom\u00e1tica.\n */\n</code></pre> <pre><code>// Ejemplos de comentarios:\n// Cuando la l\u00ednea de c\u00f3digo y el comentario son muy cortos, se puede dejar el\n// comentario al final de la l\u00ednea:\n\nint a = 5; // Declaraci\u00f3n de una variable.\n\n// Cuando la l\u00ednea de c\u00f3digo y/o el comentario son muy largos, se puede dejar\n// el comentario en la l\u00ednea anterior (o siguiente):\n\n// Bucle for que recorre un array de enteros:\nfor (int i = 0; i &lt; numeros.length; i++) {\n    System.out.println(numeros[i]);\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#javadoc","title":"<code>Javadoc</code>","text":"<p>Javadoc es una herramienta que genera la documentaci\u00f3n de una aplicaci\u00f3n Java a partir del c\u00f3digo fuente. Esta herramienta se ejecuta desde la l\u00ednea de comandos (o con la ayuda de un IDE) y genera un documento HTML que describe el funcionamiento de cada interfaz, clase, m\u00e9todos, etc. de la aplicaci\u00f3n.</p> <p>La propia documentaci\u00f3n de Java est\u00e1ndar est\u00e1 generada con Javadoc.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#uso-de-javadoc","title":"Uso de Javadoc","text":"<p>Para usar Javadoc hemos de:</p> <ul> <li>Usar c\u00f3digo fuente que contiene comentarios en el format de Javadoc.</li> <li>Ejecutar la herramienta <code>javadoc</code>.</li> </ul> <p>Por defecto Javadoc genera un documento HTML.</p> <p>Una vez hemos incluido los comentarios Javadoc en nuestro c\u00f3digo fuente, podemos generar la documentaci\u00f3n ejecutando la herramienta <code>javadoc</code> desde la l\u00ednea de comandos.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#sintaxis-del-comando-javadoc","title":"Sintaxis del comando <code>javadoc</code>","text":"<pre><code>javadoc [opciones] [paquetes] [ficheros]\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#paquetes-y-ficheros","title":"<code>[paquetes]</code> y <code>[ficheros]</code>","text":"<p>Cuando queremos documentar un paquete, debemos indicar el nombre del paquete. Si queremos documentar varios paquetes, debemos separarlos por espacios:</p> <pre><code>javadoc ga.cotarelo.utils ga.cotarelo.ui ga.cotarelo.model\n</code></pre> <p>Si queremos documentar un fichero, debemos indicar el nombre del fichero:</p> <pre><code>javadoc ga.cotarelo.utils.Utils.java\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#parametros-de-javadoc","title":"Par\u00e1metros de Javadoc","text":"<p>Los principales par\u00e1metros de Javadoc son:</p> <ul> <li>La opci\u00f3n <code>-d docs</code> indica d\u00f3nde se va a generar la documentaci\u00f3n. En este caso, en la carpeta <code>docs</code>.</li> <li>La opci\u00f3n <code>-sourcepath src</code> indica d\u00f3nde se encuentra el c\u00f3digo fuente. En este caso, en la carpeta <code>src</code>.</li> <li>La opci\u00f3n <code>-encoding utf8</code> indica el tipo de codificaci\u00f3n de caracteres que se va a usar. En este caso, <code>utf8</code>.</li> <li>La opcion <code>-locale es_ES</code> indica el idioma que se va a usar. En este caso, <code>es_ES</code> indica que se va a usar el idioma espa\u00f1ol de Espa\u00f1a.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#comentarios-de-javadoc","title":"Comentarios de Javadoc","text":"<p>Los comentarios de Javadoc se escriben de forma similar a los comentarios de varias l\u00edneas, pero se inician con <code>/**</code> y finalizan con <code>*/</code>. Estos comentarios se pueden incluir en cualquier parte del c\u00f3digo fuente, pero es conveniente que se incluyan en las interfaces, clases, m\u00e9todos, atributos, etc. de la aplicaci\u00f3n.</p> <pre><code>/** \n*\n*/\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#soporte-para-html-en-los-comentarios","title":"Soporte para HTML en los comentarios","text":"<p>En los comentarios de Javadoc podemos usar c\u00f3digo HTML para dar formato al texto. Por ejemplo, podemos usar etiquetas como <code>&lt;p&gt;</code>, <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>, etc.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.7%20-%20Documentacion/#etiquetas-de-javadoc","title":"Etiquetas de Javadoc","text":"<p>A continuaci\u00f3n, veremos una lista de las etiquetas m\u00e1s comunes para generar JavaDoc:</p> Etiqueta Descripci\u00f3n <code>@author</code> Autor de la clase o interfaz. Requerido <code>@version</code> Versi\u00f3n de la clase o interfaz. <code>@param</code> Par\u00e1metro de un m\u00e9todo o constructor. <code>@return</code> Valor de retorno de un m\u00e9todo. <code>@exception</code> Excepci\u00f3n que puede lanzar un m\u00e9todo. <code>@trow</code> Sin\u00f3nimo de <code>@exception</code>. <code>@see</code> Referencia a otra clase, interfaz, m\u00e9todo, etc. <code>@since</code> Versi\u00f3n de Java desde la que se puede usar un m\u00e9todo, clase, etc. <code>@serial</code> Atributo que se serializa. <code>@serialField</code> Atributo que se serializa. <code>@deprecated</code> M\u00e9todo, clase, etc. que est\u00e1 obsoleto."},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/","title":"Tema 2.8: Entrada de datos","text":"<p>Para poder hacer ejercicios necesitamos interactuar con el programa o, al menos, poder indicar con qu\u00e9 datos va a trabajar (datos de entrada).</p> <p>Para ello hemos de ver un par de formas en las que podemos pasar valores a nuestros programas.</p> <p>Estas instrucciones van a ser muy superficiales, simplemente para poder realizar entrada de datos. M\u00e1s adelante las analizaremos en m\u00e1s detalle.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/#entrada-por-consola","title":"Entrada por consola","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/#usando-console","title":"Usando <code>Console</code>","text":"<p>Para leer de la consola (entrada por teclado) primero hemos de acceder a ella. Para hacer esto usaremos la clase <code>Console</code>:</p> <pre><code>import java.io.Console;\n\npublic class InputOutput {\n    public static void main(String[] args) {\n        Console c = System.console(); // Accedemos al objeto Console del sistema.\n        System.out.print(\"Dime tu nombre: \");\n\n        String nombre = c.readLine(); // Quedar\u00e1 esperando a que escribamos un texto y lo guardar\u00e1 en nombre.\n\n        System.out.println(\"\u00a1Hola \" + nombre + \"!\");\n    }\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/#nota-2","title":"NOTA 2","text":"<p>Los datos le\u00eddos con <code>readLine</code> siempre ser\u00e1 cadenas de caracteres. Para poder usarlos como n\u00fameros habr\u00e1 que convertirlos en <code>int</code>, <code>float</code>, etc.</p> <p>Para ello hemos de usar los m\u00e9todos / funciones siguientes:</p> <ul> <li><code>Integer.parseInt()</code>: para convertir una cadena a un valor entero.</li> <li><code>Float.parseFloat()</code>: para obtener un valor.</li> <li><code>Double.parseDouble()</code>: ...</li> </ul> <p>Ve\u00e1moslo en un ejemplo:</p> <pre><code>import java.io.Console;\n\npublic class InputNumbers {\n    public static void main(String[] args) {\n        Console c = System.console(); // Accedemos al objeto Console del sistema.\n\n        // Guaramos lo escrito por teclado en numero.\n        String linea = c.readLine(\"Introduzca un n\u00famero: \"); \n        // Puesto que es una cadena (String) hemos de convertirlo al tipo \n        // que nos interesa.\n        int numero = Integer.parseInt(linea);\n        System.out.println(\"El valor \" + linea + \" + 10 vale \" + (numero + 10) + \".\");\n    }\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/#usando-scanner","title":"Usando <code>Scanner</code>","text":"<p>Scanner es ligeramente distinto a <code>Console</code>.  Es m\u00e1s flexible pues no s\u00f3lo sirve para leer del teclado si no que tambi\u00e9n se puede asociar a:</p> <ul> <li>Una cadena de texto.</li> <li>Un fichero del sistema.</li> <li>La entrada por defecto del programa (teclado).</li> <li>A un socket (conexi\u00f3n a la que se pueden unir otros procesos).</li> </ul> <p>Puesto que es m\u00e1s flexible es algo m\u00e1s complejo de utilizar y no ofrece tantas comodidades como <code>Console</code> para acceder a los datos introducidos por el teclado.</p> <p>NOTA: Hay que tener en cuenta que es necesario cerrar el scanner cuando ya no lo vayamos a volver a utilizar.</p> <p>Veamos un ejemplo de uso:</p> <pre><code>import java.util.Scanner;\n\npublic class PrimerosPasos {\n\n    public static void main(String[] args) {\n        String linea = null;\n\n        // La sentencia try (&lt;recurso&gt;) { // bloque }\n        // asegura que el recurso ser\u00e1 cerrado (liberado) cuando termine el bloque.\n        try (Scanner input = new Scanner(System.in)) {\n            linea = input.nextLine();\n        }\n\n        System.out.println(\"Le\u00eddo el texto: \" + linea + \".\");\n\n        // Si deseamos convertirlo a un valor entero:\n        int value = Integer.parseInt(linea);\n\n        System.out.println(\"El valor le\u00eddo es: \" + value + \".\");\n    }\n}\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/T2.8%20-%20Entrada%20de%20datos/#parametros-argumentos","title":"Par\u00e1metros / Argumentos","text":"<p>Cuando creamos el m\u00e9todo <code>main</code> podemos ver que a continuaci\u00f3n sigue la siguiente secuencia <code>(String[] args)</code>. Esta \u00faltima parte est\u00e1 indicando el que m\u00e9todo <code>main</code> recibe como argumento un array de cadenas (una lista de valores <code>String</code>) .</p> <p>Este m\u00e9todo ser\u00e1 utilizado por la m\u00e1quina virtual de Java para pasar al programa los argumentos que indiquemos por consola en el momento de ejecutarlo.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>public class Argumentos {\n    public static void main(String[] args) {\n        System.out.println(\"El primer argumento fue: \" + args[0]);\n        System.out.println(\"El segundo argumento fue: \" + args[1]);\n        System.out.println(\"El tercer argumento fue: \" + args[2]);\n    }\n}\n</code></pre> <p>Si ahora compilamos e invocamos el programa:</p> <pre><code>javac Argumentos.java\njava Argumentos Adi\u00f3s Mundo Cruel\n</code></pre> <p>El resultado ser\u00e1:</p> <pre><code>El primer argumento fue: Adi\u00f3s\nEl segundo argumento fue: Mundo\nEl tercer argumento fue: Cruel\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/","title":"Ejercicios Tema 2: Programaci\u00f3n estructurada, arrays y cadenas","text":"<p>Los ejercicios de este tema se centrar\u00e1n en la manipulaci\u00f3n de arrays y cadenas utilizando sus m\u00e9todos as\u00ed como los elementos (bifurcaci\u00f3n condicional y bucles) de la programaci\u00f3n estructurada.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Escribe un programa que pida al usuario dos palabras por consola e indique si son iguales o disntintas.</p> <p>Soluci\u00f3n ejercicio 1.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Tomando como base el c\u00f3digo del ejercicio anterior, haz que el programa nos indique que palabra est\u00e1 antes lexicogr\u00e1ficamente.</p> <p>Soluci\u00f3n ejercicio 2.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Haz ahora que el programa permita introducir hasta 10 palabras y las almacene en un array de cadenas. El usuario podr\u00e1 interrumpir la introducci\u00f3n de cadenas si pulsa ENTER sin escribir nada (cadena vac\u00eda).</p> <p>Una vez terminada la introducci\u00f3n de cadenas muestra al usuario la lista de palabras introducidas.</p> <p>Soluci\u00f3n ejercicio 3.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Modifica el programa anterior para que ordene las palabras introducidas previamente por el usuario. (Pista: <code>java.util.Arrays.sort()</code>).</p> <p>Soluci\u00f3n ejercicio 4.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-5","title":"Ejercicio 5","text":"<p>Haz que el programa ponga el may\u00fasculas la primera letra de cada palabra.</p> <p>Soluci\u00f3n ejercicio 5.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#ejercicio-6","title":"Ejercicio 6","text":"<p>Crea un m\u00e9todo (est\u00e1tico) que reciba un array de palabras como entrada y devuelva una copia del array con las palabras ordenadas.</p>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/Ejercicios/T2%20-%20Ejercicios/#extra","title":"EXTRA","text":"<p>Ejercicio opcional.</p> <p>Escribe en  programa que permita al usuario introducir una lista de palabras (sin l\u00edmite predefinido).</p> <p>Una vez haya terminado (cuando inserte una palabra vac\u00eda).</p> <p>Se le mostrar\u00e1 la lista de palabras y se le perdir\u00e1 que la ordene.</p> <p>Para ello se le pedir\u00e1n dos n\u00fameros que indicar\u00e1n al programa las posiciones de dos palabras de la lista que ha de intercambiar.</p> <p>Esto se repetir\u00e1 hasta que la lista est\u00e9 ordenada.</p> <p>El programa ha de:</p> <ul> <li>Comprobar que el usuario introduce palabras simples (sin espacios o may\u00fasculas).</li> <li>Comprobar que los \u00edndices son v\u00e1lidos (el usuario no intenta acceder a \u00edndices fuera del array).</li> <li>Verificar si el array ordenado por el usuario est\u00e1 correctamente ordeando.</li> </ul> <p>Pistas:</p> <ul> <li><code>ArrayList</code>.</li> <li><code>ArrayList.sort(null)</code>.</li> </ul>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jquery/","title":"Jquery","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jquery/#jquery-v351","title":"jQuery v3.5.1","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.5.1\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n******************************************\n\nThe jQuery JavaScript Library v3.5.1 also includes Sizzle.js\n\nSizzle.js includes the following license:\n\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/sizzle\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n*********************\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jqueryUI/#jquery-ui-v1121","title":"jQuery UI v1.12.1","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/docs/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jquery/","title":"Jquery","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jquery/#jquery-v351","title":"jQuery v3.5.1","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.5.1\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n******************************************\n\nThe jQuery JavaScript Library v3.5.1 also includes Sizzle.js\n\nSizzle.js includes the following license:\n\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/sizzle\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n*********************\n</code></pre>"},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jqueryUI/#jquery-ui-v1121","title":"jQuery UI v1.12.1","text":""},{"location":"Tema%2002%20-%20Inicio%20en%20Java/codigo_fuente/documentacion/documentacion/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/","title":"Tema 3: Programaci\u00f3n orientada a objetos","text":""},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#clase","title":"Clase","text":"<p>La funci\u00f3n de las clases es la de definir las caracter\u00edsticas de un conjunto de objetos (los objetos de dicha clase).</p> <p>La clase define la estructura o modelo que se seguir\u00e1 cuando se construyan objetos de dicho tipo (o clase).</p> <p>Define las propiedades (estado o datos) que tendr\u00e1n los objetos de la clase as\u00ed como los procedimientos que se podr\u00e1n invocar sobre el objeto.</p> <p>Adem\u00e1s de ello una clase puede tener tambi\u00e9n datos y procedimientos propios, independientes de la existencia de objetos.</p>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#ejemplo","title":"Ejemplo:","text":"<p>Por ejemplo, si estamos desarrollando una aplicaci\u00f3n para una cl\u00ednica veterinaria, podr\u00edamos definir una clase Animal y entre las propiedades de la clase podr\u00edamos tener: nombre, fecha de nacimiento, patolog\u00eda, historial, etc.</p> <p>Tambi\u00e9n tendr\u00eda sentido tener una clase Propietario para modelar el comportamiento (en lo que a la actividad de la cl\u00ednica se refiere) y una clase Historial para centralizar informaci\u00f3n y operaciones relativas al historial sanitario del animal.</p> <p>Cada vez que creamos (o instanciamos) un objeto hemos de tener en cuenta que pertenece a una clase. Y que las tripas del objeto se describen en la dicha clase.</p> <pre><code>public class Animal {\n    public String nombre; // Propiedad de todo animal.\n    public long fecha_nacimiento;\n    public String patologia;\n    // etc.\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#objeto","title":"Objeto","text":"<p>Un objeto es una instancia de una clase.</p> <p>Las instancias se crean mediante el uso de la instrucci\u00f3n new, seguida del nombre de la clase a la que pertenecer\u00e1 nuestro objeto:</p> <pre><code>Animal chuchi = new Animal();\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#propiedades","title":"Propiedades","text":"<p>Las propiedades son variables ligadas a una clase (variables de clase) o a una instancia de la clase (objeto) (variables de instancia).</p> <pre><code>chuchi.nombre = \"Chuchi\u00f1o\";\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#metodo","title":"M\u00e9todo","text":"<p>Un m\u00e9todo es un programa o algoritmo que, al igual que las propiedades, est\u00e1 ligado a una clase (m\u00e9todos de clase) o a una instancia de la clase (m\u00e9todos de instancia).</p> <pre><code>// En la clase animal definimos un m\u00e9todo para todos los miembros de la clase:\npublic class Animal {\n    public String nombre;\n\n    public void ponerNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String dimeTuNombre() {\n        return this.nombre;\n    }\n}\n</code></pre> <p>Ahora todos los animales tendr\u00e1 los m\u00e9todos <code>ponerNombre</code> y <code>dimeTuNombre</code>.</p> <p>Para invocar un m\u00e9todo hemos de poner primero el objeto (o la clase si es un m\u00e9todo est\u00e1tico) seguido de \".\" y el nombre del m\u00e9todo:</p> <pre><code>// objeto.m\u00e9todo(par\u00e1metros);\nchuchi.ponerNombre(\"Chuchi\u00f1o\")\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#abstraccion-de-datos","title":"Abstracci\u00f3n de datos","text":"<p>Se trata de un patr\u00f3n de dise\u00f1o que implica que los datos (estado interno de un objeto, o clase) no podr\u00e1n ser accedidos directamente, si no que se har\u00e1 mediante una funci\u00f3n (o m\u00e9todo).</p> <p>De esta forma nada externo al objeto tiene que conocer c\u00f3mo est\u00e1 almacenada la informaci\u00f3n del objeto (estado interno).</p> <p>Ser\u00e1 el objeto el que ofrezca m\u00e9todos para informar de su estado interno (getters) o para modificarlo (setters).</p> <pre><code>public class Animal {\n    private String nombre;\n\n    // M\u00e9todo para establecer el valor de nombre: setter.\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // M\u00e9todo para obtener el valor de nombre: getter.\n    public String getNombre() {\n        return this.nombre;\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>Relacionado con el concepto anterior, la encapsulaci\u00f3n evita que el c\u00f3digo exterior al objeto tenga que conocer la estructura interna del objeto.</p> <p>Esta pr\u00e1ctica facilita tambi\u00e9n que se evite el acoplamiento.</p> <p>El hecho de que la clase est\u00e9 desacoplada del resto de clases permite que los cambios internos que hagamos no afecten a ning\u00fan otro elemento externo: otras clases y m\u00e9todos.</p> <p>Esto facilita la refactorizaci\u00f3n, dado que el creador de una clase podr\u00e1 cambiar la representaci\u00f3n interna de los datos del objeto (mientras no cambie los m\u00e9todos p\u00fablicos de la clase).</p>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#visibilidad","title":"Visibilidad","text":"<p>El concepto de visibilidad determina qui\u00e9n y desde d\u00f3nde podr\u00e1 ver (o acceder) a un elemento.</p> <p>La visibilidad en Java se determina anteponiendo a un elemento (clase, campo, m\u00e9todo, etc.) alguna de las siguientes palabras reservadas</p> <ul> <li><code>public</code></li> <li><code>protected</code></li> <li><code>private</code></li> </ul> <p>Adem\u00e1s, en caso de que no se indique ninguna de ellas se aplicar\u00e1 otro tipo de visibilidad (<code>package-protected</code>).</p> <p>La palabra <code>public</code> indica que cualquier elemento, desde cualquier lugar podr\u00e1 acceder al elemento p\u00fablico.</p> <p><code>private</code>, por el contrario, indicar\u00e1 que el elemento ser\u00e1 visible \u00fanicamente desde el interior del elemento donde se ha definido.</p>"},{"location":"Tema%2003%20-%20POO/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#herencia","title":"Herencia","text":"<p>El concepto de herencia se refiere al mecanismo que se utiliza en programaci\u00f3n orientada a objetos para hacer que una clase (clase hija o sub-clase) herede las caracter\u00edsticas de otra clase (clase padre o super-clase). La clase hija, adem\u00e1s de heredar todas las propiedades de la clase padre podr\u00e1 sobre-escribirlas y a\u00f1adir caracter\u00edsticas nueva.</p> <p>Mediante este mecanismo nos ahorramos la repetici\u00f3n de c\u00f3digo.</p> <p>Un ejemplo de herencia ser\u00eda que las clases <code>Alumno</code> y <code>Profesor</code> heredasen de la clase <code>Persona</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/","title":"Tema 3.1: Anatom\u00eda de una Clase","text":"<p>En este tema veremos los elementos b\u00e1sicos de una clase de Java y que efecto tienen a la hora de crear instancias / objetos de dicha clase.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#creacion-de-una-clase","title":"Creaci\u00f3n de una clase","text":"<p>Para crear una clase seguiremos la siguiente sintaxis:</p> <pre><code>public class MiClase {\n    // C\u00f3digo de la clase.\n}\n</code></pre> <p>Los nombres de las clases empiezan siempre por may\u00fascula y tienen que coincidir con el nombre del fichero donde est\u00e1n guardadas.</p> <p>As\u00ed, el nombre del fichero con el c\u00f3digo fuente de nuestra clase <code>MiClase</code> ha de llamarse <code>MiClase.java</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-o-campos","title":"Propiedades o campos","text":"<p>Las propiedades o campos de una clase son declaraciones de variables que almacenar\u00e1n informaci\u00f3n sobre las caracter\u00edsticas de los objetos de de dicha clase (lo m\u00e1s com\u00fan) o que guardar\u00e1n informaci\u00f3n sobre la propia clase.</p> <p>Las propiedades de instancia (objeto) se pueden definir como el estado interno del objeto. Pueden ser visibles o no desde el exterior (apartado Visibilidad de este tema) y se ir\u00e1n modificando en respuesta a la invocaci\u00f3n de los m\u00e9todos del objeto.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#sintaxis-de-una-propiedad","title":"Sintaxis de una propiedad","text":"<p>La sintaxis para la definici\u00f3n de un campo o propiedad es la siguiente:</p> <pre><code>[visibilidad] [static] [final] tipo nombre;\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-de-instancia","title":"Propiedades de instancia","text":"<p>Para crear una propiedad de instancia simplemente hemos de declarar una variable dentro del bloque de c\u00f3digo de la clase que hayamos definido:</p> <pre><code>public class MiClase {\n    int mi_variable_de_instancia;\n}\n</code></pre> <p>Cuando creemos un objeto de la clase <code>MiClase</code>, \u00e9ste tendr\u00e1 una propiedad de tipo entero con el nombre <code>mi_variable_de_instancia</code>.</p> <p>Para acceder directamente a una propiedad de instancia hemos de escribir el nombre del objeto seguido de <code>.</code> y el nombre de su propiedad:</p> <pre><code>MiClase mi_objeto = new MiClase();\nmi_objeto.mi_variable_de_instancia = 10;\n</code></pre> <p>En general no se recomienda acceder directamente a las variables internas de un objeto. En su lugar se crear\u00e1n m\u00e9todos para leer o modificar las variables internas del mismo.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-de-clase","title":"Propiedades de clase","text":"<p>Las propiedades de clase son variables que, en lugar de necesitar de una instancia (objeto) para existir, depender\u00e1n \u00fanicamente de la clase. Para definirlas hemos de preceder la declaraci\u00f3n de la variable de la palabra reservada <code>static</code>:</p> <pre><code>public class MiClase {\n    static int mi_variable_de_clase;\n    int mi_variable_de_instancia;\n}\n</code></pre> <p>Al igual que con las propiedades de instancia, para acceder a la propiedad de una clase hemos de poner el nombre de la clase seguido de <code>.</code> y el nombre de la propiedad:</p> <pre><code>MiClase.mi_variable_de_clase = 10;\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos","title":"M\u00e9todos","text":"<p>Un m\u00e9todo consiste en crear un mini programa al que le daremos nombre, para poder utilizarlo m\u00faltiples veces desde distintos lugares.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#sintaxis-de-un-metodo","title":"Sintaxis de un m\u00e9todo","text":"<pre><code>[visibilidad] [static] [tipo | void] nombre ([par\u00e1metros])\n</code></pre> <p>Donde:</p> <ul> <li>Visibilidad podr\u00e1 ser <code>public</code>, <code>protected</code> o <code>private</code>.</li> <li><code>static</code> es opcional e indica si el m\u00e9todo es de instancia o clase.</li> <li>El tipo ha de indicarse en caso de que el m\u00e9todo devuelva alg\u00fan valor. En caso contrario usaremos <code>void</code> en lugar de tipo.</li> <li>El nombre cumplir\u00e1 una reglas similares al nombre de una variable.</li> <li>Los par\u00e1metros (opcionales) indica qu\u00e9 datos de entrada admitir\u00e1 el m\u00e9todo. Los par\u00e1metros se declaran como cualquier variable e ir\u00e1n separados por <code>,</code>.</li> </ul>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#argumentos-y-parametros","title":"Argumentos y par\u00e1metros","text":"<p>Cuando definimos un m\u00e9todo lo que indicamos (en caso de que haya alguno) son los par\u00e1metros que puede aceptar.</p> <p>Cuando invocamos o llamamos al m\u00e9todo le pasamos los argumentos que requiere.</p> <p>Por lo tanto los argumentos de un m\u00e9todo han de ser compatibles con los par\u00e1metros que hayamos indicado cuando definimos el m\u00e9todo.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#ejemplo","title":"Ejemplo","text":"<pre><code>public class MiClase {\n    public static String metodo1(String str, int x) {\n        return str + x;\n    }\n\n    public static void main(String[] args) {\n        String texto = metodo1(\"N\u00famero\", 3);\n        System.out.println(texto);\n\n        // Si llamamos al m\u00e9todo \"metodo1\" de la siguiente manera:\n        texto = metodo1(\"Error\");\n        // Saltar\u00e1 un error pues no podemos invocar al m\u00e9todo sin pasarle todos los argumentos en el orden correcto.\n        // En este caso una cadena y un valor entero.\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<p>Los m\u00e9todos de instancia son bloques de c\u00f3digo con unas entradas (par\u00e1metros de entrada) y una salidas (valor de retorno).</p> <p>As\u00ed un m\u00e9todo <code>suma</code> podr\u00eda tener como par\u00e1metros de entrada dos variables de tipo entero y como salida un valor tambi\u00e9n de tipo entero:</p> <pre><code>int suma(int x, int y) {\n    // C\u00f3digo del m\u00e9todo.\n}\n</code></pre> <p>Los m\u00e9todos de instancia solo existir\u00e1n cuando se cree un objeto. Para invocarlos hemos de escribir el nombre del objeto seguido de <code>.</code> y el nombre del m\u00e9todo:</p> <p>C\u00f3digo de la clase:</p> <pre><code>public class Figura {\n String nombre;\n public int suma(int x, int y) {\n        int resultado = x + y;\n        return resultado;\n }\n}\n</code></pre> <p>C\u00f3digo donde creamos el objeto:</p> <pre><code>//...\nFigura circulo = new Figura();\nint valor = circulo.suma(5, 3);\n// valor tendr\u00e1 el valor 8.\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Como hemos visto en el ejemplo anterior, para crear un objeto hemos de usar la palabra reservada <code>!#java new</code> seguido del nombre de la clase que queremos instanciar y + <code>()</code>. Dentro de los <code>()</code> introduciremos los argumentos que necesite el constructor de la clase (si es que necesita alguno) como veremos m\u00e1s adelante en el apartado Constructor.</p> <pre><code>class Figura {\n    public String nombre;\n    public int num_lados;\n}\n</code></pre> <p>Creaci\u00f3n de un objeto de la clase / tipo <code>Figura</code>:</p> <pre><code>//...\nFigura circulo = new Figura;\ncirculo.nombre = c\u00edrculo;\ncirculo.num_lados = 1;\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos-de-clase","title":"M\u00e9todos de clase","text":"<p>Los m\u00e9todos de clase, al igual que las propiedades de clase no estar\u00e1n ligados a ning\u00fan objeto por lo que no necesitar\u00e1n que se cree un objeto para existir. Est\u00e1n, por el contrario, ligados directamente a la clase donde se definan. Para invocarlos hemos de escribir el nombre de la clase seguido de <code>.</code> y el nombre del m\u00e9todo.</p> <pre><code>class Aleatorio {\n    public static int enteroAleatorio(int min, int max) {\n        Random r = new Random();\n        return r.nextInt(max - min) + min;\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#constructor","title":"Constructor","text":"<p>El constructor de una clase es un m\u00e9todo especial que sirve para establecer el estado inicial de cada nuevo objeto que creemos de una clase.</p> <p>Es decir, asignar\u00e1 valores a las propiedades de instancia.</p> <p>El constructor de una clase se define como un m\u00e9todo sin valor de retorno (pues lo que crea es evidente) y con el nombre igual al de la clase para la cual se define.</p> <p>Podemos definir varios constructores (con distintos par\u00e1metros) para una misma clase:</p> <pre><code>class MiClase {\n    int m_v_d_i;\n\n    // Primer constructor.\n    public MiClase() {\n        m_v_d_i = 0;\n    }\n\n    public MiClase(int x) {\n        m_v_d_i = x;\n    }\n\n    public static void main(String[] args) {\n        // Creamos un objeto usando el primero constructor.\n        MiClase miObj1 = new MiClase();\n        System.out.println(miObj1.m_v_d_i); // Mostrar\u00e1 el valor 0.\n\n        // Creamos un segundo objeto usando el segundo constructor.\n        MiClase miObj2 = new MiClase(10);\n        System.out.println(miObj2.m_v_d_i); // Mostrar\u00e1 el valor 1.\n    }\n}\n</code></pre> <p>NOTA: Clase sin constructor:</p> <p>Cuando no definimos un constructor para una clase sigue existiendo un constructor. Este es el constructor por defecto de la clase padre: <code>Object</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#destructor","title":"Destructor","text":"<p>En general en Java no tendremos un m\u00e9todo destructor de objetos. Cuando una instancia de una clase ya no sea accesible el recolector de basura se encargar\u00e1 de ella (liberar\u00e1 la memoria que estuviese utilizando).</p> <p>Una clase ser\u00e1 accesible siempre que tenga alguna variable que la referencie.</p> <pre><code>MiClase obj1 = new MiClase(); // la variable obj1 apunta a un objeto de la clase MiClase. Una variable referencia al objeto.\nMiClase obj2 = obj1; // la variable obj2 apunta al mismo objeto. Dos variables referencian al objeto.\nobj1 = null; // la variable obj1 deja de referenciar al objeto. Una variable referencia al objeto.\nobj2 = null; // la variable ojb2 deja de referenciar al objeto. Ninguna variable referencia al objeto.\n/*\nEn este punto el objeto ya no ser\u00eda accesible. No hay forma de referenciarlo. \"Hemos perdido su informaci\u00f3n de contacto\".\nEl objeto podr\u00e1 ser recogido por el recolector de Basura en cualquier momento.\n*/\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#visibilidad","title":"Visibilidad","text":"<p>Es hora de que hablemos de los public que aparecen delante de nuestras declaraciones de clases, propiedades y m\u00e9todos.</p> <p>La palabra reservada <code>public</code>, junto con <code>protected</code> y <code>private</code> determinan la visibilidad que tendr\u00e1 la clase, propiedad o m\u00e9todo al que se le apliquen desde fuera de la clase.</p> <ul> <li><code>public</code>: Todo el mundo podr\u00e1 ver la clase/propiedad/m\u00e9todo desde fuera de la clase.</li> <li><code>protected</code>: S\u00f3lo las clases compa\u00f1eras (del mismo paquete) podr\u00e1n ver la clase/propiedad/m\u00e9todo de nuestra clase.</li> <li><code>private</code>: Nadie fuera de la propia clase podr\u00e1 ver la clase/propiedad/m\u00e9todo de esta clase.</li> </ul> <pre><code>public class MiClase {\n public class MiClaseInterna {\n        // Cosas de esta clase.\n    }\n\n    public int propiedad_publica;\n    private int propiedad_privada;\n\n    public void setPrivada(int valor) {\n        this.propiedad_privada = valor;\n    }\n\n    public int getPrivada() {\n        return this.propiedad_privada;\n    }\n\n    public metodoPublico() {\n        System.out.println(\"Aqu\u00ed estoy, de cara al p\u00fablico...\");\n        System.out.println(\"(Pero puedo invocar a m\u00e9todos privados de mi clase\" + metodoPrivado +\")\"):\n    }\n\n    private String metodoPrivado() {\n        return \"Pues aqu\u00ed estoy, siendo privado en mi privacidad.\";\n    }\n\n    public static void main(String[] args) {\n        MiClase miObjeto = new MiClase();\n\n        miObjeto.propiedad_privada = 5; // Esto ser\u00e1 un error.\n        miObjeto.propiedad_publica = 10; // No dar\u00e1 problemas.\n\n        String mensaje_privado = miObjeto.metodoPrivado(); // Dar\u00e1 error.\n        miObjeto.metodoPublico(); // Funcionar\u00e1 correctamente.\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.2%20-%20Visibilidad/","title":"Tema 3.2: Visibilidad","text":"<p>La visibilidad determina qu\u00e9 elementos de una clase se pueden ver desde el exterior.</p> <p>Hay tres palabras reservadas con las que podemos indicar qu\u00e9 visibilidad tendr\u00e1n los elementos de una clase (propiedades y m\u00e9todos).</p> <ul> <li><code>public</code>: Todo el mundo podr\u00e1 verlo.</li> <li><code>protected</code>: S\u00f3lo las clases del mismo paquete podr\u00e1n verlo.</li> <li><code>private</code>: S\u00f3lo la misma clase podr\u00e1 verlo, es decir, ser\u00e1 invisible desde el exterior.</li> </ul>"},{"location":"Tema%2003%20-%20POO/T3.2%20-%20Visibilidad/#ejemplo","title":"Ejemplo","text":"<p>En primer lugar vamos a definir una clase con tres propiedades y tres m\u00e9todos, cada uno con una visibilidad distinta:</p> <pre><code>public class MiClase {\n    public int propPublica;\n    protected int propProtegida;\n    private int propPrivada;\n\n    public void setAllToZero() {\n        this.propPublica = 0;\n        this.propProtegida = 0;\n        this.propPrivada = 0;\n    }\n\n    protected void setAllToOne() {\n        this.propPublica = 1;\n        this.propProtegida = 1;\n        this.propPrivada = 1;\n    }\n\n    protected void setAllToTwo() {\n        this.propPublica = 2;\n        this.propProtegida = 2;\n        this.propPrivada = 2;\n    }\n}\n</code></pre> <p>Supongamos tambi\u00e9n que esta clase est\u00e1 dentro de la carpeta \"paquete1\", lo que representar\u00e1 que la clase est\u00e1 en el paquete \"paquete1\":</p> <pre><code>package paquete1;\n\npublic class MiClase {\n    // Definimos un conjunto de constantes (modificador \"final\") con distintas\n    // opciones de visibilidad.\n    final int VISIBILIDAD_POR_DEFECTO = 1\n    public final int VISIBLE_POR_TODOS = 10;\n    protected final int VISIBILIDAD_DE_PAQUETE = 100;\n    private final int VISIBLE_POR_MI = 1000;\n\n    // ...\n}\n</code></pre> <p>Crearemos ahora otras dos clases que har\u00e1n uso de la clase <code>MiClase</code>. La primera estar\u00e1 en el mismo paquete y la segunda fuera.</p> <pre><code>package paquete1;\n\npublic class MiClaseHermana {\n    // ...\n    int valor = MiClase.VISIBILIAD\n}\n</code></pre> <pre><code>public class MiClaseExtra\u00f1a {\n    // ...\n}\n</code></pre> <p>Veamos, por \u00faltimo, a qu\u00e9 elementos de <code>MiClase</code> pueden acceder las otras dos clases:</p> <pre><code>\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.2%20-%20Visibilidad/#cuadro-de-visibilidad","title":"Cuadro de visibilidad","text":"<p>El siguiente cuadro muestra la interacci\u00f3n entre los modificadores de visibilidad que se aplican a propiedades y m\u00e9todos de una clase y desde donde se pueden consultar:</p> <p></p>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/","title":"Tema 3.3: Herencia","text":"<p>La herencia es un mecanismo que permite declarar una nueva clase (subclase) a partir de otra clase ya existente (superclase). Esto permite que todos los elementos de la superclase pasen a estar disponibles en la subclase excepto los constructores.</p> <p>Java s\u00f3lo dispone de herencia simple, por lo que una clase s\u00f3lo puede heredar de una \u00fanica superclase.</p> <p>Cuando una clase hereda (<code>extends</code>) de otra clase se denomina a la heredera: subclase, clase hija o clase derivada. Por su parte a la clase de la que hereda se la llamar\u00e1: superclase, clase padre o clase base.</p> <p>La herencia tiene una cualidad transitiva. Esto quiere decir que si la clase C hereda de la clase B y la clase B hereda de la clase A:</p> <ul> <li>La clase C es subclase de B.</li> <li>La clase B es subclase de A.</li> <li>La clase C es tambi\u00e9n subclase de A.</li> </ul> <p>De este modo siempre podremos hablar de una jerarqu\u00eda de clases.</p> <p>Adem\u00e1s de heredar todo el c\u00f3digo y propiedades de sus superclases (todas las que est\u00e9n por encima en la jerarqu\u00eda), una subclase se considera del mismo tipo que su superclase.</p> <pre><code>// Creamos una clase Alumno.\npublic class Alumno {\n    private int dni;\n    private String nombre;\n\n    public void setDni(int dni) {\n        this.dni = dni;\n    }\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public int getDni() {\n        return dni;\n    }\n\n    public string getNombre() {\n        return nombre;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Mi nombre es %s y mi DNI %d.\");\n    }\n}\n</code></pre> <p>Si creamos ahora una subclase (<code>AlumnoFP</code>) de la clase anterior.</p> <pre><code>public class AlumnoFP extends Alumno {\n    private String modulo;\n\n    public void setModulo(String modulo) {\n        this.modulo = modulo;\n    }\n\n    public String getModulo() {\n        return modulo\n    }\n\n    @Override \n    public String toString() {\n        String string = super.toString();\n\n        return String.format(\"%s%nEstudio el m\u00f3dulo de %s.%n\", string, modulo);\n    }\n}\n</code></pre> <p>Aunque no los hemos definido <code>AlumnoFP</code> dispone de los m\u00e9todos <code>setDni</code> y <code>getDni</code> que hereda de su padre (as\u00ed como todas sus propiedades). Adem\u00e1s de heredar los m\u00e9todos de la clase padre tambi\u00e9n podr\u00e1 a\u00f1adir sus propios m\u00e9todos (como <code>setModulo</code> y <code>getModulo</code>). Y tambi\u00e9n podr\u00e1 sobrescribir m\u00e9todos de sus clases padres (se indica con la etiqueta <code>@Override</code>).</p> <p>Si necesitase acceder a alg\u00fan m\u00e9todo de su clase padre podr\u00eda hacerlo utilizando la referencia <code>super</code>, que le permitir\u00e1 acceder a los m\u00e9todos de su clase padre (directa).</p>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#ventajas-de-la-herencia","title":"Ventajas de la herencia","text":"<p>Su principal ventaja es que permite reutilizar c\u00f3digo ya que los m\u00e9todos que hayamos dise\u00f1ado para una clase podr\u00e1n aplicarse autom\u00e1ticamente a todas sus subclases.</p> <p>Otra ventaja es que podremos tratar a toda una jerarqu\u00eda de objetos como si fuesen del mismo tipo (todo heredan de alguna de las clases superiores en la jerarqu\u00eda).</p> <p>Por ejemplo, si dise\u00f1amos un m\u00e9todo que trabaja con objetos de la clase <code>Alumno</code> podremos pasarle objetos que sean de cualquiera de sus subclases <code>AlumnoFP</code> y el m\u00e9todo funcionar\u00e1 perfectamente. En cierto modo es como si el m\u00e9todo aceptase distintos tipos de argumentos.</p>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#declaracion-de-herencia","title":"Declaraci\u00f3n de herencia","text":"<p>Para declarar que la clase <code>Raton</code> hereda de la clase <code>Mamifero</code> hemos de usar la siguiente sentencia al declarar la clase <code>Raton</code>:</p> <pre><code>public class Raton extends Mamifero {\n    // C\u00f3digo de la clase rat\u00f3n.\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#asociacion-agregacion-y-composicion-de-clases","title":"Asociaci\u00f3n, agregaci\u00f3n y composici\u00f3n de clases","text":""},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#agregacion","title":"Agregaci\u00f3n","text":"<p>La agregaci\u00f3n puede definirse como una relaci\u00f3n entre dos clases que refleja que la clase A tiene uno o m\u00e1s elementos de la clase B. Se determina que la clase A es due\u00f1a de la clase B porque se puede producir que la clase A contiene alguna referencia (propiedad) a la clase B pero la clase B no puede contener elementos de la clase A. Si no se puede determinar la clase due\u00f1a estar\u00edas hablando de una asociaci\u00f3n de clases.</p> <p>Imaginemos por ejemplo el caso de dos clases Alumno y Modulo. Alumno almacena informaci\u00f3n sobre el alumno y Modulo informaci\u00f3n sobre el contenido del m\u00f3dulo. Puesto que un alumno estar\u00e1 matriculado en varios m\u00f3dulos podemos decir que Alumno es la clase que tiene uno o m\u00e1s elementos de la clase Modulo.</p> <pre><code>public class Alumno {\n    private String nombre;\n    private String apellidos;\n\n    //...\n\n    private Modulo[] modulos = Modulo[10];\n\n    //...\n}\n</code></pre> <pre><code>public class Modulo {\n    private String codigo;\n    private String nombre;\n    private String contenido;\n\n    // ...\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#composicion","title":"Composici\u00f3n","text":"<p>Similar al caso anterior pero cuando la clase B, adem\u00e1s de pertenecer a la clase A no puede existir de manera independiente.</p> <p>Un ejemplo de composici\u00f3n ser\u00eda una cuenta bancaria con respecto a un cliente. No pueden existir cuentas sin propietarios.</p>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#constructores-y-herencia","title":"Constructores y herencia","text":"<p>Los constructores se comporta de una forma diferente al resto de los elementos de una clase cuando son heredados por otra.</p> <p>A diferencia de lo que ocurre con el resto de m\u00e9todos y propiedades (que son heredados por la subclase) los constructores no se heredan. Cada subclase tendr\u00e1 sus propios constructores.</p> <p>Aunque no se declare expl\u00edcitamente toda clase tiene un constructor impl\u00edcito, es decir, un constructor por defecto. Si se declara cualquier otro constructor, el constructor por defecto desaparece.</p> <p>Cuando se crea un objeto de una clase no se invoca \u00fanicamente a su constructor, si no que se ejecuta en cadena el de todas las superclases de su jerarqu\u00eda:</p> <ol> <li>Si se invoca al constructor con alg\u00fan argumento, se buscar\u00e1 el m\u00e9todo constructor cuyos par\u00e1metros sean compatibles con dicho argumento. En caso contrario se invocar\u00e1 al constructor por defecto o al que ha creado el programador sin argumentos.</li> <li>Si queremos indicar que se ejecute un constructor concreto de la superclase hemos de invocarlo impl\u00edcitamente usando la sentencia <code>super</code>.</li> </ol>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#ejemplo","title":"Ejemplo","text":"<pre><code>public class MiClase {\n    // constructor por defecto. No es necesario si no se incluye ning\u00fan otro constructor.\n    public MiClase() {\n        // Inicializaci\u00f3n del objeto.\n    }\n\n    public MiClase(int x) {\n        // Inicializaci\u00f3n del objeto.\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#acceso-a-propiedades-de-la-superclase","title":"Acceso a propiedades de la superclase","text":"<p>Hay veces que deseamos acceder, desde una subclase, a alguna de las propiedades o m\u00e9todos de su superclase. Para ello podemos hacer uso de la palabra reservada <code>super</code>.</p> <pre><code>public class SuperClase {\n    public int x;\n\n    public SuperClase(int x) {\n        this.x = x;\n    }\n}\n\npublic class SubClase1 extends SuperClase {\n    public int y;\n\n    public SubClase1(int x, int y) {\n        super.x = x;\n        this.y = y;\n    }\n}\n\npublic class SubClase2 extends SuperClase {\n    public int y;\n\n    public SubClase2(int x, int y) {\n        super(x); // Constructor de la superclase.\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#cast","title":"Cast","text":"<p>Hay casos en los que sabemos que un objeto pertenece a una subclase concreta pero est\u00e1 almacenado en una variable declarada como del tipo de alguna de sus superclases. Si queremos convertir o indicar expl\u00edcitamente cual es el tipo del objeto podemos hacerlo utilizando el mecanismo cast:</p> <pre><code>// Object es superclase de todas las clases as\u00ed que la siguiente sentencia ser\u00e1 v\u00e1lida.\nObject cadena = \"hola mundo\"; \n\n// Pero como no est\u00e1 garantiza que cadena sea del tipo String (dijimos que era Object)\n// la siguiente sentencia fallar\u00e1.\nString miCadena = cadena;\n\n// Para que sea posible hemos de indicar expl\u00edcitamente el tipo de la variable cadena.\nString miCadena = (String) cadena;\n\n// Aunque parezca incre\u00edble esto puede dar problemas... por ejemplo cuando \"estamos completamente\n// seguros\" de algo que al fina como que no. Estoy bastante cansado.\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#acceso-a-metodos-de-la-superclase","title":"Acceso a m\u00e9todos de la superclase","text":""},{"location":"Tema%2003%20-%20POO/T3.3%20-%20Herencia/#sobrescritura-de-metodos","title":"Sobrescritura de m\u00e9todos","text":"<p>Cuando queramos que una subclase tenga su propia versi\u00f3n de un m\u00e9todo de la superclase, podemos sobrescribirlo. Para ello hemos de declarar un m\u00e9todo con el mismo nombre y par\u00e1metros que el m\u00e9todo de la superclase.</p> <pre><code>public class SuperClase {\n    public String nombre;\n\n    // Constructor, m\u00e9todos, etc.\n\n    public void metodo() {\n        System.out.printf(\"Hola %s.%n\", nombre);\n    }\n}\n\n// Creamos una subclase.\n\npublic class SubClase extends SuperClase {\n    public String apellidos;\n\n    // Constructor, m\u00e9todos, etc. \n\n    @Override // Indicamos que sobrescribimos el m\u00e9todo \"metodo\".\n    public void metodo() {\n        System.out.printf(\"Hola %s %s.%n\", nombre, apellidos);\n    }\n\n    // Cuando invoquemos este m\u00e9todo de la subclase no se ejecutar\u00e1 el c\u00f3digo definido\n    // en la superclase si no el que acabamos de escribir.\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/","title":"Tema 3.4: Paquetes","text":"<p>En Java los paquetes son un mecanismo mediante el que podemos agrupar clases, sub-paquetes e interfaces. Como es l\u00f3gico se agrupar\u00e1n en un mismo paquete aquellas clases que tengan alguna relaci\u00f3n entre ellas.</p> <p>Toda clase (e interfaz) pertenece a alg\u00fan paquete. Si no se indica expl\u00edcitamente uno (mediante la sentencia <code>package</code>) se asigna la clase a un paquete por defecto.</p> <p>Los paquetes se usan para:</p> <ul> <li>Facilitar la localizaci\u00f3n de las clases e interfaces.</li> <li>Evitar conflictos de nombres, es decir, podr\u00edan existir dos clases Alumno en dos paquetes distintos (uno perteneciendo al instituto y otro a una academia).</li> <li>Facilitan un control de acceso: <code>protected</code> y el acceso por defecto funcionan a nivel de paquete.</li> </ul> <p>Hemos de tener en cuenta tambi\u00e9n que los paquetes est\u00e1n relacionados con la estructura de directorios. As\u00ed que si una clase est\u00e1 en el paquete <code>org.iescotarelo.dam</code> estar\u00e1 guardada en el directorio <code>org\\iescotarelo\\dam</code>. Idea</p>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#agrupar-clases-en-paquetes","title":"Agrupar clases en paquetes","text":"<p>Para agrupar las clases en paquetes hemos de usar la sentencia <code>package</code>:</p> <pre><code>package org.iescotarelo.dam;\n</code></pre> <p>Adem\u00e1s hemos de tener en cuenta que la clase ha de guardarse en la ruta <code>org\\iescotarelo\\dam</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#paquetes-y-el-classpath-y-el-horror","title":"Paquetes y el CLASSPATH y el horror","text":"<p>La variable de entorno <code>CLASSPATH</code> le indicar\u00e1 a la JVM d\u00f3nde debe buscar los paquetes a los que llamamos o deseamos importar. De este modo, si todos nuestros paquetes est\u00e1n dentro del directorio <code>C:\\FP\\DAM\\Programacion\\Java</code> deber\u00edamos a\u00f1adir dicho directorio a la variable <code>CLASSPATH</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#windows-11","title":"Windows 11","text":"<p>Para modificar las variables de entorno en Windows 11 podemos directamente pulsar en Inicio y buscar \"variables\". Nos aparecer\u00e1 la opci\u00f3n de \"Editar las variables de entorno del sistema\". Pulsamos y veremos la siguiente ventana:</p> <p></p> <p>Pulando en el bot\u00f3n de la parte inferior con la etiqueta <code>Variables de entorno...</code> abriremos la ventana:</p> <p></p> <p>Seleccionamos la variable llamada <code>CLASSPATH</code> y pulsamos editar:</p> <p></p> <p>Si deseamos que se incluyesen las de nuestro proyecto deber\u00edamos a\u00f1adir la ruta a la carpeta ra\u00edz de nuestro c\u00f3digo.</p>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#cosas-a-tener-en-cuenta","title":"Cosas a tener en cuenta","text":"<p>Peque\u00f1os detalles obvios y de escasa importancia que nos pueden amargar una ma\u00f1ana.</p> <ul> <li>La variable global <code>CLASSPATH</code> ha de indicar la ruta a los directorios de classes <code>.class</code> y/o a la ra\u00edz del \u00e1rbol de paquetes.</li> <li>La opci\u00f3n <code>-cp</code> de <code>java</code> y <code>javac</code> substituye el valor de <code>CLASSPATH</code>.</li> <li>Si incluimos <code>.jar</code> en nuestro proyecto estos han de incluirse expl\u00edcitamente en el <code>CLASSPATH</code> o la opci\u00f3n <code>-cp</code>. No llega co indicar su ubicaci\u00f3n.</li> </ul>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#importando-clases-de-paquetes","title":"Importando clases de paquetes","text":"<p>Una vez tenemos nuestras clases organizadas en paquetes podremos incluirlas en nuestros programas y proyectos import\u00e1ndolas.</p> <p>Para importar una o varias clases hemos de usar la sentencia <code>import</code>:</p> <pre><code>import org.iescotarelo.dam.MiClase;\n</code></pre> <p>Si quisi\u00e9semos importar todas las clases de un paquete escribir\u00edamos:</p> <pre><code>import org.iescotarelo.dam.*;\n</code></pre> <p>La sentencia anterior importar\u00eda a nuestro programa todas las clases que se encuentren dentro del paquete <code>org.iescotarelo.dam</code>.</p>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#static-import","title":"Static import","text":"<p>Un tipo especial de import es el import est\u00e1tico. Este import permitir\u00e1 importar a nuestro c\u00f3digo las constantes, propiedades y m\u00e9todos est\u00e1ticos de la clase que indiquemos:</p> <pre><code>package org.iescotarelo.dam.programacion.paquetes;\n\npublic class MiClase {\n    public static final int MI_CONSTANTE = 666;\n\n    public static void saludo(String nombre) {\n        System.out.println(String.format(\"Hola %s.\"));\n    }\n}\n</code></pre> <pre><code>import static org.iescotarelo.dam.programacion.paquetes.MiClase;\n\npublic class MiOtraClase {\n    public static void main {\n        saludo(\"Manuel\");\n    }\n}\n</code></pre>"},{"location":"Tema%2003%20-%20POO/T3.4%20-%20Paquetes/#estructura-de-directorios","title":"Estructura de directorios","text":"<p>Important points:</p> <p>Every class is part of some package. If no package is specified, the classes in the file goes into a special unnamed package (the same unnamed package for all files). All classes/interfaces in a file are part of the same package. Multiple files can specify the same package name. If package name is specified, the file must be in a subdirectory called name (i.e., the directory name must match the package name). We can access public classes in another (named) package using: package-name.class-name</p> <p>Informaci\u00f3n tomada de GeeksForGeeks.</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios%20-%20Herencia/","title":"Ejercicios tema 3: Herencia","text":""},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/","title":"Ejercicios Tema3: Prog. orientada a objetos","text":""},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Implementa un programa que admita dos argumentos indicando el valor m\u00ednimo y m\u00e1ximo y que genere dos n\u00fameros aleatorios entre dichos valores. Ha de mostrar dichos n\u00fameros por pantalla y tambi\u00e9n el valor del mayor sin usar ninguna sentencia de control. (Pistas <code>Random</code>, <code>Math.max</code>).</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Implementa una clase que represente a un viajero que sea capaz de almacenar informaci\u00f3n sobre: DNI, nombre, apellidos, nacionalidad y direcci\u00f3n.</p> <p>*Souci\u00f3n...</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>A\u00f1ade a la case anterior los m\u00e9todos necesarios para la lectura y escritura de sus campos (propiedades) y establece el nivel de visibilidad adecuado para ellos.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Incluye la clase en un paquete <code>viajero</code> que a su vez est\u00e9 contenido dentro del paquete <code>persona</code>.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#ejercicio-5","title":"Ejercicio 5","text":"<p>Declara un constructor para el viajero que admita como argumentos los valores de todos sus campos.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%2003%20-%20POO/Ejercicios/T3%20-%20Ejercicios/#extra","title":"EXTRA","text":"<p>Opcional. Para aquellos con experiencia previa en programaci\u00f3n que hayan terminado los ejercicios anteriores.</p> <p>Escribe un m\u00e9todo que compruebe que el DNI es v\u00e1lido.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/","title":"Tema 4: Excepciones","text":"<p>El mecanismo de excepciones es un sistema que nos permite detectar ciertas situaciones excepcionales que se pueden producir en nuestro programa y definir las acciones a llevar a cabo como respuesta a las mismas.</p> <p>Hasta cierto punto podemos identificar a las excepciones con errores.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#gestion-de-excepciones","title":"Gesti\u00f3n de excepciones","text":"<p>Si sabemos que una secci\u00f3n de nuestro c\u00f3digo corre el riesgo de generar una excepci\u00f3n (si se puede dar una o m\u00e1s condiciones excepcionales) durante su ejecuci\u00f3n, podremos poner a prueba ese segmento y capturar las excepciones que se puedan producir. Esto nos permitir\u00e1, principalmente, evitar que nuestro programa descarrile, podremos tomar medidas para recuperar una situaci\u00f3n estable retomar la ejecuci\u00f3n normal del programa.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#excepccion","title":"Excepcci\u00f3n","text":"<p>Una excepci\u00f3n es un objeto que puede ser lanzado con una sentencia <code>throw</code>:</p> <pre><code>Exception e = new Exception();\n\nthrow e;\n</code></pre>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#sentencia-try-cacth","title":"Sentencia <code>try-cacth</code>","text":"<p>La sentencia <code>try-catch</code> permite acotar un segmento de c\u00f3digo y capturar todas o algunas de la excepciones que se puedan producir dentro de un bloque de c\u00f3digo.</p> <p>La sintaxis de un bloque <code>try-catch</code> es la siguiente:</p> <pre><code>try {\n    // Bloque1\n    // Bloque de c\u00f3digo susceptible de lanzar una excepci\u00f3n.\n} catch (TipoDeExcepcion1 excepci\u00f3n1) {\n    // Bloque2\n    // Bloque de tratamiento de la situaci\u00f3n de excepci\u00f3n.\n    // Para una excepci\u00f3n del TipodDeExcepcion1\n\n} catch (TipoDeExcepcion2 excepci\u00f3n2) {// Opcional.\n    // Bloque3\n    // Bloque de tratamiento de la situaci\u00f3n de excepci\u00f3n.\n    // Para una excepci\u00f3n del TipodDeExcepcion1\n\n} finally { // Opcional. Bloque que se ejecutar\u00eda SIEMPRE.\n    // Bloque4\n    // Bloque de c\u00f3digo que se ejecutar\u00e1 siempre despu\u00e9s del Bloque1.\n}\n</code></pre> <p>N\u00f3tese que en una estructura <code>try-catch</code> pueden definirse varias sentencias <code>catch</code>. Esto nos permite tratar de forma distinta las distintas situaciones excepcionales que se puedan dar en nuestro bloque de c\u00f3digo <code>try</code>.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#excepciones-checked-y-unchecked","title":"Excepciones checked y unchecked","text":"<p>Las excepciones se pueden clasificar en dos tipos:</p> <ul> <li>Excepciones checked: Son aquellas que se pueden prever y que se deben tratar en el c\u00f3digo. El compilador nos obliga a tratarlas mediante un bloque <code>try-catch</code> o mediante una declaraci\u00f3n <code>throws</code> en la firma del m\u00e9todo. Son excepciones que se comprueban en tiempo de compilaci\u00f3n.</li> <li>Excepciones unchecked: Son aquellas que no se pueden prever y que no se deben tratar en el c\u00f3digo. El compilador no nos obliga a tratarlas mediante un bloque <code>try-catch</code> o mediante una declaraci\u00f3n <code>throws</code> en la firma del m\u00e9todo.</li> </ul> <p>El usdo de la cl\u00e1usula <code>throws</code> en la firma de un m\u00e9todo nos permite propagar la excepci\u00f3n a la llamada del m\u00e9todo:</p> <pre><code>public void metodo() throws TipoDeExcepcion1, TipoDeExcepcion2 {\n    // Bloque de c\u00f3digo susceptible de lanzar una excepci\u00f3n.\n}\n</code></pre> <p>Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; RuntimeException (unchecked) Object -&gt; Traceable -&gt; Throwable -&gt; Error (unchecked)</p> <p>Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; IOException Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; en tiempo de compilaci\u00f3n.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#lanzar-excepciones","title":"Lanzar excepciones","text":"<p>Cuando escribamos c\u00f3digo que pueda generar situaciones excepcionales podremos ser nosotros los que decidamos disparar o lanzar la excepci\u00f3n. Para ellos podremos escribir una sentencia <code>throw</code> que lance la excepci\u00f3n de la que nos interese avisar.</p> <p>Para lanzar una excepci\u00f3n hemos de crear un objeto del tipo de excepci\u00f3n que nos interese. Cuando creemos el objeto excepci\u00f3n podremos tambi\u00e9n indicar en un mensaje la cauda de la excepci\u00f3n:</p> <pre><code>import java.util.Random;\n\npublic class Excepciones {\n\n    /*\n     * En el siguiente m\u00e9todo s\u00f3lo admitiremos como par\u00e1metros valores positivos y que cumplan que\n     * min &lt; max.\n     */\n    public static int randomInt(int min, int max) {\n        if (min &lt; 0 || min &gt;= max) {\n            // Si no se cumplen nuestras restricciones lanzamos una excepci\u00f3n.\n            throw new IllegalArgumentException(\n                    String.format(\"min (%d) ha de ser menor que max (%d).\", min, max));\n        }\n        // Si se lanza una excepci\u00f3n se termina la ejecuci\u00f3n del m\u00e9todo por lo que nunca llegar\u00edamos\n        // a esta l\u00ednea de c\u00f3digo.\n\n        Random r = new Random();\n        return r.nextInt(max - min) + min;\n    }\n}\n</code></pre>"},{"location":"Tema%2004%20-%20Excepciones/T4.0%20-%20Excepciones/#capturar-excepciones","title":"Capturar excepciones","text":"<p>En primer lugar hemos de tener en cuenta que s\u00f3lo hemos de capturar aquellas excepciones que sepamos como resolver. Si no tenemos definida la forma en que vamos lidia con una situaci\u00f3n excepcional no debemos de capturar la excepci\u00f3n que produzca. Lo correcto ser\u00e1 dejar que el programa falle y se termine su ejecuci\u00f3n.</p> <p>Para capturar una excepci\u00f3n usaremos la estructura <code>try-catch</code>. Esta estructura tiene la siguiente sintaxis:</p> <pre><code>try {\n    // Bloque de c\u00f3digo que podr\u00eda lanzar una excepci\u00f3n.\n} catch (Exception e) {// Podremos indicar un tipo m\u00e1s espec\u00edfico de excepci\u00f3n.\n    // Bloque de c\u00f3digo para tratar la excepci\u00f3n\n\n} finally {\n    // Opcional en caso de que deseemos ejecutar alg\u00fan c\u00f3digo siempre\n    // a continuaci\u00f3n del bloque que puede producir la excepci\u00f3n.\n}\n</code></pre> <p>```java import java.util.Random;</p> <p>public class Excepciones {</p> <pre><code>/*\n * En el siguiente m\u00e9todo s\u00f3lo admitiremos como par\u00e1metros valores positivos y que cumplan que\n * min &lt; max.\n */\npublic static int randomInt(int min, int max) {\n    if (min &lt; 0 || min &gt;= max) {\n        // Si no se cumplen nuestras restricciones lanzamos una excepci\u00f3n.\n        throw new IllegalArgumentException(\n                String.format(\"min (%d) ha de ser menor que max (%d).\", min, max));\n    }\n    // Si se lanza una excepci\u00f3n se termina la ejecuci\u00f3n del m\u00e9todo por lo que nunca llegar\u00edamos\n    // a esta l\u00ednea de c\u00f3digo.\n\n    Random r = new Random();\n    return r.nextInt(max - min + 1) + min;\n}\n\npublic static void main(String[] args) {\n    int min = Integer.parseInt(args[0]);\n    int max = Integer.parseInt(args[1]);\n    try {\n        System.out.println(\"Vamos a invocar \\\"randomInt\\\"\");\n        int aleatorio = randomInt(min, max);\n        System.out.println(String.format(\"El n\u00famero generado ha sido %d.\", aleatorio));\n\n    } catch (Exception e) {\n        System.out.println(e); // Podremos mostrar por pantalla el mensaje de la excepci\u00f3n.\n    } finally {// Este condigo se ejecutar\u00e1 EN CUALQUIER CASO.\n        System.out.println(\"the end.\");\n    }\n}\n</code></pre> <p>} \u00b4\u00b4\u00b4</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.1%20-%20Debugging/","title":"Debugging","text":"<p>TODO: Explicar qu\u00e9 es debugging.</p> <p>TODO: Hacer un v\u00eddeo explicando c\u00f3mo hacer debugging en Visual Studio Code.</p> <p>TODO: Ejercicio para hacer debugging.</p>"},{"location":"Tema%2004%20-%20Excepciones/T4.2%20-%20Testing/","title":"Tema 4.2: Texting","text":"<p>Gracias a dios este tema ya lo dio Fernando en Contorno de desarrollo.</p>"},{"location":"Tema%2004%20-%20Excepciones/Ejercicios/T4%20-%20Ejercicios/","title":"Ejercicios tema 4: Excepciones, debugging y testing","text":""},{"location":"Tema%2004%20-%20Excepciones/Ejercicios/T4%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Utilizando arrays y la clase de utilidades <code>java.util.Arrays</code>...</p> <p>Crea una clase <code>Numeros</code> que:</p> <ul> <li>Pueda almacenar una lista de n\u00fameros enteros.</li> <li>Se pueda consultar el tama\u00f1o de la lista.</li> <li>Se puedan obtener el n\u00famero mayor y el n\u00famero menor de la lista.</li> <li>Se pueda obtener la media de los n\u00fameros de la lista.</li> <li>Se pueda obtener la mediana de los n\u00fameros de la lista.</li> </ul>"},{"location":"Tema%2004%20-%20Excepciones/Ejercicios/T4%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modifica el programa anterior para que:</p> <ul> <li>Se pueda obtener una versi\u00f3n ordenada de la lista de n\u00fameros.</li> <li>Se pueda obtener una lista con los n\u00fameros pares de la lista original.</li> <li>Se pueda obtener una lista con los n\u00fameros impares de la lista original.</li> </ul>"},{"location":"Tema%2004%20-%20Excepciones/Ejercicios/T4%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Modifica de nuevo la clase <code>Numeros</code> para que:</p> <ul> <li>Se pueda obtener el n\u00famero de n\u00fameros primos de la lista.</li> <li>Se pueda obtener un array con los n\u00fameros primos de la lista.</li> </ul>"},{"location":"Tema%2004%20-%20Excepciones/Ejercicios/T4%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Finalmente modifica la clase <code>Numeros</code> para que:</p> <ul> <li>Se pueda insertar un n\u00famero en la lista.</li> <li>En una posici\u00f3n concreta.</li> <li>Por el principio.</li> <li>Por el final.</li> <li>Se pueda elminar un n\u00famero de la lista.</li> <li>De una posici\u00f3n concreta.</li> <li>Por el principio.</li> <li>Por el final.</li> </ul>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.0%20-%20Polimorfismo/","title":"Tema 5: Conceptos avanzados de POO","text":"<p>En este tema veremos algunos conceptos m\u00e1s avanzados de la orientaci\u00f3n a objetos como son:</p> <ul> <li>Polimorfismo.</li> <li>Interfaces.</li> <li>Clases abstractas.</li> </ul>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.0%20-%20Polimorfismo/#polimorfismo","title":"Polimorfismo","text":"<p>Polimorfismo significa \"muchas formas\". Eso se asocia con la capacidad de distintos lenguajes de programaci\u00f3n de que un elemento tome distintas formas en distintos contextos. En Java el polimorfismo se puede dar de varias formas:</p> <ul> <li>Polimorfismo de clase: O asignaci\u00f3n polimorfa derivada del concepto de herencia.</li> <li>Polimorfismo de m\u00e9todo: O ejecuci\u00f3n polimorfa por la que una clase puede definir varios algoritmos distintos para un mismo m\u00e9todo.</li> </ul>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.0%20-%20Polimorfismo/#polimorfismo-de-clase","title":"Polimorfismo de clase","text":"<p>Como hemos visto en el apartado dedicado a la herencia, una subclase es una especificaci\u00f3n de su superclase. Esto permite que podamos asignar objetos de muchas formas distintas (subclases) a una variable de una \u00fanica clase (la superclase). Este concepto se aplica tanto a clases y clases abstractas como a interfaces.</p> <p>Veamos el caso del m\u00e9todo <code>toString</code>. Este m\u00e9todo est\u00e1 implementado en la clase <code>Object</code>. Como <code>Object</code> es superclase de toda otra clase de Java esto significa el que m\u00e9todo estar\u00e1 disponible para todas las clases de Java.</p> <p>Si quisi\u00e9semos crear un m\u00e9todo (como <code>println</code>) que muestre la cadena que represente al objeto podr\u00edamos crearlo con el siguiente c\u00f3digo:</p> <pre><code>public void muestra(Object obj) {\n    System.out.println(obj.toString());\n}\n</code></pre> <p>Si creamos la clase alumno de la siguiente manera:</p> <pre><code>public class Alumno {\n    private String nombre;\n    private String apellidos;\n    private String DNI;\n    private int numero;\n\n    public Alumno(String nombre, String apellidos, String DNI, int numero) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.DNI = DNI;\n        this.numero = numero;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Alumno %s, %s con DNI %s y n\u00famero %d.%n\", apellidos, nombre, DNI, numero);\n    }\n}\n</code></pre> <p>Y le pasamos un objeto de la clase <code>Alumno</code> al m\u00e9todo antes creado:</p> <pre><code>Alumno alumno = new Alumno(\"Juan\", \"Sin Miedo\", \"87654321A\");\n\nmuestra(alumno);\n</code></pre> <p>Por un lado el m\u00e9todo aceptar\u00e1 el objeto ya que, adem\u00e1s de la clase <code>Alumno</code> tambi\u00e9n lo es de <code>Object</code> (todas las clases son subclases de <code>Object</code>). Adem\u00e1s, al invocar al m\u00e9todo <code>toString</code> se ejecutar\u00e1 la implementaci\u00f3n del objeto de la clase <code>Alumno</code>.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.0%20-%20Polimorfismo/#polimorfismo-de-metodo","title":"Polimorfismo de m\u00e9todo","text":"<p>Este polimorfismo se refiere a la capacidad que tiene una clase de definir distintas implementaciones de un m\u00e9todo dependiendo del tipo de objeto con que se invoque (de sus argumentos). Podr\u00edamos decir que en este caso podr\u00edamos ejecutar la misma acci\u00f3n de distintas formas sobre distintos elementos.</p> <p>Por ejemplo. El m\u00e9todo que escribimos al comienzo de este tema, <code>mostrar</code> funcionar\u00e1 con cualquier objeto pero no con los tipos primitivos: <code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>, etc.</p> <p>Para solucionar esto podremos a\u00f1adir m\u00e1s m\u00e9todos:</p> <p>```java public void muestra(Object obj) {     System.out.println(obj.toString()); }</p> <p>public void muestra(int i) {     System.out.println(Integer.toString(i)); }</p> <p>public void muestra(float f) {     System.out.println(Float.toString(f)); }</p> <p>public void muestra(boolean b) {     System.out.println(Boolean.toString(b)); } ``</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.1%20-%20Interfaces/","title":"Tema 5.1: Interfaces","text":""},{"location":"Tema%2005%20-%20POO%20Extra/T5.1%20-%20Interfaces/#introduccion","title":"Introducci\u00f3n","text":"<p>Las interfaces son un tipo de clase que s\u00f3lo contiene m\u00e9todos y constantes. No puede contener atributos ni constructores. Las interfaces son muy \u00fatiles para definir comportamientos que pueden ser implementados / compartidos por diferentes clases.</p> <p>Un interfaz podr\u00e1 definir:</p> <ul> <li>Constantes: <code>static final PI = 3.1416;</code></li> <li>M\u00e9todos abstractos: <code>public double area();</code></li> <li>M\u00e9todos por defecto: <code>default void metodo() {\\\\cuerpo del m\u00e9todo}</code></li> </ul>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.1%20-%20Interfaces/#sintaxis","title":"Sintaxis","text":"<p>La sintaxis de una interfaz es la siguiente:</p> <pre><code>public interface NombreDeLaInterfaz {\n    // Constantes\n    static final int CONSTANTE = 5;\n    //...\n\n    // M\u00e9todos abstractos.\n    void metodo1();\n    int metodo2();\n    default int metodo3() {\n        return 0;\n    }\n    //...\n}\n</code></pre> <p>Los m\u00e9todos declarados en la interfaz anterior se denominan m\u00e9todos abstractos. Estos m\u00e9todos no tienen cuerpo, es decir, no tienen implementaci\u00f3n. La implementaci\u00f3n de estos m\u00e9todos se realiza en las clases que implementan la interfaz.</p> <p>Tambi\u00e9n existe la posibilidad de declarar m\u00e9todos con cuerpo en una interfaz. Estos m\u00e9todos se denominan m\u00e9todos por defecto <code>default</code>. Ya que estos m\u00e9todos se implementan en la interfaz no es necesario que las clases la implementen los sobrescriban (aunque es posible hacerlo).</p> <pre><code>public interface NombreDeLaInterfaz {\n    // Constantes\n    static final int CONSTANTE = 5;\n    //...\n\n    // M\u00e9todos por defecto:\n    default void metodo1() {\n\n    }\n    default int metodo2() {\n        return 0;\n    }\n    //...\n}\n</code></pre> <p>Cuando deseamos indicar que una clase cumple los requisitos de una interfaz, usamos la palabra reservada <code>implements</code>:</p> <pre><code>public class NombreDeLaClase implements NombreDeLaInterfaz {\n    //...\n}\n</code></pre>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.1%20-%20Interfaces/#ejemplo","title":"Ejemplo","text":"<pre><code>public interface Superficie {\n    public static final double PI = 3.1416;\n\n    public double area();\n    public double perimetro();\n}\n</code></pre> <p>Cuando creemos la clase que implemente la interfaz, debemos implementar todos los m\u00e9todos de la interfaz:</p> <pre><code>public class Circulo implements Superficie {\n    private double radio;\n\n    public Circulo(double radio) {\n        this.radio = radio;\n    }\n\n    @Override\n    public double area() {\n        return PI * radio * radio;\n    }\n\n    @Override\n    public double perimetro() {\n        return 2 * PI * radio;\n    }\n}\n</code></pre> <p>Una clase puede implementar varias interfaces:</p> <pre><code>public class Circulo extends Figura implements Interfaz1, Interfaz2 {\n    //...\n}\n</code></pre>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.1%20-%20Interfaces/#herencia-de-interfaces","title":"Herencia de interfaces","text":"<p>Una interfaz puede heredar de otras interfaces. Para ello usamos la palabra reservada <code>extends</code>:</p> <pre><code>public interface InterfazHija extends InterfazPadre1, InterfazPadre2 {\n    //...\n}\n</code></pre> <p>Como podemos ves las interfaces, a diferencia de una clases, pueden heredar de varias interfaces.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/","title":"Tema 5.2: Clases abstractas","text":"<p>Una clase abstracta es una clase como otra clase cualquier con dos salvedades:</p> <ul> <li>No se se puede instanciar. Es decir, no podemos crear objetos de una clase abstracta.</li> <li>Puede contener m\u00e9todos abstractos. Tiene que tener al menos un m\u00e9todo abstracto.</li> </ul>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/#declaracion-de-una-clase-abstracta","title":"Declaraci\u00f3n de una clase abstracta","text":"<p>Para declarar una clase como abstracta, usamos la palabra reservada <code>abstract</code>:</p> <pre><code>public abstract class NombreDeLaClase {\n    //...\n}\n</code></pre>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Un m\u00e9todo abstracto es un m\u00e9todo en el que \u00fanicamente se declara su firma, pero no su implementaci\u00f3n. Es decir, no se indica c\u00f3mo se va a implementar el m\u00e9todo. La implementaci\u00f3n del m\u00e9todo se realiza en las clases que hereden de la clase abstracta.</p> <p>Para declarar un m\u00e9todo abstracto usaremos, de nuevo, la palabra reservada <code>abstract</code>. La sintaxis es la siguiente:</p> <pre><code>public abstract class NombreDeLaClase {\n    public abstract void metodoAbstracto();\n}\n</code></pre> <p>Tambi\u00e9n es posible declarar m\u00e9todos completos en una clase abstracta. Estos m\u00e9todos se heredar\u00e1n en sus clases hijas como cualquier otro m\u00e9todo de cualquier otra clase.</p> <pre><code>public abstract class NombreDeLaClase {\n    public abstract void metodoAbstracto();\n\n    public void metodoNormal() {\n        //...\n    }\n\n}\n</code></pre>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/#extras","title":"Extras","text":"<p>Curiosidades relacionadas con las clases abstractas.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/#clases-con-constructor-privado","title":"Clases con constructor privado","text":"<p>Otra forma de evitar que una clase pueda ser instanciada es la siguiente:</p> <pre><code>public class ClaseNoInstanciable {\n    private ClaseNoInstanciable() {\n        //...\n    }\n}\n</code></pre> <p>Si hacemos el constructor por defecto privado, no podremos instanciar la clase. Esto es \u00fatil cuando queremos que una clase no pueda ser instanciada, pero no queremos que sea abstracta.</p> <p>Adem\u00e1s de que la clase no pueda ser instanciada tambi\u00e9n logramos que no se puedan crear subclases de esta clase. Esto se debe a que toda subclase de una clase llama impl\u00edcitamente al constructor de la superclase. Si el \u00fanico constructor de la superclase es el constructor por defecto y, adem\u00e1s, este es privado, ninguna subclase podr\u00e1 ser instanciada.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.2%20-%20Clases%20abstractas/#clases-finales","title":"Clases finales","text":"<p>Si lo que no queremos es que se puedan crear subclases de una clase podremos declarar esta como <code>final</code>. De esta forma, no se podr\u00e1 heredar de esta clase.</p> <pre><code>public final class ClaseNoHeredable {\n    //...\n}\n</code></pre> <p>Lo que no est\u00e1 permitido es crear una clase no instanciable <code>abstract</code> y que adem\u00e1s sea <code>final</code>. Esto no tiene sentido, ya que una clase <code>final</code> no puede ser heredada, por lo que no tiene sentido que sea <code>abstract</code>.</p> <p>Aunque este comportamiento S\u00cd tiene sentido si queremos tener una clase que unicamente contenga m\u00e9todos est\u00e1ticos (como es el caso de la clase <code>Arrays</code> o <code>Math</code>). En este caso, la clase s\u00ed que puede ser instanciada, pero no se puede heredar de ella. Esto es lo que vimos en el apartado anterior \"Clases con constructor privado\" (<code>Arrays</code> y <code>Math</code> son dos ejemplos).</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/","title":"Tema 5.3: Recursividad","text":"<p>El concepto de recursividad, aunque no est\u00e1 ligado en absoluto a la POO es lo suficientemente importante como para dedicarle este espacio.</p> <p>La recursividad est\u00e1 ligada al concepto de funci\u00f3n (m\u00e9todo en Java) y la programaci\u00f3n funcional. Diremos que una funci\u00f3n (o m\u00e9todo) es recursiva cuando la funci\u00f3n se llama a s\u00ed misma. El ejemplo cl\u00e1sico de funci\u00f3n recursiva es la funci\u00f3n que describe la serie de Fibonacci.</p> <p>Funci\u00f3n de Fibonacci:</p> <ul> <li>Fibonacci de 0: fib(0) = 0.</li> <li>Fibonacci de 1: fib(1) = 1.</li> <li>Fibonacci de 1: fib(2) = 1.</li> <li>Fibonacci de 1: fib(3) = fib(1) + fib(2).</li> <li>Fibonacci de 1: fib(4) = fib(2) + fib(3).</li> <li>...</li> <li>Fibonacci de 1: fib(n) = fib(n - 2) + fib(n - 1).</li> </ul> <p>Si implementamos una clase con la funci\u00f3n de Fibonacci en Java har\u00edamos lo siguiente:</p> <pre><code>public static int fibonacci(int x) {\n    if (x == 0) return 0;\n    if (x == 1) return 1;\n    if (x == 2) return 2;\n\n    return fibonacci(x - 1) + fibonacci(x - 2);\n}\n</code></pre>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#elementos-de-una-funcion-recursiva","title":"Elementos de una funci\u00f3n recursiva","text":""},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#lamada-recursiva","title":"Lamada recursiva","text":"<p>La llamada recursiva es simplemente la invocaci\u00f3n de la misma funci\u00f3n en la que nos encontramos desde ella misma. Dentro de una funci\u00f3n puede haber una o m\u00e1s llamadas a ella misma (como en el caso de Fibonacci).</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#caso-base-salida-de-la-recursion","title":"Caso base / salida de la recursi\u00f3n","text":"<p>El caso base es aquel que no nos lleva a una llamada recursiva si no que devuelve directamente el resultado. En el ejemplo de Fibonacci, <code>fibonacci(0)</code>, <code>fibonacci(1)</code> y <code>fibonacci(2)</code> so los tres casos base.</p> <p>Si una funci\u00f3n recursiva no tuviese caso base nunca se romper\u00eda la cadena de llamadas recurivas y no econtrar\u00edamos, en cierto modo, ante el mismo caso de un bucle sin fin.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#eficiencia","title":"Eficiencia","text":"<p>Aunque hay casos como el de la funci\u00f3n de Fibonacci donde la soluci\u00f3n recursiva es la m\u00e1s natural, muchas veces sucede que esta soluci\u00f3n es muy ineficiente. Esto se debe principalmente a que en una funci\u00f3n recursiva se producen muchas llamadas consecutivas a una funci\u00f3n sin que haya terminado la funci\u00f3n en que nos encontramos y al impacto que esto tiene en la pila de llamadas.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#pila-de-llamadas-stack","title":"Pila de llamadas / stack","text":"<p>Cuando invocamos una funci\u00f3n hemos de preservar el estado en que se encuentra nuestro programa hasta ese momento. A continuaci\u00f3n pasaremos el control a la funci\u00f3n y, cuando esta termine, tomaremos el valor devuelto, desempaquetaremos el estado previamente guardado de nuestro programa y continuaremos con su ejecuci\u00f3n.</p> <p>Si desde dentro de una funci\u00f3n llamamos a otra funci\u00f3n ser\u00e1 necesario, al igual que en el caso anterior, guardar su estado de ejecuci\u00f3n (variables locales, punto de ejecuci\u00f3n, etc.) hasta que la funci\u00f3n llamada finalice y le devuelva el control. De este modo si encadenamos llamadas a una funci\u00f3n sin que esta termine iremos apilando funciones y su estado continuamente. Dependiendo del n\u00famero de llamadas recursivas que se produzca esto podr\u00e1 tener un fuerte impacto tanto en la memoria como en el tiempo de ejecuci\u00f3n (ya que empaquetar y guardar el estado tiene un coste de CPU).</p> <p>Es por este motivo que las soluciones recursivas tienen mala fama y por el que se han desarrollado t\u00e9cnicas para transformar una soluci\u00f3n recursiva en otra iterativa.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/T5.3%20-%20Recursividad/#recursividad-de-cola","title":"Recursividad de cola","text":"<p>En el apartado anterior hablamos de la penalizaci\u00f3n en eficiencia de las funciones recursivas. Este no es el caso siempre, hay un subconjunto de funciones recursivas que (en los lenguajes actuales) no tienen penalizaci\u00f3n alguna. Estas son las que tienen recursividad de cola.</p> <p>La recursividad de cola se produce cuando la llamada recursiva es la \u00faltima instrucci\u00f3n de la funci\u00f3n. En este caso no es necesario guardar nada del estado interno de la funci\u00f3n que realiza la llamada ya que su resultado depende \u00fanicamente de los datos que se le hayan pasado a la nueva funci\u00f3n en la llamada.</p> <pre><code>// Como hacer un bucle con una funci\u00f3n recursiva\npublic static int recursiva(int i, int x) {\n    if (x == 0) return null;\n    System.out.println(String.format(\"Iteraci\u00f3n %d del bucle.\", i));\n    recursiva(i + 1; x - 1);\n}\n</code></pre> <p>Esta optimizaci\u00f3n se denomina TCO (Tail Call Optimization). I aparentemente Java no la tiene.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/Ejercicios/T5%20-%20Ejericicios/","title":"Tema 5: Ejercicios","text":""},{"location":"Tema%2005%20-%20POO%20Extra/Ejercicios/T5%20-%20Ejericicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Codifica la jerarqu\u00eda ser vivo, animal y vegetal, creando las estructuras que consideres necesario para almacenar de cada elemento, como m\u00ednimo, nombre cient\u00edfico y nombre com\u00fan. Para los animales almacenaremos peso y altura. Paralos vegetales \u00fanicamente altura. Cada ser vivo se alimentar\u00e1 de una manera diferente, por lo que deber\u00e1 reflejar este aspecto de alguna forma.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/Ejercicios/T5%20-%20Ejericicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Implementa el escenario propuesto en la figura y a\u00f1ade las declaraciones de los getters y setters para cada uno de los campos, as\u00ed como constructores parametrizados a cada una de las clases.</p> <p></p>"},{"location":"Tema%2005%20-%20POO%20Extra/Ejercicios/T5%20-%20Ejericicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Si se desea manejar informaci\u00f3n sobre, \u00fanicamente, las figuras geom\u00e9tricas punto, recta y circunferencia, \u00bfqu\u00e9 tipo de relaci\u00f3n establecer\u00eda entre ellas? Justifica tu respuesta.</p> <p>Codifica la soluci\u00f3n que hayas propuesto junto con un programa que muestre  un men\u00fa que permita crear los tres objetos de las clases indicadas y mostrar la informaci\u00f3n de los mismos.</p>"},{"location":"Tema%2005%20-%20POO%20Extra/Ejercicios/T5%20-%20Ejericicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Haz una clase llamada <code>Persona</code> que siga las siguientes condiciones:</p> <p>Sus atributos son: </p> <ul> <li>nombre</li> <li>edad</li> <li>DNI</li> <li>sexo (H hombre, M mujer)</li> <li>peso</li> <li>altura</li> </ul> <p>No queremos que se accedan directamente a ellos. Si quieres a\u00f1adir alg\u00fan atributo puedes hacerlo.</p> <p>Todos los atributos menos el DNI ser\u00e1n valores por defecto seg\u00fan su tipo (0 n\u00fameros, cadena vac\u00eda para String, etc.). Sexo sera hombre por defecto, (usa una constante para representar el sexo).</p> <p>Se implantaran varios constructores:</p> <ul> <li>Un constructor por defecto.</li> <li>Un constructor\u00a0con el nombre, edad y sexo, el resto por defecto.</li> <li>Un constructor\u00a0con todos los atributos como par\u00e1metro.</li> </ul> <p>Los m\u00e9todos que se implementaran son:</p> <ul> <li><code>calcularIMC()</code>: calculara si la persona esta en su peso ideal (peso en kg/(altura^2  en m)), si esta f\u00f3rmula devuelve un valor menor que 20, la funci\u00f3n devuelve un -1, si devuelve un n\u00famero entre 20 y 25 (incluidos), significa que esta por debajo de su peso ideal\u00a0la funci\u00f3n devuelve un 0  y si devuelve un valor mayor que 25 significa que tiene sobrepeso, la funci\u00f3n devuelve un 1. Te recomiendo que uses constantes para devolver estos valores.</li> <li><code>esMayorDeEdad()</code>: indica si es mayor de edad, devuelve un booleano.</li> <li><code>comprobarSexo(char sexo)</code>: comprueba que el sexo introducido es correcto. Si no es correcto, sera H. No sera visible al exterior.</li> <li><code>generaDNI()</code>: genera un n\u00famero aleatorio de 8 cifras, genera a partir de este su n\u00famero su letra correspondiente. Este m\u00e9todo sera invocado cuando se construya el objeto. Puedes dividir el m\u00e9todo para que te sea m\u00e1s f\u00e1cil. No ser\u00e1 visible al exterior.</li> <li><code>toString()</code>: devuelve una cadena respresentado las propiedades del objeto.</li> <li>M\u00e9todos set de cada par\u00e1metro, excepto de DNI.</li> </ul> <p>Ahora, crea una clase ejecutable que haga lo siguiente:</p> <ul> <li>Pide por teclado el nombre, la edad, sexo, peso y altura.</li> <li>Crea 3 objetos de la clase anterior, el primer objeto obtendr\u00e1 las anteriores variables pedidas por teclado, el segundo objeto obtendr\u00e1 todos los anteriores menos el peso y la altura y el \u00faltimo por defecto, para este \u00faltimo utiliza los m\u00e9todos set para darle a los atributos un valor.</li> <li>Para cada objeto, deber\u00e1 comprobar si esta en su peso ideal, tiene sobrepeso o por debajo de su peso ideal con un mensaje.</li> <li>Indicar para cada objeto si es mayor de edad.</li> <li>Por \u00faltimo, mostrar la informaci\u00f3n de cada objeto.</li> </ul> <p>Puedes usar m\u00e9todos en la clase ejecutable, para que os sea mas f\u00e1cil.</p>"},{"location":"Tema%2006%20-%20Proyectos/T6.0%20-%20Proyectos/","title":"Proyectos","text":"<p>Cuando desarrollamos una aplicaci\u00f3n en Java (o cualquier otro lenguaje) lo normal no es empezar a escribir c\u00f3digo. Para tener el c\u00f3digo organizado, hacer un seguimiento de las librer\u00edas que utilizamos y compartir las tareas de desarrollo con otras personas lo normal es crear un proyecto.</p> <p>Los EID de Java incluyen las herramientas necesarias apara organizar nuestro c\u00f3digo en proyectos.</p> <p>Adem\u00e1s de disponer de dichas herramientas hay otras independientes del EID que nos facilitan el mantenimiento de nuestro proyectos.</p> <p>Dos de ellas son Maven y Graddle.</p>"},{"location":"Tema%2006%20-%20Proyectos/T6.0%20-%20Proyectos/#maven","title":"Maven","text":"<p>TODO: Pendiente de hacerlo. Algo se hizo ya en Contornos.</p>"},{"location":"Tema%2006%20-%20Proyectos/T6.1%20-%20Maven/","title":"Tema 6.1: Maven","text":"<p>Hago lo que puedo. Esto esta pendiente de hacerse.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.0%20-%20Introduccion/","title":"Tema 7: Introducci\u00f3n a estructuras de datos avanzadas","text":"<p>Adem\u00e1s de los arrays que hemos estado viendo hasta el momento Java nos ofrece una serie de estructuras de datos m\u00e1s avanzadas que nos permiten almacenar y manipular conjuntos de datos de una forma m\u00e1s eficiente. Estas estructuras se pueden agrupar en tres grandes grupos:</p> <ul> <li>Listas: Una lista es una colecci\u00f3n de elementos ordenados. Los elementos de una lista pueden ser accedidos mediante un \u00edndice que indica su posici\u00f3n en la lista. Las listas pueden contener elementos duplicados y permiten la inserci\u00f3n (y borrado) de elementos en cualquier posici\u00f3n dentro de la lista. Un ejemplo de listas son las clases <code>ArrayList</code> y <code>LinkedList</code>.</li> <li>Conjuntos: Un conjunto es una colecci\u00f3n de elementos no ordenados. Los elementos de un conjunto no pueden repetirse. Un ejemplo de conjuntos son las clases <code>HashSet</code> y <code>TreeSet</code>.</li> <li>Mapas: Un mapa es una colecci\u00f3n de elementos no ordenados. Los elementos de un mapa se almacenan en pares de clave-valor. Estos pares clave-valor no pueden repetirse. Un ejemplo de mapas son las clases <code>HashMap</code> y <code>TreeMap</code>.</li> </ul> <p>Es importante tener en cuenta que las estructuras de datos avanzadas no son m\u00e1s que una forma de almacenar y manipular datos. Por lo tanto, no se puede decir que una estructura de datos es mejor que otra. Depender\u00e1 de las necesidades de cada aplicaci\u00f3n y de la forma en la que se vayan a utilizar los datos.</p> <p>Todas estas estructuras se basan en la implementaci\u00f3n de distintos interfaces que definen los m\u00e9todos que deben implementar. Por este motivo recomiendo que se repase el apartado del tema 5 sobre interfaces.</p> <p>Adem\u00e1s del uso de interfaces estas estructuras se basan en la utilizaci\u00f3n del mecanismo de gen\u00e9ricos que permite definir clases y m\u00e9todos que pueden trabajar con cualquier tipo de datos. En el siguiente apartado pasaremos a explicar su funcionamiento.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/","title":"Tema 7.1: Gen\u00e9ricos","text":""},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#introduccion","title":"Introducci\u00f3n","text":"<p>\u00bfPara qu\u00e9 sirven los gen\u00e9ricos?</p> <p>Los gen\u00e9ricos nos permiten crear clases y m\u00e9todos que pueden trabajar con cualquier tipo de dato, sin necesidad de especificar el tipo de dato concreto en el momento de definir las clases. Debido a que no se especifica el tipo exacto en la fase de dise\u00f1o de la clase podemos decir que usa un tipo gen\u00e9rico y de ah\u00ed su nombre.</p> <p>En el momento en que creemos objetos de una clase que use gen\u00e9ricos s\u00ed hemos de concretar con qu\u00e9 tipo de datos va a trabajar.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#ejemplo-practico","title":"Ejemplo pr\u00e1ctico","text":"<p>Ve\u00e1moslo con un ejemplo:</p> <p>Imaginemos que queremos que una clase almacenen un valor <code>Integer</code> y pueda imprimirlo:</p> <pre><code>public class AlmacenEntero {\n    private Integer valor;\n    public AlmacenEntero(Integer valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Esta clase s\u00f3lo puede almacenar e imprimir valores <code>Integer</code>, pero si queremos una clase que tenga la misma funcionalidad que pueda almacenar valores <code>Double</code> o <code>Float</code>, tendremos que crear una nueva clase (virtualmente id\u00e9ntica) para cada tipo de dato nuevo que queramos tratar:</p> <pre><code>public class AlmacenDoble {\n    private Double valor;\n    public AlmacenDoble(Double valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Para evitar tener que repetir una y otra vez el mismo c\u00f3digo en cada clase podemos utilizar los gen\u00e9ricos. Esto permitir\u00e1 crear una clase que pueda almacenar cualquier tipo de dato y que pueda imprimirlo. Indicaremos el tipo concreto en el momento de usar la clase (de crear un objeto). El c\u00f3digo de la clase ser\u00eda de esta forma gen\u00e9rico. Valdr\u00eda para cualquier tipo de dato.</p> <p>En el siguiente ejemplo de c\u00f3digo usamos <code>T</code> para indicar un tipo cualquiera que especificaremos en otro momento. No es necesario usar la letra T pero una vez la indiquemos hemos de mantener la consistencia y emplear la misma letra para indicar el tipo gen\u00e9rico:</p> <pre><code>public class Almacen&lt;T&gt; {\n    private T valor;\n    public Almacena(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>A la hora de utilizarlo debemos indicar el tipo de dato concreto que queremos almacenar. Por ejemplo, si queremos almacenar un <code>Integer</code>:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Almacen&lt;Integer&gt; almacen = new Almacen&lt;&gt;(5);\n        almacen.imprimir();\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#sintaxis-de-los-genericos","title":"Sintaxis de los gen\u00e9ricos","text":"<p>Como acabamos de ver en el ejemplo la sintaxis de los gen\u00e9ricos es muy sencilla.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#declaracion-de-la-clase","title":"Declaraci\u00f3n de la clase","text":"<p>En el momento de declarar una clase que use gen\u00e9ricos primero escribiremos el c\u00f3digo de declaraci\u00f3n de la misma como siempre:</p> <pre><code>public class MiClase {\n    //...\n}\n</code></pre> <p>A continuaci\u00f3n indicaremos entre los s\u00edmbolos <code>&lt;</code> y <code>&gt;</code> una palabra (generalmente la letra T) que indica el tipo gen\u00e9rico:</p> <pre><code>public class MiClase&lt;T&gt; {\n    //... \n}\n</code></pre> <p>Si fuese necesario se podr\u00e1n indicar varios gen\u00e9ricos:</p> <pre><code>public class MiClase&lt;T, E&gt; {\n    //...\n}\n</code></pre> <p>Despu\u00e9s de indicar el c\u00f3digo (T, E, etc.) del tipo gen\u00e9rico que se va a utilizar en la clase podremos utilizar este c\u00f3digo como indicador de tipo de las variables y m\u00e9todos:</p> <pre><code>public class MiClase&lt;T, E&gt; {\n    private ArrayList&lt;T&gt; datos;\n\n    public E resultado(T dato) {\n        // ...\n    }\n}\n</code></pre> <p>Cuando, al usar la clase gen\u00e9rica, indiquemos el tipo concreto que queremos usar se substituir\u00e1 <code>T</code> en el c\u00f3digo de la clase por dicho tipo concreto.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#uso-de-la-clase","title":"Uso de la clase","text":"<p>Cuando necesitemos crear una instancia de nuestra clase hemos de concretar con qu\u00e9 dato va a trabajar:</p> <pre><code>MiClase&lt;Integer, String&gt; mc = new MiClase&lt;Integer, String&gt;();\n</code></pre> <p>Puesto que es redundante repetir el tipo de dato Java permite omitirlo para mayor comodidad:</p> <pre><code>MiClase&lt;String&gt; mc = new MiClase&lt;&gt;();\n</code></pre> <p>Esto har\u00e1 que Java transforme el c\u00f3digo del la clase gen\u00e9rica en el siguiente antes de crear la instancia: (Es una forma de verlo, no digo que haga esto literalmente).</p> <pre><code>public class MiClase {\n    private ArrayList&lt;Integer&gt; datos;\n\n    public String resultado(Integer dato) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#tipos-de-datos-genericos","title":"Tipos de datos gen\u00e9ricos","text":"<p>El tipo dato que indicamos al crear la clase gen\u00e9rica puede ser cualquier tipo de dato, incluyendo clases, interfaces, etc. pero no puede ser un tipo primitivo.</p> <pre><code>// El siguiente c\u00f3digo no ser\u00eda v\u00e1lido:\nMiClase&lt;int&gt; mc = new MiClase&lt;&gt;();\n// Tendr\u00edamos que utilizar la clase envoltorio Integer:\nMiClase&lt;Integer&gt; mc = new MiClase&lt;&gt;();\n</code></pre> <p>N\u00f3tese tambi\u00e9n que, si trabajamos con tipos primitivos (<code>int</code>, <code>float</code>, <code>boolean</code>, etc.) no es necesario convertir expl\u00edcitamente \u00e9ste a su tipo envoltorio (<code>Integer</code>, <code>Float</code>, <code>Boolean</code>, etc.) ya que Java lo hace autom\u00e1ticamente.</p> <pre><code>ArrayList&lt;Integer&gt; listaInt = new ArrayList&lt;&gt;();\n\nlistaInt.add(5); // Esto es v\u00e1lido\nlistaInt.add\n(Integer.valueOf(6)); // Esto tambi\u00e9n es v\u00e1lido pero m\u00e1s complicado e innecesario.\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#genericos-limitados","title":"Gen\u00e9ricos limitados","text":"<p>Tambi\u00e9n es posible limitar o restringir las caracter\u00edsticas del tipo de datos gen\u00e9rico que vamos a usar.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#limitar-superclase","title":"Limitar superclase","text":"<p>Por ejemplo, si queremos usar un tipo gen\u00e9rico pero que sea de un tipo dado (por ejemplo <code>Persona</code>) lo podemos indicar como:</p> <pre><code>public class Almacen&lt;T extends Persona&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Una vez hecho esto una variable de tipo <code>T</code> tendr\u00e1 acceso a todos los m\u00e9todos de <code>Persona</code> y, cuando se cree una instancia de <code>Almacen</code> se tendr\u00e1 que indicar un tipo que herede de <code>Persona</code>.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#limitar-interfaz","title":"Limitar interfaz","text":"<p>Del mismo modo que podemos limitar cual ha de ser la superclase del tipo de nuestro gen\u00e9rico tambi\u00e9n podemos hacer lo mismo con respecto a un interfaz:</p> <pre><code>public class Almacen&lt;T extends Comparable&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>N\u00f3tese que hemos de utilizar extends tanto para indicar la superclase como el interfaz que implementa y no implements (que ser\u00eda lo l\u00f3gico).</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#limitar-superclase-e-interfaces","title":"Limitar superclase e interfaces","text":"<p>Podemos combinar la limitaci\u00f3n de superclase con la indicaci\u00f3n de que ha de implementar uno o m\u00e1s interfaces. Para ello hemos de indicar primero siempre la superclase y a continuaci\u00f3n todos los interfaces que deseemos separados por &amp;:</p> <pre><code>public class Almacen&lt;T extends Persona &amp; Comparable &amp; Serializable&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#metodos-genericos","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Los m\u00e9todos tambi\u00e9n pueden ser gen\u00e9ricos. Para ello, simplemente indicamos el tipo de dato gen\u00e9rico entre <code>&lt;</code> y <code>&gt;</code> despu\u00e9s del tipo de retorno del m\u00e9todo.</p> <pre><code>public class Printer {\n    public static &lt;T&gt; void print(T valor) {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Si queremos que el m\u00e9todo admita m\u00e1s de un gen\u00e9rico:</p> <pre><code>public class GenericMethod {\n    public static &lt;T, U&gt; void print(T valor1, U valor2) {\n        System.out.println(valor1);\n        System.out.println(valor2);\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#como-usarlos","title":"\u00bfC\u00f3mo usarlos?","text":"<p>Se usan como cualquier otro m\u00e9todo sin que haya que tener en cuenta que son gen\u00e9ricos. Si se incumple alguna de las restricciones en la invocaci\u00f3n el compilador nos indicar\u00e1 cu\u00e1l es el problema.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.1%20-%20Genericos/#comodines-wildcards","title":"Comodines (wildcards)","text":"<p>Hay casos en los que deseamos indicar que un m\u00e9todo que estamos escribiendo admite un tipo gen\u00e9rico con cualquier tipo de datos. Veamos un ejemplo:</p> <pre><code>public class MiClase {\n    //...\n    // Este c\u00f3digo no es correcto, es s\u00f3lo ilustrativo.\n    public static void imprime(List&lt;DeLoQueSea&gt; lista) {\n        //...\n    }\n}\n</code></pre> <p>Nuestro m\u00e9todo <code>imprime</code> estar\u00e1 dise\u00f1ado de manera que pueda imprimir una lista independientemente de lo que contenga. Para indicar esto en la sintaxis de gen\u00e9ricos hemos de escribir un comod\u00edn (<code>?</code>) como tipo de la lista:</p> <pre><code>public class MiClase {\n    //...\n    // Este c\u00f3digo no es correcto, es s\u00f3lo ilustrativo.\n    public static void imprime(List&lt;?&gt; lista) {\n        //...\n    }\n\n    public static void main(String[] args) {\n        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        al.add(1);\n        al.add(2);\n        al.add(3);\n\n        imprime(list); // No dar\u00eda problemas.\n\n        LinkedList&lt;String&gt; llist = new LinkedList&lt;&gt;();\n        ll.add(\"1\");\n        ll.add(\"2\");\n        ll.add(\"3\");\n\n        imprime(llist); // No dar\u00eda problemas.\n\n\n        int[] intArr = {1, 2, 3};\n        imprime(intArr); // Dar\u00eda error.\n    }\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/","title":"Tema 7.2: <code>Collections</code>","text":"<p>Para hablar de las estructura de datos avanzadas de Java hemos de tener claros varios conceptos.</p> <p>Necesitamos entender en qu\u00e9 consiste el interfaz <code>Iterable</code> y, para ello, hemos de tener claro el concepto de interface.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#interfaces-en-java","title":"Interfaces en Java","text":"<p>Para entender el funcionamiento de las colecciones en java hemos de tener claro el funcionamiento de los interfaces (ya que <code>Collection</code> es un interfaz que implementan todas las estructura de datos de java).</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#funcion-de-un-interfaz","title":"Funci\u00f3n de un interfaz","text":"<p>Un interfaz define total o parcialmente una serie de m\u00e9todos. Los m\u00e9todos son, conceptualmente, la forma en que podemos interactuar con un objeto. De este modo podemos decir que cada interfaz define una forma de interactuar con un objeto. El objeto implementa los m\u00e9todos necesarios para realizar dicha interacci\u00f3n.</p> <p>Estas interacciones en la pr\u00e1ctica se concretan en una funcionalidad. Es decir, los m\u00e9todos que se definen en el interfaz permiten que los objetos que lo implementen sean capaces de realizar una serie de operaciones.</p> <p>Por ejemplo, los objetos cuya clase implemente el interfaz iterable podr\u00e1n ser iterados empleando el bucle <code>for-each</code>. Los objetos cuya clase implemente el interfaz Comparable podr\u00e1n ser ordenados usando las funciones de ordenaci\u00f3n. etc.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#interfaces-y-clases-de-las-colecciones","title":"Interfaces y clases de las colecciones","text":"<p>La jerarqu\u00eda de interfaces y clases que veremos en este tema es el siguiente:</p> <p></p> <p>En primer lugar vemos que todos los elementos que vamos a ver son iterables ya que todos heredan de Collection y \u00e9ste a su vez de Iterable.</p> <p>List, Set y Queue son sub-interfaces de Collection as\u00ed que tendr\u00e1n todas las capacidades de una colecci\u00f3n y adem\u00e1s cada una de ellas a\u00f1adir\u00e1n cualidades propias (las listas tendr\u00e1n asignadas posiciones a sus elementos, etc.)</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#el-interfaz-iterable","title":"El interfaz <code>Iterable</code>","text":"<p>Este interfaz se utiliza para indicar que un objeto puede ser recorrido, o lo que es lo mismo, se puede iterar sobre \u00e9l. Las clases que implementan el interfaz <code>Iterable</code> han de implementar un m\u00e9todo (<code>iterator()</code>) que permita obtener un objeto <code>Iterator</code> que, a su vez, ha de permitir determinar si hemos llegado al final de la lista (<code>hasNext()</code>) y obtener un elemento de la lista y avanzar al siguiente (<code>next()</code>).</p> <p>El interfaz <code>Iterable</code> utiliza gen\u00e9ricos de modo que el iterador podr\u00e1 aplicarse sobre cualquier tipo de dato (clase) que deseemos.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#el-interfaz-iterator","title":"El interfaz <code>Iterator</code>","text":"<p>Como acabamos de ver el interfaz <code>Iterable</code> exige que se implemente un m\u00e9todo (<code>iterator()</code>) que devuelva un objeto <code>Iterator</code>. Este objeto <code>Iterator</code> es el que se encarga de recorrer la lista y de devolver los elementos de la misma.</p> <p>Al igual que el interfaz <code>Iterable</code>, el interfaz <code>Iterator</code> utiliza gen\u00e9ricos de modo que el iterador podr\u00e1 aplicarse sobre cualquier tipo de dato que deseemos. El tipo de dato que se utilice en el interfaz <code>Iterator</code> ha de ser el mismo que se utilice en el interfaz <code>Iterable</code>.</p> <p>Por \u00faltimo <code>Iterator</code> exige que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>hasNext()</code>: Devuelve <code>true</code> si quedan elementos por recorrer y <code>false</code> en caso contrario.</li> <li><code>next()</code>: Devuelve el siguiente elemento de la lista y avanza el iterador al siguiente elemento.</li> </ul> <p>De este modo podemos recorrer una lista usando un bucle while:</p> <pre><code>// Creemos primero un iterable como por ejemplo una lista de cadenas:\nLista&lt;String&gt; lista = new ArrayList&lt;String&gt;();\nlista.add(\"Hola\");\nlista.add(\"Mundo\");\nlista.add(\"!\");\n\n// Ahora podremos acceder a su iterador:\nIterator&lt;String&gt; iterador = lista.iterator();\n\n// Y recorrerla usando un bucle while:\nwhile (iterador.hasNext()) {\n    System.out.println(iterador.next());\n}\n\n// o usando un bucle for:\nfor (Iterator&lt;String&gt; iterador = lista.iterator(); iterador.hasNext(); ) {\n    System.out.println(iterador.next());\n}\n\n// o usando un bucle for-each (lo m\u00e1s sencillo en el caso de un iterable):\nfor (String elemento : lista) {\n    System.out.println(elemento);\n}\n</code></pre> <p>Puesto que el iterador estar\u00e1 muy ligado a la colecci\u00f3n que estamos recorriendo, es habitual que se implemente como una clase interna de la colecci\u00f3n.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.2%20-%20Collections/#el-interfaz-collection","title":"El interfaz <code>Collection</code>","text":"<p><code>Collection</code> hereda del interfaz <code>Iterable</code>. Esto implica que toda clase que implemente <code>Collection</code> tambi\u00e9n ha de implementar los m\u00e9todos que exige el interfaz <code>Iterable</code> (<code>iterator()</code>) y, a su vez, hemos de crear una clase que implemente el interfaz <code>Iterator</code> que funcione para nuestra colecci\u00f3n.</p> <p>Adem\u00e1s del m\u00e9todo anterior, <code>Collection</code>, tambi\u00e9n exige que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>size()</code>: Indicar\u00e1 el n\u00famero de elementos que contiene la colecci\u00f3n.</li> <li><code>isEmpty()</code>: Indicar\u00e1 si la colecci\u00f3n est\u00e1 o no vac\u00eda.</li> <li><code>contains(Object o)</code>: Permite determinar si el objeto <code>o</code> se encuentra dentro de la colecci\u00f3n.</li> <li><code>containsAll(Collection c)</code>: Determina si una colecci\u00f3n contiene todos los elementos de la colecci\u00f3n <code>c</code>. </li> <li><code>add(Object o)</code>: A\u00f1ade un elemento nuevo <code>o</code> a la colecci\u00f3n  (opcional).</li> <li><code>addAll(Collection c)</code>: Igual al anterior pero para una colecci\u00f3n de elementos  (opcional).</li> <li><code>remove(Object o)</code>: Elimina un objeto <code>o</code> de la colecci\u00f3n  (opcional).</li> <li><code>removeAll(Collection c)</code>: Igual al anterior pero para una colecci\u00f3n de elementos  (opcional).</li> <li><code>clear()</code>: Elimina todos los elementos de la colecci\u00f3n (opcional).</li> <li><code>retainAll(Collection c)</code>: Mantendr\u00e1 en la colecci\u00f3n \u00fanicamente los elementos que tambi\u00e9n se encuentran en la colecci\u00f3n <code>c</code> (intersecci\u00f3n)  (opcional).</li> <li><code>toArray()</code>: Devolver\u00e1 un array conteniendo todos los elementos e la colecci\u00f3n.</li> <li><code>toArray(T[] a)</code>:  Devolver\u00e1 un array conteniendo todos los elementos de la colecci\u00f3n; el tipo del array devuelto ha de ser el mismo del del array indicado <code>T</code>.</li> </ul> <p>En una colecci\u00f3n no hay posiciones. S\u00f3lo podremos a\u00f1adir o eliminar elementos pero no podremos ni insertar un valor en una posici\u00f3n ni obtener el contenido de una posici\u00f3n. Podr\u00edamos decir que una <code>Collection</code> es ignorante respecto a \u00edndice de sus elementos.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/","title":"Tema 7.3: Listas","text":""},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/#list","title":"<code>List</code>","text":"<p>El interfaz <code>List</code> indica que una colecci\u00f3n de elementos se encuentra agrupado en forma de lista (existe un orden en el almacenamiento). En una lista podremos acceder a cada elemento indicando su \u00edndice o posici\u00f3n dentro de la lista (empezando a contar en cero).</p> <p>A diferencia de un conjunto, una lista admite elementos duplicados.</p> <p>Adem\u00e1s de los m\u00e9todos requeridos por el interfaz <code>Collection</code>, el interfaz <code>List</code> requiere que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>T get(int index)</code>: Nos devolver\u00e1 el elemento (de tipo T :arrow_right: gen\u00e9ricos) que se encuentra en la posici\u00f3n <code>index</code> de la lista (la primera posici\u00f3n de la lista ser\u00e1 0).</li> <li><code>T set(int index, T element)</code>: Coloca el valor <code>element</code> en la posici\u00f3n <code>index</code> de la lista y devuelve el elemento que se encontraba antes en dicha posici\u00f3n.</li> <li><code>void add(int index, T element)</code>: A\u00f1ade o inserta el elemento <code>element</code> en la posici\u00f3n <code>index</code> de la lista.</li> <li><code>T remove(int index)</code>: Elimina el elemento que se encuentra en la posici\u00f3n <code>index</code> de la lista y lo devuelve como resultado.</li> <li><code>int indexOf(Object o)</code>: Devuelve la posici\u00f3n de la primera aparici\u00f3n del elemento <code>o</code> de la lista.</li> <li><code>int lastIndexOf(Object o)</code>: Devuelve la posici\u00f3n d</li> <li>e la \u00faltima aparici\u00f3n del elemento <code>o</code> en la lista.</li> <li><code>ListIterator&lt;T&gt; listIterator()</code>: Devuelve un tipo especial de iterador <code>ListIterator</code>.</li> <li><code>ListIterator&lt;T&gt; listIterator(int index)</code>: Devuelve un tipo especial de iterador <code>ListIterator</code> apuntando a la posici\u00f3n <code>index</code> de la lista.</li> <li><code>List&lt;T&gt; subList(int fromIndex, int toIndex)</code>: Devuelve una lista conteniendo los elementos desde la posici\u00f3n <code>fromIndex</code> (incluy\u00e9ndola) hasta la posici\u00f3n <code>toIndex</code> (excluy\u00e9ndola).</li> </ul>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/#arraylist","title":"<code>ArrayList</code>","text":"<p>La clase <code>ArrayList</code> implementa una lista de elementos que internamente se almacenan en un array. Esta clase es muy eficiente para acceder a sus elementos de ya que se puede acceder a ellos indicando su posici\u00f3n (\u00edndice) y no es necesario recorrer la lista para encontrarlos (pues estamos trabajando por debajo con un array).</p> <p>A diferencia de un array, el tama\u00f1o de un <code>ArrayList</code> puede crecer o decrecer din\u00e1micamente. Los elementos de un <code>ArrayList</code> pueden ser de cualquier tipo (gen\u00e9ricos).</p> <p>Puesto que un <code>ArrayList</code> guarda internamente los datos en un array tendr\u00e1 problemas cuando al crecer de tama\u00f1o. Si va creciendo llegar\u00e1 un momento en que se quede sin espacio en el array interno. Para poder almacenar m\u00e1s valores cuando ya est\u00e9 lleno se ver\u00e1 obligado a crear un array con m\u00e1s espacio libre y copiar los valores del array viejo al nuevo. Esta operaci\u00f3n llevar\u00e1 bastante tiempo.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<pre><code>ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();\n\nlista.add(\"Hola\");\nlista.add(\"Mundo\");\nlista.add(\"Cruel\");\nlista.add(\"!\");\n\n// Para mostrar el contenido de la lista podemos usar un bucle for-each:\nfor (String s : lista) {\n    System.out.println(s);\n}\n\n// O directamente el m\u00e9todo toString() de la lista:\nSystem.out.println(lista);\n\n// Podemos acceder a los elementos de la lista indicando su posici\u00f3n:\nfor (int i = 0; i &lt; lista.size(); i++) {\n    System.out.printf(\"Elemento n\u00famero %d: %s.%n\", i, lista.get(i));\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/#linkedlist","title":"<code>LinkedList</code>","text":"<p>El funcionamiento de una <code>LinkedList</code> es similar al de un <code>ArrayList</code> pero internamente no se almacenan los elementos en un array sino en una lista enlazada. Esto hace que la inserci\u00f3n y eliminaci\u00f3n de elementos sea m\u00e1s eficiente que en un <code>ArrayList</code> pero el acceso a un elemento concreto es, en general, m\u00e1s lento.</p> <p>Si necesitamos guardar una lista de datos que no va a cambiar mucho a lo largo del tiempo pero a la que vamos a acceder con frecuencia, es mejor usar un <code>ArrayList</code>. Si, por el contrario, vamos a modificar la lista con m\u00e1s frecuencia de la que vamos a acceder a ella es mejor usar un <code>LinkedList</code>.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.3%20-%20Listas/#arraylist-vs-linkedlist","title":"<code>ArrayList</code> vs <code>LinkedList</code>","text":"<p>Resumiendo, el acceso a una posici\u00f3n es instant\u00e1nea en un <code>ArrayList</code> pero depender\u00e1 de la posici\u00f3n en un <code>LinkedList</code>. La inserci\u00f3n y eliminaci\u00f3n de elementos es lenta (algunas veces habr\u00e1 que cambia rel tama\u00f1o) en un <code>ArrayList</code> pero instant\u00e1nea en un <code>LinkedList</code>.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.4%20-%20Colas/","title":"Tema 7.4: Colas, interfaz <code>Queue</code>","text":"<p>Las colas de Java funcionan como las colas en el mundo real. Los elementos se a\u00f1aden al final de la cola y se extraen del principio: primero en entrar, primero en salir (FIFO: First In, First Out).</p> <p>Las clases que implementen esta interfaz emular\u00e1n el comportamiento de una cola utilizando los siguientes m\u00e9todos:</p> <ul> <li><code>boolean add(E e)</code>: A\u00f1ade el elemento <code>e</code> al final de la cola. Devuelve <code>true</code> si se ha podido a\u00f1adir y lanzar\u00e1 una excepci\u00f3n <code>IllegalStateException</code> si no hay espacio disponible.</li> <li><code>boolean offer(E e)</code>: Inserta el elemento <code>e</code> al final de la cola. Devuelve <code>true</code> si se ha podido a\u00f1adir y <code>false</code> si no hay espacio disponible.</li> <li><code>E element()</code>: Devuelve el primer elemento de la cola. Lanzar\u00e1 una excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda. Sin eliminar el elemento de la cola.</li> <li><code>E peek()</code>: Devuelve el primer elemento de la cola. Devuelve <code>null</code> si la cola est\u00e1 vac\u00eda. Sin eliminar el elemento de la cola.</li> <li><code>E poll()</code>: Devuelve el primer elemento de la cola. Devuelve <code>null</code> si la cola est\u00e1 vac\u00eda. Eliminando el elemento de la cola.</li> <li><code>E remove()</code>: Devuelve el primer elemento de la cola. Lanzar\u00e1 una excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda. Eliminando el elemento de la cola.</li> </ul> <p>Como podemos ver hay dos m\u00e9todos para cada operaci\u00f3n, uno de ellos lanza una excepci\u00f3n si no se puede realizar la operaci\u00f3n y el otro devuelve un valor especial para indicar que no se ha podido realizar la operaci\u00f3n:</p> <ul> <li>Inserci\u00f3n de un elemento al final de la cola: <code>add</code> lanza una excepci\u00f3n (<code>IllegalStateException</code>) si no hay espacio libre (colas con l\u00edmite de tama\u00f1o) y <code>offer</code> devolver\u00e1 falso si no pudo insertar.</li> <li>Leer el elemento cabeza de la cola sin sacarlo: <code>element</code> lanza una excepci\u00f3n (<code>NoSuchElementoException</code>) si la cola est\u00e1 vac\u00eda y <code>peek</code> devuelve <code>null</code> si la cola est\u00e1 vac\u00eda.</li> <li>Extraer el elemento cabeza de la cola: <code>remove</code> lanza una excepci\u00f3n (<code>NoSuchElementException</code>) si la cola est\u00e1 vac\u00eda y <code>poll</code> devuelve <code>null</code> si la cola est\u00e1 vac\u00eda.</li> </ul>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.4%20-%20Colas/#priorityqueue","title":"<code>PriorityQueue</code>","text":"<p>La clase <code>PriorityQueue</code> implementa el interfaz <code>Queue</code>. Adem\u00e1s los elementos de la cola se ordenan seg\u00fan su prioridad, que se define mediante un objeto <code>Comparator</code> que se pasa al constructor de la cola. Si no se pasa ning\u00fan <code>Comparator</code> se usar\u00e1 el orden natural de los elementos.</p> <p>Esto no significa que los elementos se ordenen autom\u00e1ticamente cuando se a\u00f1aden a la cola. Los elementos se obtendr\u00e1n ordenados cuando se extraigan de la cola.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.4%20-%20Colas/#comparadores","title":"Comparadores","text":"<p>Un comparador ser\u00e1 un objeto que implemente la interfaz <code>Comparator</code>. \u00c9sta exige que se implemente el m\u00e9todo <code>compare</code> que recibe dos objetos y devuelve un entero que indica si el primer objeto es menor (menor que 0), igual (0) o mayor que el segundo (mayor que 0).</p> <pre><code>public class ComparadorInverso implements Comparator&lt;Integer&gt; {\n    @Override\n    public int compare(Integer i1, Integer i2) {\n        return i2 - i1;\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main() {\n        PriorityQueue&lt;Integer&gt; cola = new PriorityQueue&lt;&gt;(new ComparadorInverso());\n        cola.add(1);\n        cola.add(2);\n        cola.add(3);\n        cola.add(4);\n        cola.add(5);\n        cola.add(6);\n        cola.add(7);\n        cola.add(8);\n        cola.add(9);\n        cola.add(10);\n        while (!cola.isEmpty()) {\n            System.out.println(cola.poll());\n        }\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.4%20-%20Colas/#interfaz-comparator","title":"Interfaz <code>Comparator</code>","text":"<p>Este interfaz le concede a un objeto la capacidad de establecer un orden sobre un tipo de objetos. Para ello, el objeto debe implementar el m\u00e9todo <code>compare</code> que recibe dos objetos del tipo que se quiere ordenar y devuelve un entero que indica si el primer objeto es menor (menor que 0), igual (0) o mayor que el segundo (mayor que 0).</p> <pre><code>// Si queremos establecer una cola de prioridad para personas en las que se priorice la edad de menor a mayor:\npublic class MiComparador implements Comparator&lt;Persona&gt; {\n    @Override\n    public int compare(Persona p1, Persona p2) {\n        return p1.getEdad() - p2.getEdad();\n    }\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.5%20-%20Conjuntos/","title":"Tema 7.5: Conjuntos","text":"<p>L</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.5%20-%20Conjuntos/#interfaz-set","title":"Interfaz <code>Set</code>","text":"<p>Los conjuntos de Java funcionan como los conjuntos en matem\u00e1ticas. Los elementos que contiene son \u00fanicos y no se pueden repetir. Adem\u00e1s, no tienen un orden determinado.</p> <p>Las clases que implementen esta interfaz emular\u00e1n el comportamiento de un conjunto utilizando los siguientes m\u00e9todos:</p> <ul> <li><code>boolean add(E e)</code>: A\u00f1ade el elemento <code>e</code> al conjunto. Devuelve <code>true</code> si se ha podido a\u00f1adir y <code>false</code> si el elemento ya estaba en el conjunto.</li> <li></li> </ul>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.5%20-%20Conjuntos/#hashset","title":"<code>HashSet</code>","text":""},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.5%20-%20Conjuntos/#treeset","title":"<code>TreeSet</code>","text":""},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/","title":"Tema 7.5: Mapas","text":"<p>Los mapas son estructuras de datos de Java que almacenan dos valores por cada entrada. Un de los valores funcionar\u00e1 como una clave a partir de la cual se podr\u00e1 obtener el valor con el que est\u00e1 emparejado. As\u00ed, diremos que un mapa se compone de pares clave - valor.</p> <p>En un mapa nunca podr\u00e1n existir dos claves iguales.</p> <p>Los mapas, al igual que todas las dem\u00e1s estructuras de datos (salvo los arrays) son gen\u00e9ricos, por lo que habr\u00e1 que indicar el tipo tanto de la clave como del valor.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#definicion-de-un-mapa","title":"Definici\u00f3n de un mapa","text":"<p>La sintaxis para definir un mapa es la siguiente:</p> <pre><code>Map&lt;String, Alumno&gt; mapaAlumnos = new HashMap&lt;&gt;();\n</code></pre> <p>Para instar elementos en el mapa deberemos de usar el m\u00e9todo <code>put</code> pas\u00e1ndole el par clave - valor:</p> <pre><code>mapaAlumnos.put(\"primero\", new Alumno(\"\u00c1ngel\", \"32124F\", \"16-07-2005\"));\n</code></pre> <p>Y para extraer elementos (en nuestro ejemplo de tipo <code>Alumno</code>) usaremos <code>get</code> pas\u00e1ndolo la clave.</p> <pre><code>Alumno alumno = mapaAlumnos.get(\"primero\");\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#tipos-de-mapas","title":"Tipos de mapas","text":"<p>En Java existen tres tipos de mapas ya implementados:</p> <ul> <li><code>HashMap</code></li> <li><code>TreeMap</code></li> <li><code>LinkedHashMap</code></li> </ul> <p>Las diferencias existentes entre ellos son respecto a c\u00f3mo almacenan los datos internamente y, como consecuencia de ello, la velocidad con que se pueden realizar las operaciones de inserci\u00f3n y extracci\u00f3n de datos.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#hashmap","title":"<code>HashMap</code>","text":"<p>Almacena los elementos en una tabla hash y es el m\u00e1s r\u00e1pido. Como consecuencia de su m\u00e9todo de almacenamiento no se puede saber a priori con qu\u00e9 orden se iterar\u00eda sobre los datos. Es decir, un <code>HashMap</code> no garantiza ning\u00fan orden en sus elementos cuando es recorrido.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#treemap","title":"<code>TreeMap</code>","text":"<p>Un <code>TreeMap</code> emplea una estructura de \u00e1rbol binario. Esto permite que el <code>TreeMap</code> ofrezca una complejidad logar\u00edtmica (log(n)) bastante eficiente para las operaciones <code>containsKey</code>, <code>get</code>, <code>put</code> and <code>remove</code>.</p> <p>Los elementos se encontrar\u00e1n ordenados con respecto a la clave. Se le puede pasar un <code>Comparator</code> para establecer un orden respecto a la clave.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#linkedhashmap","title":"<code>LinkedHashMap</code>","text":"<p>Un <code>LinkedHashMap</code> almacena los datos de la misma forma que un <code>HashMap</code> pero guarda adem\u00e1s informaci\u00f3n sobre el orden en que fueron insertados. De este modo, al iterar sobre un <code>LinkedHashMap</code> \u00e9ste se recorrer\u00e1 en el orden en que fueron introducidas sus entradas. Es decir, un <code>LinkedHashMap</code> garantiza que sus elementos se recorrer\u00e1n en el orden en que fueron insertados.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#como-recorrer-un-mapa","title":"Como recorrer un mapa","text":"<p>Existen varias formas de recorrer un mapa dependiendo de la funci\u00f3n que usemos para obtener su contenido en forma de <code>Iterable</code>:</p> <ul> <li><code>entrySet()</code>: Nos devolver\u00e1 el contenido de un mapa en forma de un conjunto de las entradas (pares clave - valor) del mapa.</li> <li><code>keySet()</code>: Nos devolver\u00e1 a su vez un conjunto con las claves del mapa.</li> <li><code>values()</code>: De manera similar a las anteriores, nos devolver\u00e1 un conjunto con los valores del mapa.</li> </ul>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#bucle-for-mejorado","title":"Bucle <code>for</code> mejorado","text":"<p>Este bucle podremos utilizarlo tanto con <code>entrySet()</code>:</p> <pre><code>for (Entry&lt;String, Alumno&gt; entrada : mapa.entrySet()) {\n    System.out.println(entrada.getKey() + \" -&gt; \" + entrada.getValue());\n}\n</code></pre> <p>como con <code>keySet()</code>:</p> <pre><code>for (String clave : mapa.keySet()) {\n    System.out.println(clave + \" -&gt; \" + mapa.get(clave));\n}\n</code></pre> <p>o directamente con <code>values()</code>:</p> <pre><code>for (Alumno valor : mapa.values()) {\n    System.out.println(valor);\n}\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.6%20-%20Mapas/#metodo-foreach","title":"M\u00e9todo <code>forEach()</code>","text":"<p>Los mapas, as\u00ed como todas las clases que implementan <code>Collection</code>, disponen de un m\u00e9todo denominado <code>forEach()</code>. Este m\u00e9todo acepta una funci\u00f3n lambda con dos par\u00e1metros como entrada. El primer par\u00e1metro de la lambda ser\u00e1 la clave y el segundo su valor asociado. Esta funci\u00f3n lambda se aplicar\u00e1 a cada entrada del mapa.</p> <pre><code>mapa.forEach((k, v) -&gt; System.out.println(k + \" -&gt; \" + v));\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/","title":"Tema 7.7: EXTRA El tiempo, The_Times, en Java: <code>Date</code>, <code>Calendar</code> y <code>java.time</code>","text":"<p>En todos los lenguajes de programaci\u00f3n existe la necesidad de almacenar valores que representen el tiempo. Es necesario saber, por ejemplo, cuando fue la \u00faltima vez que se accedi\u00f3 o modific\u00f3 un fichero, en qu\u00e9 fecha se realiz\u00f3 la \u00faltima actualizaci\u00f3n o en qu\u00e9 momento se estableci\u00f3 una conexi\u00f3n con un servidor.</p> <p>La tarea de llevar cuenta de en que momento se produjo un evento se complica a\u00fan m\u00e1s cuando tenemos que tener en cuenta los distintos usos horarios. A\u00fan m\u00e1s si tenemos que tener en cuenta que distintas  culturas (como China, Jap\u00f3n) tienen distintos calendarios.</p> <p>Java intenta resolver este problema mediante las clases <code>Date</code> y <code>Calendar</code>.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#date","title":"<code>Date</code>","text":"<p>Este es el sistema antiguo y pr\u00e1cticamente obsoleto de almacenar fechas y horas.</p> <p>En Java (al igual que otros muchos lenguajes) se mide el tiempo contando los milisegundos (segundos, microsegundos o nanosegundos en otros sistemas) que han transcurrido desde el a\u00f1o cero de la inform\u00e1tica o tiempo de Unix (oo:oo:oo del 1 de enero de 1970).</p> <p>Para crear un objeto <code>Date</code> escribiremos el siguiente c\u00f3digo:</p> <pre><code>Date d = new Date();\n</code></pre> <p>de esta forma creamos el objeto <code>d</code> con la fecha y hora del instante en que se haya ejecutado la sentencia.</p> <p>Si queremos obtener el n\u00famero de milisegundos desde el 1 de enero de 1970 almacenado en <code>d</code> simplemente tendremos que mostrar:</p> <pre><code>System.out.println(\"Milisegundos desde el origen de tiempo: \" + d.getTime());\n</code></pre> <p>Pero para obtener el d\u00eda, mes y a\u00f1o lo tenemos complicado...</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#calendar-al-rescate","title":"<code>Calendar</code> al rescate","text":"<p>Trabajar con <code>Date</code> para obtener los valores del a\u00f1o, d\u00eda del mes, de la semana, etc. es bastante complicado. Para facilitar el trabajo se cre\u00f3 la clase <code>Calendar</code>. <code>Calendar</code> es una actualizaci\u00f3n <code>Date</code> pero que no lo substituye. Funciona en tandem con <code>Date</code>.</p> <p>Por ejemplo, para crear un <code>Calendar</code> que represente la fecha y hora actual escribiremos:</p> <pre><code>Calendar c = Calendar.getInstance();\n</code></pre> <p>Si queremos obtener a\u00f1o, mes y d\u00eda de un objeto <code>Date</code>:</p> <pre><code>Date d = new Date();\nCalendar c = Calendar.getInstance();\nc.setTime(d);\nint year = c.get(Calendar.YEAR);\nint month = c.get(Calendar.MONTH);\n/...\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#paquete-javatime","title":"Paquete <code>java.time</code>","text":"<p>En cualquier caso parece que <code>Calendar</code> no fue una soluci\u00f3n definitiva si no m\u00e1s bien un parche y finalmente se desarroll\u00f3 el paquete <code>java.time</code> con las clases <code>LocalDate</code> y  <code>LocalDateTime</code> para facilitar el tratamiento del tiempo.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#localdate","title":"<code>LocalDate</code>","text":"<p>Para almacenar el momento actual usaremos el m\u00e9todo <code>now()</code>:</p> <pre><code>LocalDate hoy = LocalDate.now();\n</code></pre> <p>Y para obtener a\u00f1o, mes y d\u00eda:</p> <pre><code>int a\u00f1o = hoy.getYear();\nint mes = hoy.getMonth();\nint diaMes = hoy.getDayOfMonth();\nint diaSemana = hoy.getDayOfWeek();\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#localdatetime","title":"<code>LocalDateTime</code>","text":"<p>Almacena dos valores:</p> <ul> <li>El numero de segundos transcurridos desde la medianoche del 1 de enero de 1970.</li> <li>El n\u00famero de nanosegundos transcurridos dentro del segundo en que nos encontramos.</li> </ul>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#formato-de-las-fechas","title":"Formato de las fechas","text":"<p>Para dar formato a las fechas se usar\u00e1 la clase <code>DateTimeFormatter</code>:</p> <pre><code>LocalDateTime ahora = LocalDateTime.now();\nDateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;\nString ahoraString = ahora.format(formatter);\n\nSystem.out.println(\"La fecha de hoy es: \" + ahoraString);\n</code></pre> <p>Tambi\u00e9n podremos crear un formateador a nuestra medida usando patrones:</p> <pre><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy hh:mm:ss\");\nString ahoraString = ahora.format(formatter);\n\nSystem.out.println(\"La fecha de hoy es: \" + ahoraString);\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#formatos-predefinidos","title":"Formatos predefinidos","text":"Formatter Description Example ofLocalizedDate(dateStyle) Formatter with date style from the locale '2011-12-03' ofLocalizedTime(timeStyle) Formatter with time style from the locale '10:15:30' ofLocalizedDateTime(dateTimeStyle) Formatter with a style for date and time from the locale '3 Jun 2008 11:05:30' ofLocalizedDateTime(dateStyle,timeStyle) Formatter with date and time styles from the locale '3 Jun 2008 11:05' BASIC_ISO_DATE Basic ISO date '20111203' ISO_LOCAL_DATE ISO Local Date '2011-12-03' ISO_OFFSET_DATE ISO Date with offset '2011-12-03+01:00' ISO_DATE ISO Date with or without offset '2011-12-03+01:00'; '2011-12-03' ISO_LOCAL_TIME Time without offset '10:15:30' ISO_OFFSET_TIME Time with offset '10:15:30+01:00' ISO_TIME Time with or without offset '10:15:30+01:00'; '10:15:30' ISO_LOCAL_DATE_TIME ISO Local Date and Time '2011-12-03T10:15:30' ISO_OFFSET_DATE_TIME Date Time with Offset 2011-12-03T10:15:30+01:00' ISO_ZONED_DATE_TIME Zoned Date Time '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_DATE_TIME Date and time with ZoneId '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_ORDINAL_DATE Year and day of year '2012-337' ISO_WEEK_DATE Year and Week '2012-W48-6' ISO_INSTANT Date and Time of an Instant '2011-12-03T10:15:30Z' RFC_1123_DATE_TIME RFC 1123 / RFC 822 'Tue, 3 Jun 2008 11:05:30 GMT'"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.7%20-%20EXTRA%20-%20El%20tiempo/#formatos-construidos","title":"Formatos construidos","text":"<p>Los s\u00edmbolos para construir formatos son (entre otros):</p> S\u00edmbolo Significado Representaci\u00f3n Ejemplo G era texto AD; Anno Domini; A u a\u00f1o a\u00f1o 2004; 04 y a\u00f1o de la era a\u00f1o 2004; 04 D d\u00eda del a\u00f1o n\u00famero 189 M/L mes del a\u00f1o n\u00famero / texto 7; 07; Jul; July; J d d\u00eda del mes n\u00famero 10 E d\u00eda de la semana texto Tue; Tuesday; T a am-pm texto PM h hora 1-12 n\u00famero 12 k hora formato 1-24 n\u00famerop 15 <pre><code>  Symbol  Meaning                     Presentation      Examples\n  ------  -------                     ------------      -------\n   G       era                         text              AD; Anno Domini; A\n   u       year                        year              2004; 04\n   y       year-of-era                 year              2004; 04\n   D       day-of-year                 number            189\n   M/L     month-of-year               number/text       7; 07; Jul; July; J\n   d       day-of-month                number            10\n\n   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter\n   Y       week-based-year             year              1996; 96\n   w       week-of-week-based-year     number            27\n   W       week-of-month               number            4\n   E       day-of-week                 text              Tue; Tuesday; T\n   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T\n   F       week-of-month               number            3\n\n   a       am-pm-of-day                text              PM\n   h       clock-hour-of-am-pm (1-12)  number            12\n   K       hour-of-am-pm (0-11)        number            0\n   k       clock-hour-of-am-pm (1-24)  number            0\n\n   H       hour-of-day (0-23)          number            0\n   m       minute-of-hour              number            30\n   s       second-of-minute            number            55\n   S       fraction-of-second          fraction          978\n   A       milli-of-day                number            1234\n   n       nano-of-second              number            987654321\n   N       nano-of-day                 number            1234000000\n</code></pre>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.8%20-%20EXTRA%20-%20Lambdas/","title":"Tema 7.8 - Extra: Lambdas en Java","text":"<p>Las lambda (equivalentes a m\u00e9todos en Java) son funciones que se pueden pasar directamente como par\u00e1metro a un m\u00e9todo.</p> <p>Para poder utilizar una lambda (o expresi\u00f3n lambda) como par\u00e1metro hemos de declarar el argumento del m\u00e9todo como un interfaz que s\u00f3lo tenga un m\u00e9todo requerido.</p> <p>As\u00ed, podr\u00edamos decir que el mecanismo de uso de las lambda consta de tres partes:</p> <ul> <li>El interfaz que define c\u00f3mo ha de ser la lambda.</li> <li>El m\u00e9todo que acepta como par\u00e1metro una variable del tipo del interfaz.</li> <li>Y la expresi\u00f3n lambda propiamente dicha.</li> </ul> <p>Ve\u00e1moslo con un ejemplo:</p> <p>Imaginemos que tenemos una clase <code>Alumno</code> y deseamos ordenar objetos de dicha clase. Existe una interfaz en Java que nos permite definir formas de comparar objetos <code>Comparator</code>. Esta interfaz s\u00f3lo define como obligatorio el m\u00e9todo <code>compare</code> que admite dos argumentos.</p> <p>Si creamos un par de m\u00e9todos para obtener el primero y \u00faltimo alumno de una lista seg\u00fan alg\u00fan criterio podr\u00edamos hacer lo siguiente:</p> <pre><code>public static Alumno primero(List&lt;Alumno&gt; l, Comparator&lt;Alumno&gt; c) {\n    Alumno m = l.get(0);\n\n    for (Alumno a : l) {\n        if (c.compare(a, m) &lt; 0) {\n            m = a;\n        }\n    }\n\n    return m\n}\n\npublic static Alumno ultimo(List&lt;Alumno&gt; l, Comparator&lt;Alumno&gt; c) {\n    Alumno m = l.get(0);\n\n    for (Alumno a : l) {\n        if (c.compare(a, m) &gt; 0) {\n            m = a;\n        }\n    }\n\n    return m\n}\n</code></pre> <p>Dependiendo del comparador que le pasemos a los m\u00e9todos <code>primero</code> y <code>ultimo</code> devolver\u00e1n el alumno con menor (mayor) edad, menor (mayor) nota, etc.</p> <p>En lugar de crear una clase que implemente <code>Comparator</code> y a continuaci\u00f3n crear una instancia de la misma y pas\u00e1rsela al m\u00e9todo <code>menor</code>, lo que podremos hacer es pasar una expresi\u00f3n lambda:</p> <pre><code>// Para obtener el alumno con menor edad:\nAlumno menor = primero(alumnos, (a1, a2) -&gt; a1.edad() - a2.edad());\n\n// Para obtener el alumno con mejor nota:\nAlumno mejor = ultimo(alumnos, (a1, a2) -&gt; a1.nota() - a2.nota());\n</code></pre> <p>Si a1 tiene menor edad (nota) que a2 el resultado ser\u00e1 negativo (lo que indica que a1 es menor que a2). Si el resultado es cero significa que la edad de a1 y la de a2 son la misma y si el resultado es positivo significar\u00e1 que la edad (nota) de a2 ser\u00e1 mayor que la de a1.</p>"},{"location":"Tema%2007%20-%20Estructuras%20de%20datos/Tema%207.8%20-%20EXTRA%20-%20Lambdas/#asignar-lambdas-a-variables","title":"Asignar lambdas a variables","text":"<p>Es posible asignar expresiones lambda a variable si las declaramos usando la interfaz <code>Function</code>:</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; suma = (x, y) -&gt; x + y;\n</code></pre> <p>De esta forma asignamos una funci\u00f3n lambda a una variable. Si a continuaci\u00f3n queremos invocar dicha funci\u00f3n a partir de la variable hemos de llamar al m\u00e9todo <code>apply</code>:</p> <pre><code>int x = 10;\nint y = 20;\nint z = suma.apply(x, y);\nSystem.out.printf(\"z = %d.%n\", z); // Mostrar\u00e1 el valor 30 por consola.\n</code></pre> <p>Para funciones que s\u00f3lo admiten un par\u00e1metros podremos usar el interfaz <code>Function</code> que es gen\u00e9rico y requiere que indiquemos el tipo de la entrada y la salida:</p> <pre><code>Function&lt;String, Integer&gt; intToStr = i -&gt; Integer.parseInt(i);\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/","title":"Tema 8: Entrada y salida a ficheros","text":""},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escribir-texto-a-un-fichero","title":"Escribir texto a un fichero","text":"<p>Para escribir datos en un fichero lo primero que hemos de crear es un objeto de la clase <code>FileWriter</code>:</p> <pre><code>FileWriter fb = new FileWriter(\"fichero.txt\");\n</code></pre> <p>Ahora, para escribir en este objeto, que hace referencia a un fichero, hemos de usar un <code>BufferedWriter</code>. Un <code>BufferedWriter</code> ser\u00e1 un objeto que puede escribir en muchos sitios distintos por lo que hemos de indicarle que ba a trabajar sobre nuestro fichero:</p> <pre><code>FileWriter file = new FileWriter(\"fichero.txt\");\n\nBufferedWriter writer = new BufferedWriter(file);\n</code></pre> <p>A continuaci\u00f3n hemos de invocar al m\u00e9todo <code>write</code> del <code>BufferedWriter</code>:</p> <pre><code>FileWriter file = new FileWriter(\"fichero.txt\");\n\nBufferedWriter writer = new BufferedWriter(file);\n\nwriter.write(\"Hola mundo cruel\");\n</code></pre> <p>Finalmente, y ya que se traga de un buffer ((para m\u00e1s informaci\u00f3n sobre buffers)) hemos de cerrar  <code>BufferedWriter</code> para que los datos escritos, almacenados temporalmente en el buffer se pasen al archivo en disco.</p> <p>Pero si intentas escribir este c\u00f3digo en un IDE se mostrar\u00e1 un error: <code>Unhandled exception type IOException</code>. Esto se debe a que la creaci\u00f3n de un <code>FileWriter</code> puede lanzar una excepci\u00f3n de entrada salida (<code>IOException</code>).</p> <p>Para solventar este error podremos o bien indicar que el m\u00e9todo donde nos encontramos puede lanzar esta excepci\u00f3n (y pasar la patata caliente a otro):</p> <pre><code>public void miMetodo(String nombreFichero, String texto) throws IOException {\n    FileWriter file = new FileWriter(nombreFichero);\n\n    BufferedWriter writer = new BufferedWriter(file);\n\n    writer.write(texto);\n}\n</code></pre> <p>O bien rodear el c\u00f3digo con una estructura try-catch:</p> <pre><code>public void miMetodo(String fichero, String texto) {\n\n    try {\n        FileWriter file = new FileWriter(fichero);\n\n        BufferedWriter writer = new BufferedWriter(file);\n\n        writer.write(texto);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre> <p>Puesto que cuando creamos nuestro fichero para escribir no indicamos una ruta completa el fichero se crear\u00e1 en el directorio ra\u00edz de nuestro proyecto.</p> <p>Una cosa que no hemos de olvidar es que estos objetos est\u00e1n asociados a un recurso del sistema (el fichero que hemos abierto para escritura). De modo que este recurso estar\u00e1 ocupado mientras no indiquemos lo contrario. Para evitar que el recurso est\u00e9 ocupado indefinidamente hemos de liberarlo usando el m\u00e9todo <code>close()</code> cuando hayamos terminado de trabajar con \u00e9l. Adem\u00e1s, en este caso concreto, no se escribir\u00e1 nada en el fichero hasta que cerremos el recurso asociado:</p> <pre><code>public void miMetodo(String fichero, String texto) {\n\n    try {\n        FileWriter file = new FileWriter(fichero);\n\n        BufferedWriter writer = new BufferedWriter(file);\n\n        writer.write(texto);\n\n        writer.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#leer-texto-de-un-fichero","title":"Leer texto de un fichero","text":"<p>El proceso de lectura de un fichero es muy similar al de escritura.</p> <p>Primero hemos de crear un <code>BufferedReader</code> asociado al fichero que queremos leer:</p> <pre><code>public String leeFichero(String nombreFichero) {\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(nombreFichero));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre> <p>Para leer una l\u00ednea del fichero llamaremos al m\u00e9todo <code>readLine()</code> del objeto <code>BufferedReader</code>. Este m\u00e9todo devolver\u00e1 la siguiente linea del fichero o <code>null</code> si ya se ha llegado al final y no hay nada que leer:</p> <pre><code>public String leeFichero(String nombreFichero) {\n    String lineaLeida = null;\n    String textoLeido = null;\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(nombreFichero));\n\n        do {\n            lineaLeida = reader.readLine();\n            if (lineaLeida != null) textoSalida += lineaLeida + \"\\n\";\n\n        } while (lineaLeida != null);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return textoLeido;\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#sentencia-try-con-recursos","title":"Sentencia Try-con-recursos","text":"<p>Para evitar tener que cerrar expl\u00edcitamente los recursos que abrimos podemos usar una variante de try-catch pero de la siguiente forma:</p> <pre><code>try (FileReader fr = new FileReader(fileName); BufferedWriter writer = new BufferedWriter(fr)) {\n    // C\u00f3digo que utiliza el writer.\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>Esta sentencia asegura que tanto el <code>FileReader</code> como el <code>BufferedWriter</code> se cerrar\u00e1n cuando salgamos del bloque de c\u00f3digo d\u00f3nde se usan.</p> <p>Esto previene tanto que nos olvidemos de liberar un recurso como que la instrucci\u00f3n <code>close()</code> quedase sin ejecutarse en caso de que el programa fallase antes.</p>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#anadir-texto-a-un-fichero","title":"A\u00f1adir texto a un fichero","text":"<p>Si ejecutamos el c\u00f3digo de escritura de la secci\u00f3n anterior podremos comprobar que se sobrescribe el contenido del fichero. Si queremos a\u00f1adir texto sin sobrescribir hemos de usar un constructor distinto de <code>FileWriter</code>:</p> <pre><code>try (FileWriter fr = new FileWriter(fileName, true); BufferedWriter writer = new BufferedWriter(fr)) {\n    // Ahora a\u00f1adimos texto al fichero.\n    writer.write(txt);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>El constructor <code>FileWriter(String fileName, boolean append)</code> abrir\u00e1 el fichero para a\u00f1adir contenido si <code>append</code> es <code>true</code>.</p>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escritura-de-datos-bytes","title":"Escritura de datos / bytes","text":"<p>Lo que hemos visto hasta ahora fueron formas de escribir texto a ficheros. Es posible que en lugar de texto lo que necesitemos es leer o escribir datos en binario (como ser\u00eda el caso de un fichero de imagen, v\u00eddeo o audio). Para leer y escribir binario a un fichero hemos de utilizar los objetos <code>FileInputStream</code> y <code>FileOutputStream</code> respectivamente.</p>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escritura-binaria-a-un-fichero","title":"Escritura binaria a un fichero","text":"<p>Para crear un <code>FileOutputStream</code> hemos de indicar el nombre del fichero (la ruta en realidad) y a\u00f1adir <code>true</code> si queremos indicar que deseamos a\u00f1adir datos al fichero en lugar de sobrescribirlo.</p> <pre><code>// Sobrescribir el fichero:\nOutputStream out = new FileOutputStream(fileName);\n</code></pre> <pre><code>// A\u00f1adir datos al fichero:\nOutputStream out = new FileOutputStream(fileName, true);\n</code></pre> <p>Para escribir datos podremos usar distintos m\u00e9todos pero el m\u00e1s sencillo ser\u00e1 <code>write</code> al que le pasaremos tres argumentos:</p> <ol> <li>El array de bytes que deseamos escribir.</li> <li>El n\u00famero de bytes del array que deseamos saltarnos (en nuestro caso 0).</li> <li>El n\u00famero de bytes del array que deseamos escribir (en nuestro caso la longitud del array).</li> </ol> <pre><code>// Creamos un array de bytes:\nbyte[] data = new byte[4092]; // Capacidad para 4 KiB de datos por ejemplo.\n\n// C\u00f3digo donde meter\u00edamos los datos en el array.\n// Supongamos que 128 bytes.\nint bytesStored = 128;\n\nOutputStream out = new FileOutputStream(fileName);\n\n// data es un byte[].\nout.write(data, 0, bytesStored);\n</code></pre> <p>Un <code>OutputStream</code> es un recurso que ha de ser cerrado despu\u00e9s de su uso por lo que deber\u00edamos usar <code>try</code>:</p> <pre><code>public void writeBinaryDataToFile(String fileName, byte[] data) {\n    try (OutputStream out = new FileOutputStream(fileName)) {\n        out.write(data, 0, data.length);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#lectura-binaria-de-un-fichero","title":"Lectura binaria de un fichero","text":"<p>Este caso es muy similar al anterior pero hemos de indicar cuantos bytes vamos a intentar leer. Como ahora especificamos cu\u00e1nto leer podr\u00edamos encontrarnos con tres casos:</p> <ul> <li>Disponer de los bytes que dese\u00e1bamos leer.</li> <li>Que quede menos que leer que lo que hemos indicado.</li> <li>No tener nada que leer (fichero vaci\u00f3).</li> </ul> <p>Por este motivo el m\u00e9todo <code>read</code> de <code>InputStream</code> puede devolver dos valores:</p> <ul> <li><code>-1</code>: en caso de que no haya podido leer (ya hab\u00edamos alcanzado fin de fichero, fichero est\u00e1 vac\u00edo, etc.).</li> <li>Un valor entero: El n\u00famero de bytes le\u00eddos.</li> </ul> <p>Por lo tanto si deseamos leer el contenido total de un fichero a memoria usaremos el m\u00e9todo <code>readAllBytes</code> pero hemos de tener en cuenta que es posible que el fichero no quepa en memoria.</p> <pre><code>public byte[] readAllFromFile(Sting fileName) {\n    byte[] fileData = null;\n    try (InputStream input = new FileInputStream(fileName)) {\n        fileData = input.readAllBytes();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return fileData;\n}\n</code></pre> <p>Para leer el fichero en bloques de un tama\u00f1o determinado mientras haya algo que leer escribir\u00edamos:</p> <pre><code>public static final int BUFFER_SIZE = 4096; // 4 KiB.\n\n// m\u00e1s c\u00f3digo...\n\nbyte[] buffer = new byte[BUFFER_SIZE];\n\n// ...\n\nwhile ((bytesRead = input.read(buffer, 0, BUFFER_SIZE)) != -1) {\n    // Hacer cosas con los datos le\u00eddos, bytesRead bytes guardados en buffer.\n}\n</code></pre> <p>Explicaci\u00f3n:</p> <p>Cuando escribimos la instrucci\u00f3n <code>bytesRead = input.read(buffer, 0, BUFFER_SIZE)</code> entre par\u00e9ntesis lo que pasa el lo siguiente:</p> <ol> <li>Se intenta realizar la lectura invocando el m\u00e9todo <code>read(...)</code>.</li> <li>Se asigna el resultado de <code>read(...)</code> (-1 o el n\u00famero de bytes le\u00eddos) a la variable <code>bytesRead</code>.</li> <li>Se retorna el valor asignado.</li> </ol> <p>En el siguiente ejemplo:</p> <pre><code>int x, y, z;\nx = 10;\ny = 20;\n\nif ((z = x + y) &lt; 100) {\n    System.out.printf(\"%d + %d &lt; 100.%n\", x, y);\n} else {\n    System.out.printf(\"%d + %d &gt;= 100.%n\", x, y);\n}\nSystem.out.printf(\"%d + %d = d.%n\", x, y, z);\n</code></pre> <p>El valor de la suma de x y y (30) se asignar\u00e1 a z y a continuaci\u00f3n se comparar\u00e1 dicho valor con 100.</p>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/","title":"Tema 8.1: Serializables","text":""},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/#objetos-pojo-plain-old-java-object","title":"Objetos P.O.J.O. (Plain Old Java Object)","text":"<p>Un POJO es cualquier clase definida en Java que cumpla estas tres condiciones:</p> <ol> <li>No puede extender ninguna otra clase.</li> <li>No puede implementar ning\u00fan interfaz.</li> <li>No puede usar anotaciones externas.</li> </ol> <p>Veamos un ejemplo:</p> <p>La siguiente clase ser\u00e1 un POJO.</p> <pre><code>public class Gato {\n    String nombre;\n    LocalDate fechaNacimiento;\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/#objetos-javabean","title":"Objetos JavaBean","text":"<p>Un objeto JavaBean debe cumplir las siguientes condiciones:</p> <ol> <li>Ha de disponer de un constructor sin argumentos.</li> <li>Todas sus propiedades han de ser privadas.</li> <li>Tendr\u00e1 getters y setters p\u00fablicos.</li> <li>Ser\u00e1 serializable.</li> </ol> <p>Veamos un ejemplo:</p> <p>Convirtamos la clase <code>Gato</code> a un JavaBean:</p> <pre><code>public class Gato implements Serializable {\n    private String nombre;\n    private LocalDate fechaNacimiento;\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return fechaNacimiento\n    }\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/#serializable","title":"Serializable","text":"<p>Que una clase sea serializable quiere decir que dicha clase se puede escribir y leer de una base de datos o un fichero.</p> <p>Para que una clase sera serializable ha de implementar el interfaz <code>Serializable</code>.</p> <pre><code>public class Alumno implements Serializable {\n    // ...\n}\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/#guardar-objetos-en-ficheros","title":"Guardar objetos en ficheros","text":"<p>Los objetos serializables pueden ser escritos en ficheros y, obviamente, recuperados ley\u00e9ndolos del fichero.</p>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.1%20-%20Serializables/#escritura-de-objeto-a-fichero","title":"Escritura de objeto a fichero","text":"<p>Para escribir un objeto a un fichero hemos de utilizar un <code>ObjectOutputStream</code>. Esto objeto necesitar\u00e1 a su vez que le pasemos alg\u00fan lugar a d\u00f3nde enviar el objeto. En el caso de escritura a un fichero usaremos un <code>FileOutputStream</code>.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>Gato gatito = new Gato();\ngatito.setNombre(\"Michi\");\ngatito.setFechaNacimiento(new LocalDate())\n</code></pre>"},{"location":"Tema%2008%20-%20Ficheros/Tema%20-%208.2%20-%20Acceso%20al%20sistema%20de%20ficheros/","title":"Tema 8.2: Acceso al sistema de ficheros","text":"<p>TODO: Ver el contenido de un directorio, trabajar con _path_s, etc.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.0%20-%20Introduccion%20a%20C-Sharp/","title":"Tema 9.0: Introducci\u00f3n a C Sharp","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.0%20-%20Introduccion%20a%20C-Sharp/#instalacion-de-visual-studio","title":"Instalaci\u00f3n de Visual Studio","text":"<p>Existen varias opciones para instalar Visual Studio y tambi\u00e9n varias versiones del mismo. Para nosotros ser\u00e1 suficiente Visual Studio Community.</p> <p>Como opci\u00f3n de instalaci\u00f3n realizaremos una offline ya que as\u00ed evitaremos tener que descargar Visual Studio y los componentes necesarios para cada instalaci\u00f3n.</p> <p>Los pasos a seguir para realizar esta instalaci\u00f3n (Visual Studio Community + Herramientas de desarrollo en C# para consola) son los siguientes:</p> <ol> <li>Descargar el bootstrapper para Visual Studio Community vs_community.exe</li> <li>Apuntar los identificador de los componentes que deseemos instalar (listados en esta p\u00e1gina). En nuestro caso ser\u00e1 suficiente con: .Net desktop development con ID <code>Microsoft.VisualStudio.Workload.ManagedDesktop</code>.</li> <li>Seleccionar el directorio donde descargaremos los archivos de Visual Studio Community y sus componentes mediante la opci\u00f3n <code>--layout c:\\mi_dir_VSC</code>.</li> <li>Hemos de indicar tambi\u00e9n el lenguaje que deseemos <code>--lang es-ES</code> por ejemplo (lenguajes v\u00e1lidos aqu\u00ed).</li> <li>Finalmente es importante indicar que instale los componentes opcionales con <code>--includeOptional</code></li> </ol> <p>As\u00ed, par instalar la versi\u00f3n Community de Visual Studio con el componente para desarrollo .NET en consola (incluir\u00e1 los lenguajes C#, Visual Basic, and F#) hemos de ejecutar el siguiente comando (en el directorio donde hayamos descargado <code>vs_community.exe</code>):</p> <pre><code>vs_community.exe --offline --layout D:\\VS_Community_Offline --add Microsoft.VisualStudio.Workload.ManagedDesktop --includeOptional --lang es-ES\n</code></pre> <p>Una vez finalice de descargar los ficheros entraremos en el directorio elegido (<code>D:\\VS_Community_Offline</code> en el ejemplo) y ejecutaremos el comando:</p> <pre><code>vs_community.exe --noweb --add Microsoft.VisualStudio.Workload.ManagedDesktop --includeOptional\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.0%20-%20Introduccion%20a%20C-Sharp/#que-es-c-sharp","title":"\u00bfQu\u00e9 es C Sharp?","text":"<p>Este lenguaje de programaci\u00f3n fue dise\u00f1ado en el a\u00f1o 2000 por Anders Hejlsberg (Microsoft). Se trata de un lenguaje de alto nivel y prop\u00f3sito general con soporte para m\u00faltiples paradigmas de programaci\u00f3n como: tipado est\u00e1tico, tipado fuerte, \u00e1mbito l\u00e9xico, imperativo, declarativo, funcional, gen\u00e9rico, orientado a objetos (basado en clases) y orientado a componentes.</p> <p>El est\u00e1ndar ECMA lista como objetivos de dise\u00f1o para C# los siguientes: (copiado de la Wikipedia)</p> <ul> <li>Su intenci\u00f3n es ser un lenguaje de programaci\u00f3n simple, moderno, de prop\u00f3sito general y orientado a objetos.</li> <li>El lenguaje deber\u00e1 de incluir comprobaci\u00f3n de tipado fuerte, comprobaci\u00f3n de los l\u00edmites de los array, detectar el uso de variables no inicilizadas y recolecci\u00f3n de basura autom\u00e1tica.</li> <li>La robustez del software, durabilidad y la productividad del programador ser\u00e1n aspectos importantes.</li> <li>El lenguaje est\u00e1 pensado para desarrollo de componentes software en entornos distribuidos.</li> <li>La portabilidad es muy importante para el c\u00f3digo fuente y los programadores, especialmente los familiarizados con C y C++.</li> <li>El soporte para internacionalizaci\u00f3n es muy importante.</li> <li>Aunque la intenci\u00f3n es que las aplicaciones escritas en C# sean econ\u00f3micas en cuanto al uso de memoria y CPU, el lenguaje no ha sido dise\u00f1ado para competir directamente en rendimiento y tama\u00f1o con C o ensamblador.</li> </ul>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.0%20-%20Introduccion%20a%20C-Sharp/#la-sintaxis-de-c-sharp","title":"La sintaxis de C Sharp","text":"<p>Los elementos fundamentales de la sintaxis de C#  es similar a la de otros lenguajes estilo C como C, C++ y Java:</p> <ul> <li>Se usan <code>;</code> para indicar el fin de una instrucci\u00f3n.</li> <li>Las <code>{}</code> se usan para agrupar instrucciones.</li> <li>Las instrucciones se agrupan generalmente en m\u00e9todos (funciones), los m\u00e9todos en clases y las clases en namespaces (paquetes).</li> <li>Los valores se asignan a variables mediante el s\u00edmbolo <code>=</code> y se comparan con <code>==</code>.</li> <li>Los <code>[]</code> se usan con arrays, tanto para declararlos como para acceder a sus posiciones.</li> <li>...</li> </ul>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/","title":"Tema 9.1: Elementos b\u00e1sicos de C Sharp","text":"<p>En este tema veremos los elementos b\u00e1sicos del lenguaje: variables, operadores y estructuras de control.</p> <p>Haremos esto mediante comparaciones con el lenguaje Java siempre que sea posible.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#creacion-y-ejecucion-de-una-aplicacion","title":"Creaci\u00f3n y ejecuci\u00f3n de una aplicaci\u00f3n","text":"<p>Veremos antes como crear, ejecutar y compilar una aplicaci\u00f3n de C#.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#creacion-de-un-proyecto","title":"Creaci\u00f3n de un proyecto","text":"<p>Para crear un proyecto o aplicaci\u00f3n C# ha de usarse la aplicaci\u00f3n <code>dotnet</code> con la opci\u00f3n <code>new</code> y alguna de las plantillas disponibles. Para ver un listado de todas las plantillas se puede usar el comando <code>dotnet new list</code>.</p> <p>Para crear una aplicaci\u00f3n b\u00e1sica de consola usaremos el comando <code>dotnet new console</code>.</p> <p>Tambi\u00e9n es interesante usar la opci\u00f3n <code>-o</code> para indicar el directorio dentro del que queremos crear nuestra aplicaci\u00f3n. Si no se indica se realizar\u00e1 en el directorio actual.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#ejecucion-de-un-proyecto","title":"Ejecuci\u00f3n de un proyecto","text":"<p>Para ejecutar la aplicaci\u00f3n C# se usar\u00e1 la opci\u00f3n <code>run</code> del comando <code>dotnet</code> dentro del directorio de la aplicaci\u00f3n:</p> <pre><code>dotnet run\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#compilacion-del-proyecto","title":"Compilaci\u00f3n del proyecto","text":"<p>A diferencia de Java en C# se puede generar un archivo ejecutable (<code>.exe</code>) a partir del c\u00f3digo fuente de la aplicaci\u00f3n.</p> <p>Para ello usaremos el comando <code>dotnet build</code>. Este comando compilar\u00e1 el c\u00f3digo fuente de la aplicaci\u00f3n y dar\u00e1 como resultado un archivo ejecutable Windows (<code>.exe</code>).</p> <p>El resultado de la compilaci\u00f3n se guardar\u00e1 en el directorio <code>bin</code> (binarios) del proyecto.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operadores","title":"Operadores","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operadores-clasicos","title":"Operadores cl\u00e1sicos","text":"<p>Entiendo por operadores cl\u00e1sicos los aritm\u00e9ticos, de comparaci\u00f3n, l\u00f3gicos y de asignaci\u00f3n. As\u00ed como tambi\u00e9n los operadores a nivel de bits y los de autoincremento y autodecremento.</p> <p>No aprecio diferencia en los operadores cl\u00e1sicos respecto a Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operadores-nuevos","title":"Operadores nuevos","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operador-de-nulidad","title":"Operador de nulidad <code>?</code>","text":"<p>El operador de nulidad <code>?</code> se usa para permitir que un tipo primitivo pueda tomar el valor nulo.</p> <pre><code>int? a = null;\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operador-as","title":"Operador <code>as</code>","text":"<p>Operador as que se usa para hacer un cast de un tipo a otro.</p> <p>La siguiente expresi\u00f3n:</p> <pre><code>double? b = a as double;\n</code></pre> <p>Asignar\u00e1 el valor <code>double</code> de <code>a</code> a <code>b</code> si <code>a</code> es de tipo compatible con un cast a <code>double</code> o <code>null</code> si no lo es.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operador-is","title":"Operador <code>is</code>","text":"<p>Operador <code>is</code> que se usa para comprobar si un objeto es de un tipo determinado o no y si es as\u00ed, se puede hacer un cast.</p> <pre><code>Object a = 5;\n\n// Se mostrar\u00e1 el mensaje si a es un entero positivo.\nif (a is int x &amp;&amp; x &gt; 0) Console.WriteLine(\"Es un entero positivo\");\n</code></pre> <p>El operador <code>is</code> tambi\u00e9n puede hacer otras cosas como se puede ver en la p\u00e1gina de documentaci\u00f3n de Microsoft.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#sobrecarga-de-operadores","title":"Sobrecarga de operadores","text":"<p>Otra caracter\u00edstica de C# es la posibilidad de sobrecargar los operadores. Esto es, definir el comportamiento de los operadores para un tipo de dato determinado.</p> <p>Para ello se usan los m\u00e9todos <code>operator</code> y se definen los operadores que se quieren sobrecargar.</p> <pre><code>public class Punto\n{\n    public int x, y;\n\n    public Punto(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static Punto operator +(Punto p1, Punto p2)\n    {\n        return new Punto(p1.x + p2.x, p1.y + p2.y);\n    }\n\n    public static bool operator ==(Punto p1, Punto p2) \n    {\n        return p1.x == p2.x &amp;&amp; p1.y == p2.y;\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.2%20-%20Variables/","title":"Tema 9.2: Variables","text":"<p>Las principales diferencias entre las variables de C# y Java es que en el primero las variables primitivas podr\u00e1n pasarse por valor o por referencia. La segunda diferencia es que en lugar de disponer de tipos envoltorio, como Java, para trabajar con variables sencillas (los tipos primitivos de Java) se utiliza un nuevo tipo de datos <code>struct</code> para realizar una funci\u00f3n similar. Los tipos primitivos de C# ser\u00e1n todos <code>struct</code>s, una especie de clases limitadas con valores y m\u00e9todos.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.2%20-%20Variables/#situacion-en-java","title":"Situaci\u00f3n en Java","text":"<p>En Java tenemos dos tipos de datos o variables: variables primitivas (int, short, long, double, float, boolean, byte y char) y clases.</p> <p>Los tipos primitivos son variables que se pasan por valor. Esto quiere decir que cuando le pasamos una variable int como argumento a un m\u00e9todo, este no puede modificarla. Ve\u00e1moslo con un ejemplo:</p> <pre><code>public class Main {\n    public static void metodoValor(int x, int y, int z) {\n        z = x + y;\n        System.out.printf(\"(m\u00e9todo:) x = %d, y = %d. y z = %d.%n\", x, y, z);\n    }\n\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 10;\n        int z = 0;\n\n        System.out.printf(\"x = %d, y = %d y z = %d.%n\", x, y, z);\n\n        metodoValor(x, y, z);\n\n        System.out.printf(\"x = %d, y = %d y z = %d.%n\", x, y, z);\n    }\n}\n</code></pre> <p>La ejecuci\u00f3n del c\u00f3digo anterior devolver\u00e1 la siguiente salida:</p> <pre><code>x = 5, y = 10 y z = 0.\n(m\u00e9todo:) x = 5, y = 10. y z = 15.\nx = 5, y = 10 y z = 0.\n</code></pre> <p>Como podemos observar la variable <code>z</code> toma el valor de la suma dentro del m\u00e9todo pero su valor en el exterior no se ve modificado.</p> <p>Esto se debe a que las variables que se pasan por valor \u00fanicamente transmiten una copia de su valor al m\u00e9todo y no una referencia a la variable.</p> <p>Una variable de tipo array es, por el contrario una variables que se pasa por referencia. Esto es, se pasa la referencia a la variable y puede ser alterada:</p> <pre><code>import java.util.Arrays;\n\npublic class Main {\n\n    public static void metodoReferencia(int[] arr) {\n        arr[0] = 0;\n        arr[1] = 0;\n        arr[2] = 0;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3};\n\n        System.out.printf(\"Antes: s = %s.%n\", Arrays.toString(arr));\n\n        metodoReferencia(arr);\n\n        System.out.printf(\"Despu\u00e9s: s = %s.%n\", Arrays.toString(arr));\n    }\n}\n</code></pre> <p>La salida de la ejecuci\u00f3n de este c\u00f3digo es:</p> <pre><code>s = [1, 2, 3].\ns = [0, 0, 0].\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.2%20-%20Variables/#situacion-en-c-sharp","title":"Situaci\u00f3n en C Sharp","text":"<p>Las variables en C# pueden ser tambi\u00e9n por valor y por referencia. Las variables tipo <code>struct</code> en C# son por defecto por valor (similares a los tipos primitivos de Java) mientras que las clases son, igual que en Java, por referencia.</p> <p>Pero las <code>struct</code> no son tan b\u00e1sicas como los tipos primitivos si no que se acercan m\u00e1s a las clases. Las <code>struct</code> almacenan valores y m\u00e9todos al igual que las clases. Pueden definirse como clases muy sencillas con un comportamiento especial.</p> <p>Tambi\u00e9n, a diferencia de Java, en C# podremos crear nuestras propias <code>struct</code>s.</p> <p>Ejemplos de <code>struct</code> predefinidas del lenguaje son: shot, int, long, float, double, decimal, bool, char.</p> <p>Si se las pasamos a un m\u00e9todo como argumentos tendremos el mismo comportamiento que en Java:</p> <pre><code>static void metodoValor(int x, int y, int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\nint z = 0;\n\nmetodoValor(x, y, z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre> <p>La ejecuci\u00f3n de este c\u00f3digo dar\u00e1 como resultado:</p> <pre><code>En el m\u00e9todo: x = 5, y = 10 y z = 15\nFuera del m\u00e9todo: x = 5, y = 10 y z = 0\n</code></pre> <p>En C#, a diferencia de Java, existe la opci\u00f3n de pasar estas variables por referencia como veremos en le siguiente apartado.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.2%20-%20Variables/#variables-por-referencia","title":"Variables por referencia","text":"<p>Para pasar las variable primitivas por referencia hemos de usar las palabras reservadas <code>ref</code> o <code>out</code>. Veamos un ejemplo:</p> <pre><code>static void metodoReferencia(int x, int y, ref int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\nint z = 0;\n\nmetodoReferencia(x, y, ref z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre> <p>Ahora la salida del programa ser\u00e1:</p> <pre><code>En el m\u00e9todo: x = 5, y = 10 y z = 15\nFuera del m\u00e9todo: x = 5, y = 10 y z = 15\n</code></pre> <p>La otra opci\u00f3n con <code>out</code> se similar. Con esta opci\u00f3n no se exige que se le de un valor inicial a la variable que guardar\u00e1 la salida:</p> <pre><code>static void metodoReferencia(int x, int y, out int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\n\nmetodoReferencia(x, y, out int z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/","title":"Tema 9.3: Estructuras de control","text":"<p>Las estructuras de control son similares a las de Java con diferencias menores.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#if-else","title":"<code>if-else</code>","text":"<p>Esta estructura no tiene ninguna diferencia en funcionamiento o sintaxis a Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#switch","title":"<code>switch</code>","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#for","title":"<code>for</code>","text":"<p>Esta estructura presenta alguna diferencia. En la secci\u00f3n inicial y final se pueden incluir m\u00e1s instrucciones de las de inicializaci\u00f3n e incremento:</p> <pre><code>int i, j; // Importante declaraci\u00f3n externa.\nfor (System.Console.WriteLine(\"Secci\u00f3n de inicializaci\u00f3n.\"), i = 0, j = 10; i &lt; j; ++i, --j, System.Console.WriteLine($\"Secci\u00f3n de incremento i = {i} y j = {j}.\")) {\n    System.Console.WriteLine($\"Dentro del bucle iteraci\u00f3n {i}.\");\n}\n</code></pre> <pre><code>Secci\u00f3n de inicializaci\u00f3n.\nDentro del bucle iteraci\u00f3n 0.\nSecci\u00f3n de incremento i = 1 y j = 9.\nDentro del bucle iteraci\u00f3n 1.\nSecci\u00f3n de incremento i = 2 y j = 8.\nDentro del bucle iteraci\u00f3n 2.\nSecci\u00f3n de incremento i = 3 y j = 7.\nDentro del bucle iteraci\u00f3n 3.\nSecci\u00f3n de incremento i = 4 y j = 6.\nDentro del bucle iteraci\u00f3n 4.\nSecci\u00f3n de incremento i = 5 y j = 5.\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#for-each","title":"<code>for-each</code>","text":"<p>Las diferencias en el bucle <code>for-each</code> son tambi\u00e9n (al menos externamente) muy peque\u00f1as:</p> <pre><code>List&lt;int&gt; listInt = new List&lt;int&gt;();\nint i = 0;\nforeach(int e in listInit)\n{\n    Console.WriteLn($\"elemento {++i}: {e}.\");\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#while","title":"<code>while</code>","text":"<p>De nuevo, el bucle <code>while</code> es similar al de java:</p> <pre><code>while(i &lt; 100)\n{\n    // Instrucciones a repetir.\n    ++i;\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.3%20-%20Estructuras%20de%20control/#do-while","title":"<code>do-while</code>","text":"<pre><code>do \n{\n    // Instrucciones a repetir.\n    ++i;\n\n} while(i &lt; 100)\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/","title":"Tema 9.4: Clases","text":"<p>Las clases en C# cumplen la misma funci\u00f3n que en Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#declaracion-de-una-clase","title":"Declaraci\u00f3n de una clase","text":"<pre><code>class MiClase\n{\n\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#variables-de-clase-e-instancia","title":"Variables de clase e instancia","text":"<p>Las variables de clase e instancia se declaran igual que en Java con dos salvedades: las constantes y las variables de solo lectura.</p> <pre><code>public class Persona\n{\n    private static int num_personas = 0; // Variable de clase.\n    private DateTime fecha_nacimiento; // Variable de instancia.\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#constantes","title":"Constantes","text":"<p>Si en Java declar\u00e1bamos una constante de la siguiente forma:</p> <pre><code>public class Clase {\n    public static final int VALOR = 123;\n}\n</code></pre> <p>en C# tendremos que usar la palabra reservada <code>constant</code> que substituir\u00eda a <code>public final</code> pues se considera que todas las constantes son autom\u00e1ticamente est\u00e1ticas.</p> <pre><code>public class Clase\n{\n    public const int VALOR = 123;\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#readonly","title":"Readonly","text":"<p>Si no conocemos el valor de nuestra constante antes de ejecutar el c\u00f3digo pero no vamos a permitir cambiarla una vez asignada usaremos la palabra reservada <code>readonly</code>.</p> <p>Lo que en Java ser\u00eda:</p> <pre><code>public static final int[] VALORES = {1, 2, 3};\n</code></pre> <p>En C# ser\u00e1:</p> <pre><code>public static readonly int[] VALORES = {1, 2, 3};\n</code></pre> <p>NOTA: Aunque no podamos cambiar la asignaci\u00f3n de <code>VALORES</code> al array en memoria siempre podremos cambiar su contenido <code>VALORES[0] = 10</code>.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#propiedades","title":"Propiedades","text":"<p>Las propiedades son un mecanismo para acceder al estado de un objeto. Las propiedades pueden almacenar un valor (como una variable p\u00fablica), pueden limitar la modificaci\u00f3n o la lectura (incluyendo s\u00f3lo <code>get</code> o <code>set</code> como veremos m\u00e1s adelante) o pueden no hacer referencia a un valor concreto si no que se obtengan como combinaci\u00f3n de varios.</p> <p>Supongamos que tenemos una clase caja con largo, alto, ancho y volumen.</p> <pre><code>public class Caja\n{\n    public float largo;\n    public float alto;\n    public float ancho;\n    public float volumen;\n\n    public override string ToString()\n    {\n        return $\"Largo: {largo}\\nAlto: {alto}\\nAncho: {ancho}\\n\\tVolumen: {volumen}\";\n    }\n}\n</code></pre> <p>Esta implementaci\u00f3n presenta cierta inseguridad porque se podr\u00edan modificar dichos valores eliminando la consistencia.</p> <p>Es posible que deseemos que la longitud de la caja sea fija. O que no se pueda modificar una vez establecida. O simplemente evitar que se establezcan valores negativos.</p> <p>Para ello comenzaremos por hacer las variables privadas (no olvidemos a\u00f1adir <code>_</code> al comienzo de las variables como buena pr\u00e1ctica):</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n    private float _volumen;\n\n      public override string ToString()\n    {\n        return $\"Largo: {_largo}\\nAlto: {_alto}\\nAncho: {_ancho}\\n\\tVolumen: {_volumen}\";\n    }\n}\n</code></pre> <p>Para poder acceder a las mismas crearemos las propiedades que sean necesarias.</p> <p>Para crear una propiedad escribiremos un modificador de acceso (o ninguno si queremos usar el por defecto <code>internal</code>) seguido del tipo de dato de la propiedad (<code>float</code> en nuestro caso) y a continuaci\u00f3n el nombre de la propiedad (usando pascal case). A continuaci\u00f3n abrimos un bloque de c\u00f3digo (<code>{ }</code>) y dentro del mismo tendremos la opci\u00f3n de incluir dos secciones <code>get</code> y <code>set</code> de las que podremos omitir una dependiendo de nuestras necesidades.</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n    private float _volumen;\n\n    public float Largo {\n        get \n        {\n            return _largo;\n        }\n\n        set \n        {\n            _largo = value;\n        }\n    }\n\n    // Y as\u00ed para las dem\u00e1s propiedades.\n\n      public override string ToString()\n    {\n        return $\"Largo: {Largo}\\nAlto: {Alto}\\nAncho: {Ancho}\\n\\tVolumen: {Volumen}\";\n    }\n\n}\n</code></pre> <p>El par\u00e1metro <code>value</code> que usamos dentro del <code>set</code> se establece por defecto y se le asignar\u00e1 el valor que escribamos despu\u00e9s del <code>=</code> cuando queramos asignarle un valor a nuestra propiedad:</p> <pre><code>Caja miCaja = new Caja();\n\nmiCaja.Largo = 10.5f;\n\n// Dentro del bloque set, value valdr\u00e1 10.5f.\n</code></pre> <p>Ahora podremos controlar que s\u00f3lo se le asignen valores positivos a nuestra propiedad:</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n    private float _volumen;\n\n    public float Largo {\n        get \n        {\n            return _largo;\n        }\n\n        set \n        {\n            if (value &lt;= 0)\n            {\n                throw new Exception(\"La longitud ha de ser mayor que 0.\");\n            }\n            _largo = value;\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>Con respecto a la variable volumen, puesto que su valor se obtiene a partir de las dem\u00e1s, no tiene sentido almacenarla. Podremos crear una propiedad que la calcule a partir de los valores de largo, alto y ancho de la caja:</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n    private float _volumen;\n\n    // ...\n\n    public float Volumen {\n        get {\n            _volume  = _largo * _alto * _ancho;\n            return _volumen;\n        }\n\n        set {\n            _volumen = value;\n        }\n    }\n}\n</code></pre> <p>Pero el c\u00f3digo anterior no tiene mucho sentido ya que:</p> <ul> <li>No tiene sentido usar la variable <code>_volumen</code> pues habr\u00eda que recalcularla cada vez que se acceda a ella pues largo, alto o ancho podr\u00edan haber variado.</li> <li>No tiene sentido que se pueda asignar el volumen directamente pues \u00e9ste depende de las dimensiones de la caja.</li> </ul> <p>As\u00ed que podr\u00edamos eliminar <code>_volumen</code> y el bloque <code>set</code> convirtiendo a <code>Volumen</code> en una propiedad calculada de solo lectura\u00a8:</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n\n    // ...\n\n    public float Volumen {\n        get {\n            return _largo * _alto * _ancho;\n        }\n    }\n}\n</code></pre> <p>Si le queremos a\u00f1adir la propiedad nombre a nuestra caja pero sin ning\u00fan c\u00f3digo especial que lo limite no tendremos porque crear una variable privada interna ni c\u00f3digo para los bloques <code>get</code> y <code>set</code>:</p> <pre><code>public class Caja\n{\n    private float _largo;\n    private float _alto;\n    private float _ancho;\n    private float _volumen;\n\n    public string Nombre { get; set; }\n\n    // ...\n}\n</code></pre> <p>Se recomienda el uso de propiedades frente a variables p\u00fablicas por dos motivos.</p> <ul> <li>El primero es que m\u00e1s adelante se podr\u00e1 modificar el funcionamiento de su <code>get</code> y <code>set</code> para, por ejemplo, a\u00f1adir validaci\u00f3n.</li> <li>En segundo lugar, usando siempre propiedades se aumenta la consistencia y legibilidad del c\u00f3digo.</li> </ul>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#metodos","title":"M\u00e9todos","text":"<p>Para declarar un m\u00e9todo en una clase lo haremos, de nuevo, de una forma similar a Java:</p> <pre><code>class MiClase\n{\n    private Map&lt;int, string&gt; contenido;\n\n    public void Guarda(int clave, string valor) \n    {\n        contenido.\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#constructor","title":"Constructor","text":"<p>El constructor es id\u00e9ntico y funciona de la misma forma que en Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#destructor","title":"Destructor","text":"<p>Tambi\u00e9n dispondremos de un m\u00e9todo que ha de ser \u00fanico y no admite argumentos que se invocar\u00e1 cuando se destruya (por el Recolector de basura o al fin del programa) nuestra clase.</p> <p>Su sintaxis ser\u00e1 la siguiente:</p> <pre><code>clase MiClase\n{\n    // ... \n\n    ~MiClase\n    {\n        // C\u00f3digo a ejecutar cuando destruyamos la clase.\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Las sobrecarga de m\u00e9todos es similar a la de Java. Consiste en crear varios m\u00e9todos con el mismo nombre pero distinto n\u00famero o tipo de argumentos:</p> <pre><code>class MiClase\n{\n    public void MetodoSobrecargado() \n    {\n        // ...\n    }\n\n    public void MetodoSobrecargado(int x, int y)\n    {\n        // ...\n    }\n\n    public void MetodoSobrecargado(float x, float y)\n    {\n        // ...\n\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#metodos-co-numero-variable-de-argumentos","title":"M\u00e9todos co n\u00famero variable de argumentos","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#solucion-en-java","title":"Soluci\u00f3n en Java","text":"<p>Para indicar que un m\u00e9todo acepta un numero variable de argumentos en Java hemos de indicarlo en la declaraci\u00f3n del m\u00e9todo poniendo primero el tipo del par\u00e1metro (como siempre) seguido de <code>...</code> y el nombre del par\u00e1metro.</p> <pre><code>public class Main{\n\n    public static int varArgsMethod(int... integers) {\n        int total = 0;\n\n        for (int i : integers) {\n            total += i;\n        }\n\n        return total;\n    }\n\n    public static void main(String[] args) {\n\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#solucion-en-c-sharp","title":"Soluci\u00f3n en C Sharp","text":"<p>Para declarar un m\u00e9todo con un n\u00famero variable de argumentos en C# hemos de usar la palabra clase <code>params</code> seguido de la declaraci\u00f3n del array que contendr\u00e1 los argumentos que deseemos que admita el m\u00e9todo:</p> <pre><code>class MiClase\n{\n    public static int Total(params int[] valores) \n    {\n        int total = 0;\n\n        foreach (int v in valores)\n        {\n            total += valor;\n        }\n\n        return total;\n    }\n}\n</code></pre> <p>Nota: Antes del par\u00e1metro que acepta m\u00faltiples argumentos podremos indicar otros par\u00e1metros. Pero el que acepte varios ha de ser siempre el \u00faltimo y solo puede haber uno.</p> <pre><code> public static int TotalMultiplicado(int multiplicador, params int[] valores) \n {\n    int total = 0;\n\n    foreach (int v in valores)\n    {\n        total += valor;\n    }\n\n    return multiplicador * total;\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#sobrescritura-override-de-metodos","title":"Sobrescritura (<code>override</code>) de m\u00e9todos","text":"<p>Si queremos cambiar el comportamiento de un m\u00e9todo que heredamos de una superclase hemos de usar la palabra clave <code>override</code>:</p> <pre><code>public class Mascota\n{\n    string Tipo { get; set; }\n    string Nombre { get; set; }\n    string Edad {\n        //...\n    }\n\n    // ...\n\n    public override string ToString() {\n        return $\"Soy un {Tipo} de {Edad} a\u00f1os y me llamo {Nombre}.\";\n    }\n}\n\n// ...\nMascota mascota = new Mascota(\"Perro\", \"Churri\", \"2018\");\n\nConsole.WriteLine(mascota);\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#herencia","title":"Herencia","text":"<p>En C# as\u00ed como en Java tendremos que una clase puede heredar de una \u00fanica clase padre o superclase. Convirti\u00e9ndose la heredera en subclase de su superclase.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>Los modificadores de acceso son palabras clave que se usan para especificar la accesibilidad declarada de un miembro o un tipo (clase). En esta secci\u00f3n se presentan los cinco modificadores de acceso:</p> <ul> <li>public</li> <li>protected</li> <li>internal</li> <li>private</li> <li>file</li> </ul> <p>Pueden especificarse los siguientes siete niveles de accesibilidad con los modificadores de acceso:</p> <ul> <li><code>public</code>: el acceso no est\u00e1 restringido.</li> <li><code>protected</code>: el acceso est\u00e1 limitado a la clase contenedora o a los tipos derivados de la clase contenedora.</li> <li><code>internal</code>: el acceso est\u00e1 limitado al ensamblado actual.</li> <li><code>protected internal</code>: El acceso est\u00e1 limitado al ensamblado actual o a los tipos derivados de la clase contenedora.</li> <li><code>private</code>: el acceso est\u00e1 limitado al tipo contenedor.</li> <li><code>private protected</code>: El acceso est\u00e1 limitado a la clase contenedora o a los tipos derivados de la clase contenedora que hay en el ensamblado actual.</li> <li><code>file</code>: el tipo declarado solo es visible en el archivo de origen actual. Los tipos con \u00e1mbito de archivo se usan generalmente para los generadores de origen.</li> </ul> <p>A continuaci\u00f3n veremos los modificadores con un poco m\u00e1s de detalle.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-private","title":"Modificador <code>private</code>","text":"<p>\u00c9ste es el modificador de acceso m\u00e1s restrictivo. Los miembros de una clase (variables, atributos, m\u00e9todos, etc.) declarados como <code>private</code> s\u00f3lo son accesibles desde dentro de la clase donde fueron declarados.</p> <p>Cuando marcamos una clase como <code>private</code> ninguna clase podr\u00e1 heredar de la misma.</p> <p>Nota: Las variables declaradas como <code>private</code> se nombran por convenio empezando por <code>_</code>.</p> <pre><code>public class BankAccount\n{\n    private int _balance;\n    public int GetBalance()\n    {\n        return _balance;\n    }\n    public void Deposit(int amount)\n    {\n        _balance += amount;\n    }\n    public void Withdraw(int amount)\n    {\n        if (_balance - amount &gt;= 0)\n        {\n            _balance -= amount;\n        }\n    }\n}\n</code></pre> <p>El modificador de acceso <code>private</code> se usa cuando un miembro de la clase est\u00e1 dise\u00f1ado \u00fanicamente para uso interno y no debe ser accesible desde otras partes del programa. De este modo se nos permite ocultar los detalles de implementaci\u00f3n de una clase y proteger a sus miembros de accesos o modificaciones involuntarias.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-public","title":"Modificador <code>public</code>","text":"<p>\u00c9ste modificador es el m\u00e1s permisivo. Los miembros declarados con este modificador podr\u00e1n ser accedidos desde cualquier otra parte del c\u00f3digo.</p> <p>Si declaramos una clase como <code>public</code> cualquier otra clase podr\u00e1 heredar de ella.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-protected","title":"Modificador <code>protected</code>","text":"<p>El modificador <code>protected</code> implica que el objeto ser\u00e1 accesible dentro de la clase donde se declar\u00f3 y en todas las clases derivada de ella.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-internal","title":"Modificador <code>internal</code>","text":"<p>Con <code>internal</code> especificamos que un objeto s\u00f3lo ser\u00e1 accesible dentro de su mismo ensamblado.</p> <p>Los miembros declarados como <code>internal</code> no ser\u00e1n accesibles desde fuera del ensamblado (proyecto).</p> <p>Este es el modificador que se aplica por defecto cuando no se indica ning\u00fan otro para la clase o sus miembros.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#que-es-un-ensamblado","title":"\u00bfQue es un ensamblado?","text":"<p>Un ensamblado es una colecci\u00f3n de tipos y recursos compilados para funcionar en conjunto y formar una unidad l\u00f3gica de funcionalidad. Los ensamblados adoptan la forma de un archivo ejecutable (<code>.exe</code>) o de biblioteca de v\u00ednculos din\u00e1micos ( <code>.dll</code>), y son los bloques de creaci\u00f3n de las aplicaciones.</p> <p>Com\u00fanmente podemos identificar los ensamblados con los proyecto que creamos en Visual Studio.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-protected-internal","title":"Modificador <code>protected internal</code>","text":"<p>Esta combinaci\u00f3n hace que el miembro sea accesible dentro de su propio ensamblado (proyecto) y adem\u00e1s en las clases derivadas de su clase (aunque est\u00e9n en otros ensamblados).</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.4%20-%20Clases/#modificador-private-protected","title":"Modificador <code>private protected</code>","text":"<p>Al igual que en el caso anterior se combinan (suman) los niveles de acceso del modificador <code>private</code> y del modificador <code>protected</code>. Esto hace que el elemento al que se aplique la combinaci\u00f3n s\u00f3lo podr\u00e1 ser accesible desde la propia clase (<code>private</code>) y tambi\u00e9n desde las clases derivadas (subclases) pero solo dentro del mismo ensamblado.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.5%20-%20Comentarios/","title":"Tema 9.5: Comentarios","text":"<p>Para comentar c\u00f3digo en C# se emplean dos tipos de comentarios:</p> <ul> <li>Comentarios de una l\u00ednea que empiezan con <code>//</code> y terminan al final de la l\u00ednea.</li> <li>Comentarios de m\u00faltiples l\u00edneas que empiezan con <code>/*</code> y terminan con <code>*/</code>.</li> </ul>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.5%20-%20Comentarios/#comentarios-de-documentacion","title":"Comentarios de documentaci\u00f3n","text":"<p>Los comentarios de documentaci\u00f3n son comentarios que se emplean para documentar el c\u00f3digo. Estos comentarios utilizar\u00e1n ciertas etiquetas en formato XML para informar sobre, por ejemplo, el funcionamiento de los m\u00e9todos. Finalmente se podr\u00e1 generar la documentaci\u00f3n autom\u00e1ticamente a partir de los comentario de documentaci\u00f3n utilizando alguna de las herramientas desarrolladas para ese fin como DocFX.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.5%20-%20Comentarios/#comentarios-de-documentacion-de-una-linea","title":"Comentarios de documentaci\u00f3n de una l\u00ednea","text":"<p>Los comentarios de documentaci\u00f3n de una l\u00ednea empiezan con <code>///</code> y terminan al final de la l\u00ednea.</p> <pre><code>/// &lt;summary&gt;\n/// Este texto explicar\u00eda el funcionamiento de un m\u00e9todo.\n/// &lt;/summary&gt;\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.5%20-%20Comentarios/#comentarios-de-documentacion-de-multiples-lineas","title":"Comentarios de documentaci\u00f3n de m\u00faltiples l\u00edneas","text":"<p>Los comentarios de documentaci\u00f3n de m\u00faltiples l\u00edneas empiezan con <code>/**</code> y terminan con <code>*/</code>.</p> <pre><code>/**\n * &lt;summary&gt;\n * Este texto explicar\u00eda el funcionamiento de un m\u00e9todo.\n * &lt;/summary&gt;\n * &lt;Param&gt;\n *     &lt;name&gt;param1&lt;/name&gt;\n *     &lt;description&gt;Descripci\u00f3n del par\u00e1metro&lt;/description&gt;\n *  &lt;/Param&gt;\n */\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.5%20-%20Comentarios/#etiquetas-de-comentarios-de-documentacion","title":"Etiquetas de comentarios de documentaci\u00f3n","text":"<p>Las etiquetas de comentarios de documentaci\u00f3n son etiquetas que se emplean dentro de los comentarios de documentaci\u00f3n para indicar informaci\u00f3n sobre el c\u00f3digo. Estas etiquetas se encuentran dentro de etiquetas XML.</p> Etiqueta Prop\u00f3sito <code>&lt;c&gt;</code> Establecer texto en una fuente similar a la de c\u00f3digo <code>&lt;code&gt;</code> Establecer una o m\u00e1s l\u00edneas de c\u00f3digo fuente o resultado del programa <code>&lt;example&gt;</code> Indicar un ejemplo <code>&lt;exception&gt;</code> Identifica las excepciones que un m\u00e9todo puede producir <code>&lt;include&gt;</code> Incluye XML de un archivo externo <code>&lt;list&gt;</code> Crear una lista o una tabla <code>&lt;para&gt;</code> Permitir agregar estructura a texto <code>&lt;param&gt;</code> Describir un par\u00e1metro para un m\u00e9todo o constructor <code>&lt;paramref&gt;</code> Identificar que una palabra es un nombre de par\u00e1metro <code>&lt;permission&gt;</code> Documentar la accesibilidad de seguridad de un miembro <code>&lt;remarks&gt;</code> Describir informaci\u00f3n adicional sobre un tipo <code>&lt;returns&gt;</code> Describir el valor devuelto de un m\u00e9todo <code>&lt;see&gt;</code> Especificar un v\u00ednculo <code>&lt;seealso&gt;</code> Generar una entrada vea tambi\u00e9n <code>&lt;summary&gt;</code> Describir un tipo o un miembro de un tipo <code>&lt;value&gt;</code> Describir una propiedad <code>&lt;typeparam&gt;</code> Describir un par\u00e1metro de tipo gen\u00e9rico <code>&lt;typeparamref&gt;</code> Identificar que una palabra es un nombre de par\u00e1metro de tipo"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/","title":"Tema 9.6: Estructuras de datos","text":"<p>En este tema veremos de manera resumida las estructuras m\u00e1s comunes que se utilizan en C#.</p> <p>Empezaremos por las m\u00e1s sencillas como son arrays y tuplas, y continuaremos con las que hacen uso de gen\u00e9ricos como lista, pila, cola y diccionario.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#arrays","title":"Arrays","text":"<p>Los arrays en C# son id\u00e9nticos a los de Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#declaracion-de-un-array","title":"Declaraci\u00f3n de un array","text":"<p>Al igual que en Java se declaran indicando:</p> <pre><code>// tipo seguido de [ y ] y el nombre de la variable.\nint[] arrayDeEnteros;\n\n// Opcionalmente se puede crear el array don un tama\u00f1o.\nint[] arrayDe5Enteros = new int[5];\n\n// O tambi\u00e9n se pueden asignar directamente valores.\nint[] arrayConValores = {1, 2, 3};\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#acceso-a-sus-elementos","title":"Acceso a sus elementos","text":"<p>Para acceder a un elemento concreto del array indicaremos al lado de la variable, entre corchetes, la posici\u00f3n o \u00edndice del elemento. Recordemos que el primer elemento tendr\u00e1 \u00edndice 0:</p> <pre><code>int[] intArr = {1, 2, 3};\nint[1] = int[1] * 10;\n// Ahora el array ser\u00e1 [1, 20, 3]\n</code></pre> <p>Para recorrer los elementos de un array se emplear\u00e1 la estructura <code>foreach</code>:</p> <pre><code>foreach (int i in intArr) {\n    //...\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#longitud-de-un-array","title":"Longitud de un array","text":"<p>Para ver la longitud de un array hemos de acceder a la propiedad <code>Length</code> o <code>LongLength</code>.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#funciones-de-arrays-y-colecciones-en-general","title":"Funciones de arrays (y colecciones en general)","text":"<p>Hay tres funciones que se suele aplicar sobre las estructura tipo colecci\u00f3n como son los arrays o las listas. Estas funciones son generalmente conocidas como map, reduce y filter:</p> <ol> <li>Map: Permite transformar una lista aplicando una funci\u00f3n a cada uno de sus elementos.</li> <li>Reduce: Permite... permite hacerle de todo a los elementos de una lista.</li> <li>Filter: Como su nombre indica permite filtrar los elementos de una lista aplicando una condici\u00f3n (en forma de funci\u00f3n).</li> </ol> <p>Map se denominar\u00e1 <code>Select</code> en C#, reduce ser\u00e1 <code>Aggregate</code> y filter pasar\u00e1 a denominarse <code>Where</code>.</p> <p>Veamos un ejemplo con cada una.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#map-select","title":"Map / <code>Select</code>","text":"<p>Escribamos una funci\u00f3n que eleve al cuadrado todos los elementos de un array de enteros:</p> <pre><code>int[] intArr = {1, 2, 3};\nintArr = intArr.Select(elem =&gt; elem * elem).ToArray&lt;int&gt;();\n\n// Ahora los valores de intArr ser\u00e1n [1, 4, 9].\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#reduce-aggregate","title":"Reduce / <code>Aggregate</code>","text":"<p>Esta es quiz\u00e1 una de las funciones m\u00e1s complicadas de entender de las que se pueden aplicar a listas de elementos. Esta funci\u00f3n permite procesar una lista iterando elemento a elemento y a la vez calculando algo paso a paso.</p> <p>Para poder realizar este c\u00e1lculo es necesario que una variable acumulador se pueda ir pasando a la funci\u00f3n que se aplicar\u00e1 a cada elemento de la lista de elementos.</p> <pre><code>int[] intArr = {1, 2, 3};\n\nint total = intArr.Aggregate((acc, e) =&gt; acc += e);\n</code></pre> <p>El c\u00f3digo anterior aplica la funci\u00f3n lambda <code>(acc, e) =&gt; acc + e</code> a cada elemento de la lista teniendo en cuenta que:</p> <ol> <li>El par\u00e1metro <code>e</code> ir\u00e1 tomando el valor de cada elemento del array (Enumerable) (1, 2 y 3 sucesivamente en nuestro ejemplo).</li> <li>El par\u00e1metro <code>acc</code> es, por defecto, del mismo tipo que el contenido del Enumerable sobre el que se ejecuta.</li> <li>El valor inicial de <code>acc</code> ser\u00e1 0, cadena vac\u00eda, etc. si no se le indica un valor expl\u00edcitamente.</li> <li>El valor de <code>acc</code> para cada elemento despu\u00e9s del primero ser\u00e1 el resultado de la funci\u00f3n lambda.</li> </ol> <p>As\u00ed, en nuestro ejemplo:</p> <ol> <li>Primera invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(0, 1)</code> y retornar\u00eda <code>0 + 1</code>, es decir, <code>1</code>.</li> <li>Segunda invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(1, 2)</code> y retornar\u00eda <code>1 + 2</code>, <code>3</code>.</li> <li>Tercera invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(3, 3)</code> y retornar\u00eda <code>3 + 3</code>, <code>6</code>.</li> </ol> <p>Para darle un valor inicial distinto de <code>0</code> al acumulador le pasaremos un argumento m\u00e1s a <code>Aggregate</code>:</p> <pre><code>int[] intArr = {1, 2, 3};\n\nint total = intArr.Aggregate(100, (acc, e) =&gt; acc += e);\n</code></pre> <p>Ahora el primer valor de <code>acc</code> ser\u00e1 <code>100</code> y el resultado final <code>106</code>.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#filter-where","title":"Filter / <code>Where</code>","text":"<p>El m\u00e9todo <code>Where</code> de los objetos que implementan <code>IEnumerable</code> (con es el caso de <code>Array</code> o <code>List</code>) permite seleccionar algunos elementos del enumerable en funci\u00f3n del resultado (verdadero o falso) que devuelva una funci\u00f3n lambda que se le pasa al m\u00e9todo.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>int[] intArr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\nintArr.Where(e =&gt; e % 2 == 0).ToList().ForEach(e =&gt; System.Console.WriteLine(e));\n</code></pre> <p>El c\u00f3digo anterior mostrar\u00e1 por consola el texto:</p> <pre><code>2\n4\n6\n8\n10\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#tuplas","title":"Tuplas","text":"<p>Una tupla es un tipo de datos similar a un array o a una lista pero pensados para tama\u00f1os m\u00e1s peque\u00f1os.</p> <p>Una tupla puede contener distintos tipos de datos.</p> <p>Una tupa puede asignar un nombre a cada uno de sus elementos.</p> <p>Una tupla es parecida a un mapa de Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#definicion-de-una-variable","title":"Definici\u00f3n de una variable","text":"<p>Para declarar una variable tupla hemos de indicar el tipo de sus datos dentro de par\u00e9ntesis:</p> <pre><code>(int, string, string) miTupla = (1, \"uno\", \"one\");\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#acceso-a-los-elementos","title":"Acceso a los elementos","text":"<p>Para acceder a los elementos de la tupla usaremos la palabra <code>ItemX</code> donde <code>X</code> tomar\u00e1 los valores 1, 2, ... para referirse al primer, segundo, etc. elemento de la misma.</p> <pre><code>(int, string, string) miTupla = (1, \"uno\", \"one\");\n\nConsole.WriteLine(miTupla.Item1 == 1);\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.6%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#nombrando-elementos","title":"Nombrando elementos","text":"<p>Para evitar tener que utilizar <code>Item1</code>, <code>Item2</code>, etc. que tienen muy poco significado podemos darles nombres a los elementos de la tupla:</p> <pre><code>(Value: int, Spanish: string, English: string) = (1, \"uno\", \"one\");\n\nConsole.WriteLine($\"valor: {miTupla.Value}, espa\u00f1ol: {miTupla.Spanish} e ingl\u00e9s: {miTupla.English}.\");\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/","title":"Tema 9.7: Tipos avanzados de datos","text":"<p>Con tipos avanzados de datos me refiero a los tipos de datos que son m\u00e1s complejos que los arrays y las tuplas. Se tratar\u00e1 de tipos de datos que no tiene un tama\u00f1o predeterminado si no que pueden crecer a medida que se les a\u00f1aden elementos (<code>ArrayList</code>, <code>List</code>, ...). Tambi\u00e9n hay tipos que guardan sus elementos asociados a un valor o clave (<code>Hastable</code>, <code>Dictionary</code>, ...).</p> <p>Estos tipos de datos atos tenemos que dividirlos en dos categor\u00edas no-gen\u00e9ricos y gen\u00e9ricos.</p> <p>Los primeros son tipos que admiten cualquier tipo de dato como contenido. Es decir, contendr\u00e1n elementos del tipo <code>Object</code>.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#tipos-no-genericos","title":"Tipos no-gen\u00e9ricos","text":"<p>Los tipos de datos no gen\u00e9ricos admiten datos de tipo <code>Object</code>. Para cada estructura de datos no gen\u00e9rica hay una equivalente gen\u00e9rica.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#arraylist","title":"ArrayList","text":"<p>El tipo <code>ArrayList</code> es una lista de tama\u00f1o din\u00e1mico que admite cualquier tipo de dato. Es decir, podemos a\u00f1adir elementos de cualquier tipo a la lista. Para acceder a los elementos de la lista debemos hacer un casting expl\u00edcito al tipo de dato que queremos recuperar.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#declaracion-de-un-arraylist","title":"Declaraci\u00f3n de un ArrayList","text":"<pre><code>ArrayList lista = new ArrayList();\n</code></pre> <p>Aunque no es necesario, podemos indicar el tama\u00f1o inicial de la lista:</p> <pre><code>ArrayList lista = new ArrayList(10);\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#anadir-elementos","title":"A\u00f1adir elementos","text":"<pre><code>ArrayList lista = new ArrayList();\n\n// A\u00f1adimos elementos a la lista.\n// Se a\u00f1aden como objetos de tipo Object.\nlista.Add(1);\nlista.Add(\"Hola\");\nlista.Add(3.14);\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#acceder-a-sus-elementos","title":"Acceder a sus elementos","text":"<p>Para acceder a un elemento del <code>ArrayList</code> hemos de indicar el \u00edndice del elemento que queremos recuperar. El primer elemento tiene el \u00edndice 0. Para poder utilizar el elemento, ya que se almacen\u00f3 como <code>Object</code> debemos hacer un casting expl\u00edcito al tipo de dato que queremos recuperar.</p> <p>Para recuperar un elemento usaremos el m\u00e9todo <code>Get()</code> pas\u00e1ndole como argumento el \u00edndice del elemento que queremos recuperar. Tambi\u00e9n podemos acceder a los elementos del <code>ArrayList</code> como si fuera un array:</p> <pre><code>// \n// Usando el m\u00e9todo Get().\nint entero = (int)lista.Get(0);\n\n\n// Usando el operador [].\nint entero = (int)lista[0];\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#tipos-genericos","title":"Tipos gen\u00e9ricos","text":"<p>La forma de trabajar con gen\u00e9ricos en C# es b\u00e1sicamente id\u00e9ntica a Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#declaracion-de-genericos","title":"Declaraci\u00f3n de gen\u00e9ricos","text":"<pre><code>class ContenedorGenerico&lt;T&gt;\n{\n    private T[] array;\n    private int count;\n\n    public ContenedorGenerico(int size)\n    {\n        array = new T[size];\n        count = 0;\n    }\n\n    public void Add(T element)\n    {\n        if (count &lt; array.Length)\n        {\n            array[count] = element;\n            count++;\n        }\n    }\n\n    public T Get(int index)\n    {\n        if (index &lt; count)\n        {\n            return array[index];\n        }\n        else\n        {\n            throw new IndexOutOfRangeException();\n        }\n    }\n\n    public void Set(int index, T element)\n    {\n        if (index &lt; count)\n        {\n            array[index] = element;\n        }\n        else\n        {\n            throw new IndexOutOfRangeException();\n        }\n    }\n\n    // Esta ser\u00eda una propiedad de solo lectura.\n    public int Count\n    {\n        get\n        {\n            return count;\n        }\n    }\n\n    public T this[int index]\n    {\n        get\n        {\n            return Get(index);\n        }\n        set\n        {\n            Set(index, value);\n        }\n    }\n}\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#listas","title":"Listas","text":"<p>De nuevo las listas de C# son muy similares a las listas de Java, aunque en C# s\u00f3lo hay un tipo de lista <code>List</code> en lugar de <code>ArrayList</code> y <code>LinkedList</code> de Java.</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#declarar-una-lista","title":"Declarar una lista","text":"<p>Para declarar una lista en C# hemos de indicar el tipo de dato que va a contener la lista como con cualquier otra clase gen\u00e9rica:</p> <pre><code>List&lt;string&gt; listaCadenas = new List&lt;String&gt;();\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#declarar-e-inicializar","title":"Declarar e inicializar","text":"<p>Tambi\u00e9n es posible declarar una lista y al mismo tiempo darle unos valores iniciales:</p> <pre><code>List&lt;int&gt; listaEnteros = new List&lt;int&gt;() {1, 2, 3, 4, 5};\n</code></pre>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#anadir-elementos-a-la-lista","title":"A\u00f1adir elementos a la lista","text":"<p>Para a\u00f1adir elementos (al final de la lista) usaremos el m\u00e9todo <code>Add</code>:</p> <pre><code>List&lt;int&gt; listaEnteros = new List&lt;int&gt;() {1, 2, 3, 4, 5};\n\nlistaEnteros.Add(6);\n\nlistaEnteros.ForEach(e =&gt; Console.Write(e + \", \"));\n\n// 1, 2, 3, 4, 5, 6, \n</code></pre> <p>Y en caso de que deseemos insertar el valor en una posici\u00f3n determinada usaremos el m\u00e9todo <code>Insert</code>:</p> <p>```c# List listaEnteros = new List() {1, 2, 3, 4, 5}; <p>listaEnteros.Insert(2, 3);</p> <p>for (int e in listaEnteros) {     Console.Write(e + \", \"); }</p> <p>// 1, 2, 3, 3, 4, 5</p>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#pilas","title":"Pilas","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#colas","title":"Colas","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.7%20-%20Tipos%20avanzados/#diccionarios","title":"Diccionarios","text":""},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.8%20-%20Struct%20y%20Enum/","title":"Tema 9.6 : <code>struct</code> y <code>enum</code>","text":"<p>El tipo <code>struct</code> sirve para definir tipos de datos que no son objetos. Un <code>struct</code> es pr\u00e1cticamente igual a una clase pero con ciertas limitaciones:</p> <ul> <li>Un <code>stuct</code> no puede heredar de otra clase o <code>struct</code>.</li> <li>Ninguna clase puede heredar de un <code>struct</code>.</li> </ul> <p>Adem\u00e1s de estas limitaciones un struct tiene algunas caracter\u00edsticas que lo diferencian de una clase:</p> <ul> <li>Un objeto tipo <code>struct</code>, a diferencia de un objeto derivado de un clase, se almacena en la pila de ejecuci\u00f3n y no en el heap.</li> <li>Un objeto tipo <code>struct</code> se pasa como argumento a un m\u00e9todo por valor, no por referencia.</li> </ul>"},{"location":"Tema%2009%20-%20Introducci%C3%B3n%20a%20C%20Sharp/Tema%20-%209.8%20-%20Struct%20y%20Enum/#tipo-struct","title":"Tipo <code>struct</code>","text":""},{"location":"Tema%201/Introduccion_a_la_programcacion/","title":"Tema 1: Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"Tema%201/Introduccion_a_la_programcacion/#historia","title":"Historia","text":""},{"location":"Tema%201/Introduccion_a_la_programcacion/#paradigmas","title":"Paradigmas","text":""},{"location":"Tema%201/Introduccion_a_la_programcacion/#lenguajes","title":"Lenguajes","text":""},{"location":"Tema%201/Introduccion_a_la_programcacion/#generaciones-o-niveles","title":"Generaciones o niveles","text":""},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/","title":"Tema 10.0: Flujos o <code>Stream</code>s","text":"<p>Un <code>Stream</code> representa un flujo de datos, generalmente unidireccional, desde un origen a un destino. Los <code>Stream</code>s se usan com\u00fanmente para leer y escribir datos desde o hacia un fichero.</p>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#creacion-de-un-stream","title":"Creaci\u00f3n de un <code>Stream</code>","text":"<p>Para crear un <code>Stream</code> a partir de un fichero usaremos la clase <code>FileStream</code>. <code>FileStream</code> guarda o representa la informaci\u00f3n como un array de bytes.</p> <p>Para usar un <code>FileStream</code> para lectura o escritura habr\u00e1 que indicar el n\u00famero de bytes que deseamos usar (leer o escribir).</p> <p>El constructor de un <code>FileStream</code> acepta dos argumentos:</p> <ul> <li>Path al fichero sobre el que vamos a actuar.</li> <li>La enumeraci\u00f3n <code>FileMode</code> que Especifica c\u00f3mo el sistema operativo debe abrir un archivo y ofrece las siguientes opciones:<ul> <li><code>CreateNew</code>: Especifica que el sistema operativo debe crear un archivo nuevo. Si el archivo ya existe, se produce una excepci\u00f3n <code>System.IO.IOException</code>.</li> <li><code>Create</code>: Especifica que el sistema operativo debe crear un archivo nuevo. Si el archivo ya existe, se sobrescribir\u00e1.</li> <li>Si el archivo no existe es equivalente a <code>CreateNew</code>.</li> <li>Si el archivo existe ser\u00e1 equivalente al <code>Truncate</code>.</li> <li><code>Open</code>: Especifica que el sistema operativo debe abrir un archivo existente. Se desencadena una excepci\u00f3n <code>FileNotFoundException</code> si el archivo no existe</li> <li><code>OpenOrCreate</code>: Especifica que el sistema operativo debe abrir un archivo si ya existe; en caso contrario, debe crearse uno nuevo.</li> <li><code>Truncate</code>:Especifica que el sistema operativo debe abrir un archivo existente. Cuando se abre el archivo, debe truncarse el archivo para que su tama\u00f1o sea de cero bytes. Al intentar leer un archivo abierto con <code>Truncate</code>, se produce una excepci\u00f3n <code>ArgumentException</code>.</li> <li><code>Append</code>:   Abre el archivo si existe y realiza una b\u00fasqueda hasta el final del mismo, o crea un archivo nuevo. Se produce un error de cualquier intento de lectura y una excepci\u00f3n <code>NotSupportedException</code>.</li> </ul> </li> </ul> <p>Veamos un ejemplo:</p> <pre><code>FileStream fs = new FileStream(\"fichero.txt\", FileMode.Open);\n</code></pre> <p>Este c\u00f3digo crea un objeto <code>FileStream</code> que representa el fichero <code>fichero.txt</code> y que se abrir\u00e1 en modo lectura.</p> <p>Una vez creado el objeto <code>FileStream</code> podemos usarlo para leer o escribir datos:</p>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#lectura-de-bytes-de-un-filestream","title":"Lectura de bytes de un <code>FileStream</code>","text":"<p>Para leer bytes directamente de un <code>FileStream</code> usaremos el m\u00e9todo <code>Read</code> que acepta tres argumentos:</p> <ul> <li>Un array de bytes donde se guardar\u00e1n los datos le\u00eddos.</li> <li>Un valor de offset que indica a partir de que posici\u00f3n del array deseamos escribir los datos le\u00eddos.</li> <li>El n\u00famero de bytes que deseamos leer.</li> </ul> <pre><code>byte[] buffer = new byte[100];\nint nBytes = fs.Read(buffer, 0, 100);\n</code></pre>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#escritura-de-bytes-a-un-filestream","title":"Escritura de bytes a un <code>FileStream</code>","text":"<p>Para escribir bytes directamente a un <code>FileStream</code> usaremos el m\u00e9todo <code>Write</code> que acepta tres argumentos:</p> <ul> <li>Un array de bytes que contiene los datos a escribir.</li> <li>El valor de offset que indica a partir de que posici\u00f3n del array deseamos escribir.</li> <li>El n\u00famero de bytes que deseamos escribir.</li> </ul> <pre><code>byte[] buffer = new byte[100];\n\nfor (int i = -100; i &lt; 100; i++)\n{\n    buffer[i] = (byte)i;\n}\n\nint nBytes = fs.Write(buffer, 0, 100);\n</code></pre>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#los-flujos-han-de-cerrarse","title":"Los flujos han de cerrarse","text":"<p>Los flujos representan recursos y, por tanto, hay que cerrarlos cuando ya no se vayan a usar.</p> <p>Para cerrar un flujo usaremos el m\u00e9todo <code>Close()</code>.</p> <p>Si no cerramos expl\u00edcitamente el flujo, el recolector de basura de .NET no lo cerrar\u00e1 y, por tanto, no liberar\u00e1 los recursos que ocupa.</p> <p>Puesto que nos podemos olvidar de invocar a <code>Close()</code> o podr\u00eda producirse una excepci\u00f3n que impida que se cierre el flujo, es recomendable usarlos dentro de un bloque <code>using</code> que se encargar\u00e1 de cerrarlos autom\u00e1ticamente.</p>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#sentencia-using-para-trabajar-con-recursos","title":"Sentencia <code>using</code> para trabajar con recursos","text":"<p>Para evitar tener que cerrar expl\u00edcitamente los recursos que se usan en un bloque de c\u00f3digo, podemos usar la sentencia <code>using</code> que nos permite trabajar con recursos de forma segura.</p> <p>Si necesitamos trabajar con varios recursos (<code>Streams</code>) en un mismo segmento de c\u00f3digo podemos usar varios bloques <code>using</code> consecutivos.</p> <pre><code>using (FileStream fs = new FileStream(\"fichero.txt\", FileMode.Open))\nusing (StreamWriter sw = new StreamWriter(fs))\n{\n    // Trabajamos con el flujo sw.\n}\n// Aqu\u00ed el flujo sw ya est\u00e1 cerrado.\n</code></pre>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#escritura-de-texto-a-un-fichero","title":"Escritura de texto a un fichero","text":"<p>Aunque, como hemos visto, es posible leer y escribir en un fichero utilizando simplemente referencias <code>FileStream</code>, estas nos limitan a hacerlo en forma de bytes.</p> <p>Para escribir texto a un fichero es recomendable usar un objeto <code>StreamWriter</code>. El constructor de <code>StreamWriter</code> acepta dos argumentos (el segundo opcional):</p> <ul> <li>El flujo sobre el que vamos a escribir (un objeto <code>FileStream</code> en este caso).</li> <li>La codificaci\u00f3n del texto (tomada de la enumeraci\u00f3n <code>System.Text.Encoding</code>):</li> <li>Ser\u00e1 <code>UTF-8</code> si no se indica nada (opci\u00f3n por defecto).</li> <li>Podr\u00e1 ser <code>ASCII</code>, <code>Unicode</code>, <code>Default</code>, etc.</li> </ul> <p>Para escribir usaremos el m\u00e9todo <code>WriteLine</code> del objeto <code>StreamWriter</code> que hayamos creado. El m\u00e9todo <code>WriteLine</code> tiene el comportamiento del <code>Console.WriteLine()</code> pues se trata del mismo m\u00e9todo ya que <code>Console</code> se comporta como un <code>StreamWriter</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>using (FileStream fs = new FileStream(\"fichero.txt\", FileMode.Create))\nusing (StreamWriter sw = new StreamWriter(fs))\n{\n    sw.WriteLine(\"Hola mundo\");\n}\n</code></pre>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#lectura-de-texto-de-un-fichero","title":"Lectura de texto de un fichero","text":""},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#escritura-de","title":"Escritura de","text":"<p>bytes (o texto) a un fichero</p> <p>Para escribir bytes (o texto) a un fichero es recomendable usar un objeto <code>BinaryWriter</code>. <code>BinaryWriter</code> permite escribir un array de bytes o un texto (tambi\u00e9n n\u00fameros y caracteres). Este objeto facilita la escritura a un archivo de datos de tipos primitivos as\u00ed como de cadenas de caracteres. Si vamos a escribir caracteres podremos crear el objeto <code>BinaryWriter</code> indicando la codificaci\u00f3n de los caracteres (por defecto ser\u00e1 <code>UTF-8</code>).</p> <pre><code>using (FileStream fs = new FileStream(\"fichero.txt\", FileMode.Create))\nusing (BinaryWriter bw = new BinaryWriter(fs, Encoding.UTF8))\n{\n    // Trabajamos con el flujo bw\n}\n</code></pre> <p>Para escribir mediante el <code>BinaryWriter</code> podemos usar el m\u00e9todo <code>Write</code> que acepta uno o tres argumentos:</p>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#write-con-un-argumento","title":"<code>Write</code> con un argumento","text":"<p>Se usa para escribir tipos primitivos al stream (que hace referencia a un fichero en nuestros ejemplos).</p> <pre><code>bw.Write(1);\nbw.Write(1.5);\nbw.Write('a');\nbw.Write(true);\n\n// Tambi\u00e9n acepta strings:\nbw.Write(\"Hola mundo\");\n\n// Y arrays de chars:\nbw.Write(new char[] { 'a', 'b', 'c' });\n</code></pre> <p>Cuando escribimos una cadena usando el m\u00e9todo <code>Write</code> de <code>BinaryWriter</code> hemos de tener en cuenta que la conversi\u00f3n a bytes la realizar\u00e1 en funci\u00f3n de la codificaci\u00f3n que hayamos indicado al crear el objeto <code>BinaryWriter</code>.</p>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#write-con-tres-argumentos","title":"<code>Write</code> con tres argumentos","text":"<p>Los argumentos son:</p> <ul> <li>Array a escribir (<code>byte[]</code> o <code>char[]</code>).</li> <li>Un valor de offset que indica a partir de que posici\u00f3n del array deseamos escribir.</li> <li>Un \u00faltimo valor longitud que indica cuantos bytes del array (a partir del offset) vamos a escribir.</li> </ul> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>using(FileStream fs = new FileStream(\"fichero.txt\", FileMode.Create) using(BinaryWriter bw = new BinaryWriter(fs))\n{\n    byte[] buffer = new byte[100];\n    for (int i = 0; i &lt; 100; i++)\n    {\n        buffer[i] = (byte)i;\n    }\n\n    // Escribimos los n\u00fameros de 9 al 19\n    bw.Write(buffer, 10, 10);\n}\n</code></pre>"},{"location":"Tema%2010%20-%20Streams/Tema%2010.0%20-%20Sreams/#lectura-de-bytes-o-texto-de-un-fichero","title":"Lectura de bytes (o texto) de un fichero","text":"<p>Para leer bytes (o texto) de un fichero es recomendable usar un objeto <code>BinaryReader</code>.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/","title":"Tema 11.0: Introducci\u00f3n a WPF","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#que-es-wpf","title":"\u00bfQu\u00e9 es WPF?","text":"<p>WPF son las siglas de Windows Presentation Foundation. Consiste en un framework de interfaz de usuario que permite crear aplicaciones de escritorio.</p> <p>WPF es parte del framework .NET.</p> <p>WPF utiliza el lenguaje de marcas XAML <sup>1</sup> para definir la interfaz de usuario de manera declarativa.</p> <p>Tambi\u00e9n es posible crear la interfaz de usuario mediante c\u00f3digo C# o, lo que es lo mismo, de manera program\u00e1tica.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#que-es-xaml","title":"\u00bfQu\u00e9 es XAML?","text":"<p>XAML<sup>2</sup> es un lenguaje declarativo de marcas que permite definir la interfaz de usuario de una aplicaci\u00f3n de escritorio.</p> <p>La sintaxis de XAML es XML con las limitaciones propias de los elementos y propiedades que existen en el contexto de una aplicaci\u00f3n.</p> <p>NOTA: xmlns son las siglas de XML Name Space. Es un mecanismo que permite definir un espacio de nombres para los elementos de un documento XML.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#primeros-pasos-con-wpf","title":"Primeros pasos con WPF","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#crear-un-elemento-boton","title":"Crear un elemento: bot\u00f3n","text":"<p>Para crear un elemento en XAML debemos indicar el tipo de elemento que queremos crear y sus propiedades.</p> <p>En el caso de un bot\u00f3n el elemento es <code>&lt;Button&gt;</code> y la propiedad es <code>Content</code> que es la que define el texto que aparece en el bot\u00f3n.</p> <pre><code>&lt;Button Content=\"Bot\u00f3n\" /&gt;\n</code></pre> <p>Otra forma de crear un bot\u00f3n es abriendo y cerrando el elemento <code>&lt;Button&gt;</code> y a\u00f1adiendo en su interior los elementos que representen la propiedad que deseamos modificar.</p> <pre><code>&lt;Button&gt;\n    &lt;Button.Content&gt;\n        Bot\u00f3n\n    &lt;/Button.Content&gt;\n&lt;/Button&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#el-boton-de-manera-programatica","title":"El bot\u00f3n de manera program\u00e1tica","text":"<p>Si nos fijamos en el explorador de soluciones podemos ver que el elemento MainWindow.xaml se puede desplegar y que dentro tiene un elemento MainWindow.xaml.cs asociado.</p> <p>Dentro de este archivo de c\u00f3digo fuente de C# podemos ver que hay una clase <code>MainWindow</code> que hereda de <code>Window</code> y que tiene un m\u00e9todo <code>InitializeComponent()</code>.</p> <p>El m\u00e9todo constructor de la clase <code>MainWindow</code> tiene una funci\u00f3n similar al m\u00e9todo <code>Main()</code> de un programa de consola. Es el punto de entrada de la aplicaci\u00f3n y el encargado de inicializar la interfaz de usuario.</p> <p>Dentro de este m\u00e9todo se llama al m\u00e9todo <code>InitializeComponent()</code> que es el encargado de crear la interfaz de usuario.</p> <p>A continuaci\u00f3n nosotros podr\u00edamos crear a mano la interfaz de usuario de la aplicaci\u00f3n.</p> <p>Para ello lo primero que necesitar\u00edamos es un objeto <code>Grid</code> (dentro del cual se posicionar\u00e1n los dem\u00e1s elementos):</p> <pre><code>Grid grid = new Grid();\nThis.Content = grid;\n</code></pre> <p>Si queremos a\u00f1adir un bot\u00f3n a la interfaz de usuario lo podemos hacer de la siguiente manera:</p> <pre><code>Button button = new Button();\nbutton.Content = \"Bot\u00f3n\";\n\ngrid.Children.Add(button);\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#ejemplo-mas-grande","title":"Ejemplo m\u00e1s grande","text":"<p>En este ejemplos pondremos un bot\u00f3n dentro de la ventana y dentro introduciremos text bloques de texto con diferentes colores.</p> <p>En primero lugar veremos como se representa en XAML:</p> <pre><code>&lt;Grid HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"&gt;\n    &lt;Button&gt;\n        &lt;Button.FontSize&gt;24&lt;/Button.FontSize&gt;\n        &lt;Button.Width&gt;200&lt;/Button.Width&gt;\n        &lt;Button.Height&gt;100&lt;/Button.Height&gt;\n        &lt;Button.Content&gt;\n            &lt;WrapPanel&gt;\n                &lt;TextBlock Foreground=\"AliceBlue\"&gt;Uno&lt;/TextBlock&gt;\n                &lt;TextBlock Foreground=\"Coral\"&gt;Uno&lt;/TextBlock&gt;\n                &lt;TextBlock Foreground=\"Turquoise\"&gt;Uno&lt;/TextBlock&gt;\n            &lt;/WrapPanel&gt;\n        &lt;/Button.Content&gt;\n    &lt;/Button&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Si quisi\u00e9ramos hacer lo mismo de manera program\u00e1tica ser\u00eda de la siguiente manera:</p> <pre><code>public partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n        Grid grid = new Grid();\n\n        this.Content = grid;\n\n        Button btn = new Button();\n        btn.Width = 200;\n        btn.Height = 100;\n        btn.FontSize = 20;\n\n        WrapPanel wp = new WrapPanel();\n\n        TextBlock tb1 = new TextBlock();\n        tb1.Text = \"Hello!\";\n        tb1.Foreground = Brushes.OrangeRed;\n\n        TextBlock tb2 = new TextBlock();\n        tb2.Text = \"Hello!\";\n        tb2.Foreground = Brushes.OrangeRed;\n\n        TextBlock tb3 = new TextBlock();\n        tb3.Text = \"Good bye!\";\n        tb3.Foreground = Brushes.DeepSkyBlue;\n\n        wp.Children.Add(tb1);\n        wp.Children.Add(tb2);\n        wp.Children.Add(tb3);\n\n        btn.Content = wp;\n\n        grid.Children.Add(btn);\n    }\n}\n</code></pre> <p>En cualquier caso el resultado ser\u00eda el mismo:</p> <p></p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.0%20-%20WPF/#arbol-de-elementos","title":"\u00c1rbol de elementos","text":"<p>Se puede decir que un elemento o un conjunto de elementos tiene dos \u00e1rboles:</p> <ul> <li>\u00c1rbol l\u00f3gico: Es el \u00e1rbol de elementos que se representa en el c\u00f3digo de la aplicaci\u00f3n (XAML o C#).</li> <li>\u00c1rbol visual: Es el \u00e1rbol de elementos que se representa en la interfaz de usuario.</li> </ul> <p>El \u00e1rbol visual, adem\u00e1s de los elementos que se ven en el \u00e1rbol l\u00f3gico tiene otros muchos elementos ya que cada elemento como una lista o un bot\u00f3n est\u00e1 compuesto por otros elementos. As\u00ed un bot\u00f3n est\u00e1 compuesto por un borde que contiene un <code>ContentPresenter</code> y este a su vez contiene un <code>TextBlock</code>.</p> <p>Para acceder al \u00e1rbol visual de una aplicaci\u00f3n podemos hacerlo estableciendo un breackpoint en alg\u00fan m\u00e9todo de nuestra aplicaci\u00f3n (por ejemplo el m\u00e9todo handler del bot\u00f3n), lanzar la aplicaci\u00f3n y luego el cuadro de elementos de la ventana seleccionar la lupa y hacer click en el bot\u00f3n <code>Visualizador WPF</code>.</p> <p>Al pausar la ejecuci\u00f3n de la aplicaci\u00f3n despu\u00e9s de lanzar un evento podremos ver esta ventana:</p> <p></p> <p>Si pulsamos sobre la lupa aparecer\u00e1 la opci\u00f3n <code>Visualizador WPF</code> y si pulsamos sobre ella se abrir\u00e1 una ventana con el \u00e1rbol visual de la aplicaci\u00f3n:</p> <p></p> <p>Como podremos ver al ir desplegando el \u00e1rbol hay muchos elementos que est\u00e1n compuestos por otros:</p> <p></p> <ol> <li> <p>Extensible Application Markup Language.\u00a0\u21a9</p> </li> <li> <p>Extensible Application Markup Language.\u00a0\u21a9</p> </li> </ol>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.2%20-%20Contenedores/","title":"Tema 11.2: Contenedores","text":"<p>Todo sistema o framework destinado a crear interfaces de usuario ha de disponer de alg\u00fan mecanismo para distribuir los componentes (botones, cuadros de textos, listas, radio buttons, etc.) en la ventana de la aplicaci\u00f3n.</p> <p>Una forma de lograr esto es mediante el uso de componentes contenedores. Estos contenedores, como su nombre indica, pueden contener otros componentes. Tambi\u00e9n permiten distribuir los componentes que contienen de distintas formas. Para crear una interfaz con posiciones consistentes la pr\u00e1ctica habitual es incluir los componentes que est\u00e9n formando un grupo en un mismo contenedor y a su vez incluir este contenedor en otro de nivel superior.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/","title":"Tema 11.3: Dise\u00f1o interfaz","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#recursos","title":"Recursos","text":"<p>Figma es una herramienta de dise\u00f1o de interfaces gr\u00e1ficas que permite dise\u00f1ar interfaces de usuario para aplicaciones web y m\u00f3viles. Tiene una versi\u00f3n gratuita.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#grid","title":"Grid","text":"<p>El grid es una rejilla que nos permite organizar los elementos de la interfaz.</p> <p>Para usar el grid debemos establecer divisiones del mismo. Esto se har\u00e1 en forma de filas y o columnas.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#filas-del-grid","title":"Filas del Grid","text":"<p>Para definir dos o m\u00e1s filas dentro de un grid hemos de crear una secci\u00f3n <code>&lt;Grid.RowDefinitions&gt;</code> dentro de la etiqueta <code>&lt;Grid&gt;</code>. Y, a su vez, dentro de <code>&lt;Grid.RowDefinitions&gt;</code> debemos crear tantas etiquetas <code>&lt;RowDefinition&gt;</code> como filas necesitemos.</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n&lt;/Grid&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#columnas-del-grid","title":"Columnas del Grid","text":"<p>De forma an\u00e1loga podremos crear columnas del grid. Para ello utilizaremos la etiqueta <code>&lt;Grid.ColumnDefinitions&gt;</code> y dentro de ella crearemos tantas etiquetas <code>&lt;ColumnDefinition&gt;</code> como columnas necesitemos.</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n&lt;/Grid&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#uso-de-filas-y-columnas","title":"Uso de filas y columnas","text":"<p>Una vez definidas nuestras filas y o columnas dentro del grid podremos a\u00f1adir otros componentes. Para ello debemos indicar en qu\u00e9 fila y columna queremos que se coloquen. Para ello utilizaremos las propiedades <code>Grid.Row</code> y <code>Grid.Column</code>.</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"0\" Content=\"Bot\u00f3n 1\" /&gt;\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"1\" Content=\"Bot\u00f3n 2\" /&gt;\n    &lt;Button Grid.Row=\"1\" Grid.Column=\"0\" Content=\"Bot\u00f3n 3\" /&gt;\n    &lt;Button Grid.Row=\"1\" Grid.Column=\"1\" Content=\"Bot\u00f3n 4\" /&gt;\n&lt;/Grid&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#tamanos-de-filas-y-columnas","title":"Tama\u00f1os de filas y columnas","text":"<p>En cada fila y columna podemos definir el tama\u00f1o que queremos que tenga. Para ello utilizaremos las propiedades <code>Height</code> y <code>Width</code> de las etiquetas <code>&lt;RowDefinition&gt;</code> y <code>&lt;ColumnDefinition&gt;</code> respectivamente.</p> <p>El valor de <code>Height</code> y <code>Width</code> puede ser absoluto si indicamos un n\u00famero. Este valor har\u00e1 referencia al n\u00famero de p\u00edxeles que tendr\u00e1 la fila o columna de alto o de ancho.</p> <p>Tambi\u00e9n se puede indicar el valor  <code>Auto</code> que har\u00e1 que la fila (o columna) tome tanto tama\u00f1o como necesite para acomodar los elementos que contenga.</p> <p>Por \u00faltimo podremos indicar el valor <code>*</code>. <code>*</code> indica que la fila (o columna) ocupar\u00e1 el espacio restante. Por ejemplo, si tenemos dos filas y en la primera indicamos <code>Height=\"Auto\"</code> y en la segunda <code>Height=\"*\"</code> la segunda fila ocupar\u00e1 todo el espacio restante que quede libre despu\u00e9s de colocar los elementos de la primera fila.</p> <p>Tambi\u00e9n podremos acompa\u00f1ar <code>*</code> de un n\u00famero. Por ejemplo, si tenemos dos filas y en la primera indicamos <code>Height=\"1*</code> y en la segunda <code>Height=\"2*\"</code> la segunda fila ocupar\u00e1 el doble de espacio que la primera fila.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.3%20-%20Dise%C3%B1o%20interfaz/#estilos","title":"Estilos","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/","title":"Tema 11.4: Eventos","text":"<p>Los eventos son acciones que se producen en la interfaz de usuario y que pueden ser detectadas por el c\u00f3digo de la aplicaci\u00f3n.</p> <p>En el caso de WPF los eventos se generan cuando se produce una acci\u00f3n sobre un elemento de la interfaz de usuario. Por ejemplo cuando se pulsa un bot\u00f3n, cuando se selecciona un elemento de una lista, cuando se mueve el rat\u00f3n sobre un elemento, etc.</p> <p>El mecanismo que utiliza WPF para manejar los eventos se denomina <code>Routed events</code>.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/#routed-events","title":"Routed events","text":"<p>Un evento enrutado es un tipo de evento que puede activar handlers (manejadores) en m\u00faltiples listeners del \u00e1rbol de elementos y no solo en el elemento que lo genera. Un event listener (escuchador de eventos) es aquel elemento donde tenemos un manejador de eventos y sobre el cual es invocado. Una fuente de eventos es el elemento u objeto que originalmente laz\u00f3 el evento.</p> <p>Las aplicaciones WPF normalmente contienen muchos elementos, que se declaran en XAML o se instancian en c\u00f3digo. Los elementos de una aplicaci\u00f3n existen dentro de su \u00e1rbol de elementos. Dependiendo de c\u00f3mo se defina un evento enrutado, cuando se genera un evento en un elemento fuente:</p> <ul> <li>Burbujea (bubbles) a trav\u00e9s del \u00e1rbol de elementos desde el elemento fuente hasta la ra\u00edz, que suele ser una p\u00e1gina o una ventana.</li> <li>Tunelea (tunnels) a trav\u00e9s del \u00e1rbol de elementos desde la ra\u00edz hasta el elemento fuente.</li> <li>No viaja a trav\u00e9s del \u00e1rbol de elementos y solo ocurre en el elemento fuente.</li> </ul> <p>Una vez generado un evento (imaginemos un click en un bot\u00f3n) este evento se propaga por el \u00e1rbol de elementos de la interfaz de usuario hasta que es detectado por alg\u00fan elemento. Podr\u00edamos decir que el evento sigue una ruta.</p> <p>Seg\u00fan d\u00f3nde se traten los eventos se pueden distinguir tres tipos:</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/#eventos-directamente-enrutados-directly-routed-events","title":"Eventos directamente enrutados (directly routed events)","text":"<p>Son los eventos que se detectan y tratan en el elemento que los genera. Por ejemplo cuando se pulsa un bot\u00f3n el evento se detecta y trata en el bot\u00f3n (el m\u00e9todo handler del bot\u00f3n <code>Button_Click</code>).</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/#eventos-que-burbujean-bubbling-routed-events","title":"Eventos que burbujean (bubbling routed events)","text":"<p>Este burbujeo de eventos se produce cuando el elemento d\u00f3nde se origina el evento no lo trata y lo deja pasar. Por lo que burbujea hasta el siguiente elemento contenedor de la jerarqu\u00eda. Si este elemento tampoco lo trata burbujea hasta el siguiente elemento contenedor y as\u00ed sucesivamente hasta que el evento es tratado o hasta que llega al elemento ra\u00edz de la interfaz de usuario.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/#eventos-que-tunelean-tunneling-events","title":"Eventos que tunelean (Tunneling events)","text":"<p>Este es el caso opuesto al anterior. En este caso el evento tunelea hasta el elemento ra\u00edz de la interfaz de usuario que se considera su origen. Los nombres de estos eventos comienzan por <code>Preview</code> como en el caso de <code>PreviewMouseLeftButtonDown</code>. Podremos capturarlos en su viaje hacia el bot\u00f3n (o el elemento que corresponda) para realizar alguna acci\u00f3n antes de que el evento llegue al bot\u00f3n o para evitar completamente que el evento llegue al mismo.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.4%20-%20Eventos/#anadir-comportamiento-a-un-boton","title":"A\u00f1adir comportamiento a un bot\u00f3n","text":"<p>Para que un bot\u00f3n tenga comportamiento debemos a\u00f1adirle un evento.</p> <pre><code>&lt;Grid&gt;\n    &lt;Button Width=\"150\" Height=\"100\" Content=\"Click me!\" FontSize=\"24\" Click=\"Button_Click\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Se a continuaci\u00f3n vamos al c\u00f3digo fuente generado en el archivo MainWindow.xaml.cs podremos ver el siguiente c\u00f3digo:</p> <pre><code>/// &lt;summary&gt;\n/// L\u00f3gica de interacci\u00f3n para MainWindow.xaml\n/// &lt;/summary&gt;\npublic partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    private void Button_Click(object sender, RoutedEventArgs e)\n    {\n\n    }\n}\n</code></pre> <p>Es dentro del m\u00e9todo <code>Button_Click()</code> donde debemos a\u00f1adir el c\u00f3digo que queremos que se ejecute cuando se pulse el bot\u00f3n.</p> <p>En primer lugar podemos ver que el m\u00e9todo recibe dos par\u00e1metros:</p> <ul> <li><code>sender</code>: es el objeto que ha generado el evento (nuestro bot\u00f3n).</li> <li><code>e</code>: es el objeto que contiene informaci\u00f3n sobre el evento.</li> </ul> <p>Si queremos que se ejecute alg\u00fan c\u00f3digo cuando pulsemos el bot\u00f3n hemos de introducir c\u00f3digo dentro del m\u00e9todo <code>Button_Click()</code>. Por ejemplo podremos incluir el siguiente:</p> <p><code>C#  MessageBox.Show(\"Button was clicked!\");</code></p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/","title":"Tema 11.2: MVVM","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#que-es-mvvm","title":"\u00bfQu\u00e9 es MVVM?","text":"<p>MVVM<sup>1</sup> es patr\u00f3n de dise\u00f1o de software que se utiliza para separar la interfaz de usuario de la l\u00f3gica de negocio. MVVM tamb\u00e9n es conocido como model-view-binder que se traducir\u00eda como modelo-y-vista-enlazados y fue creado por los ingenieros de Microsoft Ken Cooper y John Gossman sobre el a\u00f1o 2004.</p> <p>La idea principal de MVVM es que la interfaz de usuario (la vista) no tiene que conocer la l\u00f3gica de negocio (el modelo) y que la l\u00f3gica de negocio no tiene que conocer la interfaz de usuario.</p> <p>La segunda caracter\u00edstica de MVVM es que la vista y el modelo se enlazan de manera autom\u00e1tica. Esto quiere decir que cuando el modelo cambia la vista se actualiza autom\u00e1ticamente y viceversa.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#que-es-la-vista","title":"\u00bfQu\u00e9 es la vista?","text":"<p>La vista es la interfaz que se muestra al usuario. En WPF la vista es un \u00e1rbol de elementos que se representa en el c\u00f3digo XAML o en el c\u00f3digo C#.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#que-es-el-modelo","title":"\u00bfQu\u00e9 es el modelo?","text":"<p>El modelo es la l\u00f3gica de negocio de la aplicaci\u00f3n. En WPF el modelo es un conjunto de clases que representan los datos de la aplicaci\u00f3n y las relaciones entre ellos.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#que-es-el-viewmodel","title":"\u00bfQu\u00e9 es el ViewModel?","text":"<p>TODO: TEXTO CREADO POR EL COPILOT</p> <p>El ViewModel es un objeto que se encarga de enlazar la vista y el modelo. En WPF el ViewModel es una clase que implementa la interfaz <code>INotifyPropertyChanged</code> y que tiene propiedades que representan los datos que se muestran en la vista.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#ejemplo-de-mvvm","title":"Ejemplo de MVVM","text":"<p>Para ver como funciona MVVM vamos a crear una aplicaci\u00f3n empezando por el modelo y luego creando la vista y el ViewModel.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#crear-el-modelo","title":"Crear el modelo","text":"<p>El modelo representa el sistema de reservas de un hotel. Constar\u00e1 de cuatro clases:</p> <ul> <li><code>Hotel</code>: Representa el hotel.</li> <li><code>LibroDeReservas</code>: Representa el libro de reservas del hotel.</li> <li><code>Reserva</code>: Representa una reserva.</li> <li><code>IDHabitacion</code>: Representa el identificador de una habitaci\u00f3n.</li> </ul> <p></p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#clase-hotel","title":"Clase <code>Hotel</code>","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#clase-librodereservas","title":"Clase <code>LibroDeReservas</code>","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#clase-reserva","title":"Clase <code>Reserva</code>","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#clase-idhabitacion","title":"Clase <code>IDHabitacion</code>","text":""},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.5%20-%20MVVM/#analizar-el-caso-de-uso","title":"Analizar el caso de uso","text":"<p>Hay dos casos de uso que vamos a implementar en la aplicaci\u00f3n:</p> <ul> <li> <p>Ver las reservas de un d\u00eda. Este es el m\u00e1s sencillo pues es \u00fanicamente de consulta. El usuario introduce una fecha y la aplicaci\u00f3n muestra las reservas de ese d\u00eda.</p> </li> <li> <p>Crear una reserva. El usuario introduce los datos de la reserva y la aplicaci\u00f3n la crea. \u00c9ste es m\u00e1s complicado pues adem\u00e1s de introducir los datos de la reserva hay que comprobar que la habitaci\u00f3n est\u00e1 libre.</p> </li> </ul> <p></p> <ol> <li> <p>Model-View-ViewModel\u00a0\u21a9</p> </li> </ol>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/","title":"Tema 11.6: Delegados y eventos","text":"<p>Para poder entender c\u00f3mo funciona el enlazado de datos es necesario conocer algunos conceptos previos: delegados y eventos. Estos dos elementos se utilizan cuando realizamos binding (o enlazado de datos) entre las vistas y los view-models para informar a los componentes de las vistas de los cambios en las propiedades el modelo y viceversa.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#delegados","title":"Delegados","text":"<p>Un delegado es un elemento de C# que permite encapsular una o m\u00e1s referencias a m\u00e9todos y funciones. El delegado tambi\u00e9n ofrece un mecanismo para invocar a los m\u00e9todos encapsulados.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#declaracion-de-un-tipo-delegado","title":"Declaraci\u00f3n de un tipo delegado","text":"<p>Para declarar un tipo delegado (acci\u00f3n an\u00e1loga a la definici\u00f3n de una clase) hemos de usar la palabra reservada <code>delegate</code>, seguida de la firma (tipo de retorno y par\u00e1metros) de los m\u00e9todos que podr\u00e1 encapsular</p> <pre><code>delegate int MiDelegado(string mensaje);\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#declaracion-de-un-delegado","title":"Declaraci\u00f3n de un delegado","text":"<p>Para declarar una variable de tipo delegado simplemente antepondremos al nombre de la variable el tipo delegado que previamente hemos definido.</p> <pre><code>MiDelegado delegado;\n</code></pre> <p>N\u00f3tese que no hay que instanciar nada.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#encapsular-funciones-en-un-delegado","title":"Encapsular funciones en un delegado","text":"<p>Para encapsular una funci\u00f3n en un delegado debemos asignarle la referencia a la funci\u00f3n. Para ello usaremos el operador <code>=</code>.</p> <pre><code>// Supongamos que tenemos un m\u00e9todo est\u00e1tico que acepta un string y devuelve un int.\n// No es necesario que sea est\u00e1tico, pero para simplificar el ejemplo lo haremos as\u00ed.\n\nprivate static int MiFuncion(string mensaje)\n{\n    Console.WriteLine(mensaje);\n    return 0;\n}\n\nprivate static int MiOtraFuncion(string cadena) {\n    return cadena.Length;\n}\n\n// Si queremos encapsular la funci\u00f3n en el delegado lo haremos de la siguiente forma:\ndelegado = MiFuncion;\n\n// O de forma equivalente:\ndelegado = new MiDelegado(MiFuncion);\n</code></pre> <p>De esta forma tendremos encapsulada la funci\u00f3n <code>MiFuncion</code> en el delegado <code>delegado</code>.</p> <p>Si queremos a\u00f1adir m\u00e1s funciones o m\u00e9todos al delegado usaremos el operador <code>+=</code> para ir sum\u00e1ndolas al mismo.</p> <pre><code>delegado = MiFuncion;\ndelegado += MiOtraFuncion;\ndelegado += x =&gt; x.Length;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#invocar-a-un-delegado","title":"Invocar a un delegado","text":"<p>Invocar a un delegado supone llamar a todas las funciones o m\u00e9todos que contiene. Para ello usaremos el operador <code>()</code> o el m\u00e9todo <code>Invoke()</code> (son equivalentes).</p> <pre><code>delegado(\"Hola\"); // Equivalente a delegado.Invoke(\"Hola\");\n</code></pre> <p>Hay que tener en cuenta que si no se ha asignado ninguna funci\u00f3n al delegado, al invocarlo se producir\u00e1 un error <code>System.NullReferenceException</code>.</p> <p>Para evitar esto se ha de hacer una comprobaci\u00f3n antes de invocar al delegado.</p> <pre><code>if (delegado != null)\n{\n    delegado(\"Hola\");\n}\n</code></pre> <p>Desde C# 6.0 se ha introducido la posibilidad de hacer esta comprobaci\u00f3n de forma m\u00e1s sencilla mediante el operador <code>?.</code><sup>1</sup>:</p> <pre><code>delegado?.Invoke(\"Hola\");\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#eventos","title":"Eventos","text":"<p>Un evento es un elemento de C# que, al igual que los delegados, encapsula una o m\u00e1s referencias a m\u00e9todos y funciones. Los eventos son tan similares a los delegados que es necesario utilizar un delegado para definir un evento.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#declaracion-de-un-evento","title":"Declaraci\u00f3n de un evento","text":"<p>Para declarar un tipo evento hemos de usar la palabra reservada <code>event</code> seguida del nombre del tipo delegado que encapsular\u00e1.</p> <pre><code>delegate int MiDelegado(string mensaje);\nevent MiDelegado MiEvento;\n</code></pre> <p>En el ejemplo anterior <code>MiEvento</code> podr\u00e1 encapsular las mismas funciones o m\u00e9todos que acepte el delegado <code>MiDelegad</code>, <code>string</code> y devuelvan un <code>int</code> en este caso.</p> <p>Sin embargo, los eventos son privados. Esto significa que s\u00f3lo la clase que contiene el evento puede invocarlo. Los eventos se utilizan para notificar a los suscriptores de que ha ocurrido un evento.</p> <p>(cuando usar delegados o eventos)</p> <p>Un evento comparte muchas propiedades con una variable de tipo delegado. La principal consideraci\u00f3n que hemos de tener en cuenta a la hora de elegir entre uno u otro es si es necesario que deba existir un suscriptor conectado o no. Si es necesario que exista un suscriptor conectado, debemos usar un dise\u00f1o basado en delegados. Si no es necesario, debemos usar un dise\u00f1o basado en eventos.</p> <p>Consideremos, por ejemplo, el caso de <code>List.Sort()</code>. A este m\u00e9todo debemos pasarle una funci\u00f3n o m\u00e9todo que nos permita comparar dos elementos de la lista. Por lo tanto, por detr\u00e1s, habr\u00e1 delegados que puedan determinar qu\u00e9 elementos ha de devolver.</p> <p>Por otro lado tenemos el caso de un evento que indique el estado de progreso de una tarea. Si un componente \"barra de progreso\" se subscribe a este evento ir\u00e1 siendo notificada cada vez que cambie el estado de progreso. De este modo podremos ver c\u00f3mo va avanzando la tarea. Si no se subscribe ninguna barra de progreso, la tarea seguir\u00e1 avanzando igualmente (y el evento seguir\u00e1 lanz\u00e1ndose).</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#valores-de-retorno-requieren-usar-delegados","title":"Valores de retorno requieren usar delegados","text":"<p>Otra consideraci\u00f3n a tener en cuenta es si el m\u00e9todo encapsulado que se va a invocar debe devolver un valor. Si sucede esto debemos usar delegados, ya que todos los eventos (por convenio) no pueden devolver ning\u00fan valor. Si no es necesario que devuelva un valor, podemos usar eventos.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.6%20-%20Delegados%20Eventos/#los-eventos-se-invocan-de-manera-privada","title":"Los eventos se invocan de manera privada","text":"<p>No confundir esto con que se declaren de manera privada. Los eventos han de ser declarados de manera p\u00fablica para que los posibles subscriptores puedan subscribirse, pero s\u00f3lo la clase que contiene el evento puede invocarlo.</p> <p>Las clases externas a aquella que contiene el evento s\u00f3lo podr\u00e1n subscribirse o de-subscribirse a dicho evento. La clase que contiene el evento es la \u00fanica que puede invocarlo, es decir, es la \u00fanica que puede disparar el evento.</p> <ol> <li> <p>El null conditional operator acceder\u00e1 al elemento (m\u00e9todo, propiedad, etc.) si el objeto no es <code>null</code>. Si el objeto es <code>null</code> no se producir\u00e1 ning\u00fan error y devolver\u00e1 <code>null</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/","title":"Tema 11.7: Enlazar datos","text":"<p>Cuando creamos nuestras vistas lo m\u00e1s habitual es que queramos mostrar datos que provienen de una fuente de datos (el modelo). En este tema veremos c\u00f3mo enlazar datos a nuestras vistas de manera que cuando el valor de los datos cambie, la vista se actualice autom\u00e1ticamente. Del mismo modo, cuando el usuario modifique los datos de la vista, estos se actualicen en la fuente de datos.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazar-datos","title":"Enlazar datos","text":"<p>Enlazar datos o data binding es la capacidad de enlazar una propiedad de un componente con una propiedad de un objeto. De esta forma, cuando el valor de la propiedad del objeto cambie, el componente se actualizar\u00e1 autom\u00e1ticamente. En este contexto hablaremos de fuente (source) y destino (target) donde el destino es el componente y la fuente es el objeto.</p> <p>Hay cuatro tipos de enlazado de datos:</p> <ol> <li>Enlazado de datos unidireccional: De la fuente al destino. El componente se actualiza cuando cambia el valor de la propiedad del objeto.</li> <li>Enlazado de datos bidireccional: El componente se actualiza cuando cambia el valor de la propiedad del objeto y el objeto se actualiza cuando cambia el valor de la propiedad del componente.</li> <li>Enlazado de datos unidireccional a la fuente: Del destino a la fuente. El objeto se actualiza cuando cambia el valor de la propiedad del componente.</li> <li>Enlazado de datos de una vez: De la fuente al objeto pero que se realizar\u00e1 una sola vez en el constructor.</li> </ol> <p>Hemos dicho que la fuente es el objeto y el destino es el componente. Pero el objeto no tiene porque ser obligatoriamente un objeto de nuestro modelo. Podemos enlazar datos a cualquier objeto como por ejemplo otro componente de la vista. Esto es lo que haremos en el siguiente ejemplo para ilustrar los diferentes tipos de data binding.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#nuestro-ejemplo","title":"Nuestro ejemplo","text":"<p>Crearemos una vista con dos componentes simples: un <code>TextBox</code> y un <code>Slider</code>. El <code>TextBox</code> ser\u00e1 el target y el <code>Slider</code> ser\u00e1 la source. El objetivo es que cuando el usuario modifique el valor del <code>Slider</code> el valor del <code>TextBox</code> se actualice y viceversa.</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Valor:\" /&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"0\" /&gt;\n    &lt;Slider Grid.Row=\"1\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\" Minimum=\"0\" Maximum=\"100\" Value=\"0\" /&gt;\n&lt;/Grid&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazado-de-datos-unidireccional-de-la-fuente-al-destino","title":"Enlazado de datos unidireccional (de la fuente al destino)","text":"<p>Para hacer que nuestro <code>TextBox</code> est\u00e9 enlazado con el <code>Slider</code> debemos utilizar la propiedad <code>Text</code> del <code>TextBox</code> y enlazarla con la propiedad <code>Value</code> del <code>Slider</code>. En primer lugar debemos darle nombre al <code>Slider</code> para poder referenciarlo en el <code>TextBox</code>. Para ello usaremos la propiedad <code>Name</code> del <code>Slider</code>: <code>Name=\"MiSlider\"</code>.</p> <pre><code>&lt;Slider Name=\"MiSlider\" Grid.Row=\"1\" Grid.Column=\"0\" (...) /&gt;\n</code></pre> <p>A continuaci\u00f3n substituiremos el valor de la propiedad <code>Text</code> del <code>TextBox</code> el siguiente valor:</p> <pre><code>&lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"{Binding ElementName=MiSlider, Path=Value, Mode=OneWay}\" /&gt;\n</code></pre> <p>Ahora, cuando el usuario modifique el valor del <code>Slider</code> el valor del <code>TextBox</code> se actualizar\u00e1 autom\u00e1ticamente.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazado-de-datos-bidireccional","title":"Enlazado de datos bidireccional","text":"<p>Para hacer que la actualizaci\u00f3n del <code>TextBox</code> y el <code>Slider</code> se haga en ambos sentidos debemos cambiar el valor de la propiedad <code>Mode</code> a <code>TwoWay</code>.</p> <pre><code>&lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"{Binding ElementName=MiSlider, Path=Value, Mode=TwoWay}\" /&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazado-de-datos-unidireccional-a-la-fuente-del-destino-a-la-fuente","title":"Enlazado de datos unidireccional a la fuente (del destino a la fuente)","text":"<p>Es este caso la actualizaci\u00f3n ser har\u00e1 en el sentido inverso. Es decir, la fuente (el <code>Slider</code>) ser\u00e1 el que modifique su valor cuando el target (el <code>TextBox</code>) modifique su valor (<code>Text</code>).</p> <pre><code>&lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"{Binding ElementName=MiSlider, Path=Value, Mode=OneWayToSource}\" /&gt;\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazado-de-datos-de-una-vez-en-el-constructor","title":"Enlazado de datos de una vez (en el constructor)","text":"<p>En este caso no se vinculan permanentemente los dos componentes. Simplemente sirve para darle un valor inicial (el mismo) a ambos al inicio de la aplicaci\u00f3n. Para ello cambiamos el valor de <code>Mode</code> a <code>OneTime</code> y, a continuaci\u00f3n, en el c\u00f3digo fuente de <code>MainWindow</code> debemos a\u00f1adiremos las siguientes instrucciones:</p> <pre><code>&lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"{Binding ElementName=MiSlider, Path=Value, Mode=OneTime}\" /&gt;\n</code></pre> <pre><code>public MainWindow() {\n    InitializeComponent();\n    // MiSlider es el nombre del componente. Le asignamos un valor inicial.\n    MiSlider.Value = 0;\n    // MiTextBox es el nombre del componente. Le asignamos un valor a partir del valor del Slider.\n    MiTextBox.Text = MiSlider.Value.ToString();\n}\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#cambio-en-tiempo-real","title":"Cambio en tiempo real","text":"<p>Si queremos que los cambios se produzcan en tiempo real debemos a\u00f1adir la propiedad <code>UpdateSourceTrigger</code> con el valor <code>PropertyChanged</code> a la etiqueta <code>Binding</code>.</p> <pre><code>&lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" Text=\"{Binding ElementName=MiSlider, Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" /&gt;\n</code></pre> <p>Esto har\u00e1 que se actualice el aspecto del componente cuando se produzca un cambio en el valor de la propiedad.</p>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.7%20-%20Enlazar%20datos/#enlazado-de-datos-al-modelo","title":"Enlazado de datos al modelo","text":"<p>En un caso m\u00e1s real, en lugar de vincular propiedades de distintos componentes entre si, lo que nos interesar\u00e1 ser\u00e1 vincular propiedades de los componentes a propiedades de nuestro modelo. Para ello usaremos el interfaz <code>INotifyPropertyChanged</code> que nos permite notificar a los componentes que se ha producido un cambio en una propiedad.</p> <p>Para llevar esto a t\u00e9rmino hemos de seguir los siguientes pasos:</p> <ol> <li>Crearemos la clase base de todos nuestros view-models (<code>ViewModelBase</code>) que implementar\u00e1 la interfaz <code>INotifyPropertyChanged</code>.</li> <li>El interfaz <code>INotifyPropertyChanged</code> nos obliga a implementar el m\u00e9todo <code>PropertyChanged</code> que ser\u00e1 el que notifique a los componentes que se ha producido un cambio en una propiedad.</li> <li>Para llevar a cabo esta funci\u00f3n hemos de declarar un evento (<code>PropertyChanged</code>) que ser\u00e1 el que notifique a los componentes que se ha producido un cambio en una propiedad.  Inciso: Recordemos que un evento es un tipo especial de delegado. Esto quiere decir que podremos asociar a un evento varias funciones (m\u00e9todos) que se ejecutar\u00e1n cuando se produzca el evento. En este caso, cuando se produzca el evento <code>PropertyChanged</code> se ejecutar\u00e1n todas las funciones asociadas a \u00e9l. <code>PropertyChanged</code> es un evento del tipo <code>PropertyChangedEventHandler</code> que es un delegado que recibe dos par\u00e1metros: el objeto que ha producido el evento y un objeto de tipo <code>PropertyChangedEventArgs</code> que contiene informaci\u00f3n                                                           sobre el evento.</li> <li>Crearemos tambi\u00e9n un m\u00e9todo <code>OnPropertyChanged</code> que ser\u00e1 el que se encargue de lanzar el evento <code>PropertyChanged</code> cuando se produzca un cambio en una propiedad. Este m\u00e9todo recibir\u00e1 como par\u00e1metro el nombre de la propiedad que ha cambiado.</li> </ol> <p>Una vez hecho esto crearemos las clases view-model que necesitemos para cada vista.</p> <p>En cada vista asignaremos un bloque <code>{Binding ... }</code> donde indicaremos el nombre de la propiedad del modelo que queremos enlazar con la propiedad del componente.</p> <p>En nuestro ejemplo podremos poner <code>Text=\"{Binding Intentos}\"</code> en el <code>TextBlock</code> que muestra el n\u00famero de intentos.</p> <pre><code>public class ViewModelBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected void OnPropertyChanged(string propertyName) {\n        if (PropertyChanged != null) {\n            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n        }\n    }\n}\n</code></pre> <p>Supongamos que en nuestro modelo tenemos la clase <code>Patida</code> una de cuyas propiedades es <code>Intentos</code> que refleja cuantos intentos ha realizar el jugador hasta el momento.</p> <pre><code>public class Partida\n{\n    private readonly int _intentos;\n\n    private readonly int _numero;\n\n    public int Intentos { get { return _intentos} }\n\n    public int Intento(int numero) {\n        ++_intentos;\n        return Math.Abs(numero - _numero);\n    }\n    // ...\n}\n</code></pre> <p>En nuestra vista queremos mostrar el n\u00famero de intentos que lleva el jugador. Para ello utilizaremos la etiqueta <code>&lt;TextBlock&gt;</code>.</p> <pre><code>&lt;TextBlock Text=\"Intentos: 0\" /&gt;    \n</code></pre>"},{"location":"Tema%2011%20-%20GUI/Tema%20-%2011.8%20-%20Comandos/","title":"Tema 11.8: Comandos","text":"<p>Del mismo modo que escribimos una sentencia Binding para enlazar datos a un componente, podremos enlazar tambi\u00e9n un comando.</p> <p>Para enlazar un comando hemos de definir antes uno o m\u00e1s <code>ICommand</code> en la view-model que corresponda.</p> <pre><code>public class MainViewModel : INotifyPropertyChanged\n{\n    // ...\n\n    public ICommand Salvar { get; }\n    public ICommand Cancelar { get; }\n\n    // ...\n\n}\n</code></pre> <p>Haremos esto para que estos comandos est\u00e9n disponibles para la vista. Ya que han de estar en el <code>DataContext</code> asociado a la vista.</p> <p>Adem\u00e1s de ello hemos de definir crear los objetos <code>ICommand</code> para que las propiedades <code>Salvar</code> y <code>Cancelar</code> puedan hagan realmente algo. As\u00ed, crearemos una carpeta con nombre <code>Commands</code> y dentro de ella crearemos dos clases <code>SalvarCommand</code> y <code>CancelarCommand</code> que implementen la interfaz <code>ICommand</code>.</p> <pre><code>public class SalvarCommand : ICommand\n{\n    public event EventHandler CanExecuteChanged;\n\n    public bool CanExecute(object parameter)\n    {\n        throw new NotImplementedException();\n    }\n\n    public void Execute(object parameter)\n    {\n        throw new NotImplementedException();\n    }\n\n}\n</code></pre> <p>Como podemos ver, la interfaz <code>ICommand</code> nos obliga a implementar dos m\u00e9todos: <code>CanExecute</code> y <code>Execute</code>. El primero nos indica si el comando puede ejecutarse y el segundo es el que se ejecuta cuando se ejecuta el comando. En el constructor del comando <code>SalvarCommand</code> podremos pasarle una referencia al modelo para que pueda ejecutar las acciones que sean necesarias.</p> <pre><code>public class SalvarCommand : ICommand\n{\n    private readonly Partida _partida;\n\n    public event EventHandler CanExecuteChanged;\n\n    public SalvarCommand(Partida partida)\n    {\n        _partida = partida;\n    }\n\n    public bool CanExecute(object parameter)\n    {\n        return true;\n    }\n\n    public void Execute(object parameter)\n    {\n        EstadoPartida estado = (EstadoPartida)parameter;\n        _partida.Salvar(estado);\n    }\n\n}\n</code></pre>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/","title":"This is the HOMEPAGE.","text":"<p>Refer to Markdown for how to write markdown files.</p>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/#quick-start-notes","title":"Quick Start Notes:","text":"<ol> <li>Add images to images folder if the file is referencing an image.</li> </ol>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/api/","title":"PLACEHOLDER","text":"<p>TODO: Add .NET projects to src folder and run <code>docfx</code> to generate a REAL API Documentation!</p>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/articles/intro/","title":"Add your introductions here!","text":""},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/articles/toc/","title":"Introduction","text":""},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/docfx_project/","title":"This is the HOMEPAGE.","text":"<p>Refer to Markdown for how to write markdown files.</p>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/docfx_project/#quick-start-notes","title":"Quick Start Notes:","text":"<ol> <li>Add images to the images folder if the file is referencing an image.</li> </ol>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/docfx_project/api/","title":"PLACEHOLDER","text":"<p>TODO: Add .NET projects to the src folder and run <code>docfx</code> to generate REAL API Documentation!</p>"},{"location":"Tema%2011%20-%20GUI/codigo_fuente/ReservasMVVM/ReservasMVVM/docfx_project/articles/intro/","title":"Add your introductions here!","text":""},{"location":"Tema%2012%20-%20Acceso%20a%20BBDD/Tema%20-%2012.0%20-%20Conexi%C3%B3n%20a%20BD/","title":"Bases de datos con C","text":""},{"location":"Tema%2012%20-%20Acceso%20a%20BBDD/Tema%20-%2012.0%20-%20Conexi%C3%B3n%20a%20BD/#conexion-a-bbdd-mysql","title":"Conexi\u00f3n a BBDD MySQL","text":"<p>Para realizar este tema necesitaremos tener instalado el servidor de bases de datos MySQL y el cliente MySQL Workbench.</p>"},{"location":"Tema%2012%20-%20Acceso%20a%20BBDD/Tema%20-%2012.0%20-%20Conexi%C3%B3n%20a%20BD/#conexion-a-bbdd-ms-sql-server","title":"Conexi\u00f3n a BBDD MS SQL Server","text":"<p>Para realizar este tema necesitaremos tener instalado el servidor de bases de datos MS SQL Serever y el cliente SSMS.</p> <p>Utilizaremos al versi\u00f3n gratuita de SQL Server: Developer Edition. Pues en la documentaci\u00f3n se indica que tiene las mismas caracter\u00edsticas que la versi\u00f3n Enterprise Edition (aunque su licencia lo limita su uso a entornos de desarrollo y no de producci\u00f3n).</p> <p>Tambi\u00e9n ser\u00e1 necesario instalar el SSMS (SQL Server Management Studio) para poder administrar la base de datos.</p>"},{"location":"Tema%2012%20-%20Acceso%20a%20BBDD/Tema%20-%2012.0%20-%20Conexi%C3%B3n%20a%20BD/#creacion-de-una-base-de-datos","title":"Creaci\u00f3n de una base de datos","text":"<p>Nombre de la instancia de SQL Server: MSSQLSERVER. Administradores de SQL Server: LAPTOP-KT7R0G0V\\asinc</p> <p>Cadena de conexi\u00f3n a MS Sql Server: <code>Server=localhost;Database=master;Trusted_Connection=True;</code>.</p> <p>Carpeta del registro de instalaci\u00f3n de SQL Server: <code>C:\\Program Files\\Microsoft SQL Server\\160\\Setup Bootstrap\\Log\\20230307_103749</code>.</p> <p>Carpeta de medios de instalaci\u00f3n: <code>C:\\SQL2022\\Developer_ESN</code>.</p>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/","title":"Tema 2: Introducci\u00f3n a Java","text":""},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#hola-mundo","title":"Hola mundo","text":""},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#como-escribir-un-programa-java","title":"\u00bfC\u00f3mo escribir un programa Java?","text":"<p>Un programa en c\u00f3digo Java no es m\u00e1s que un documento de texto con sentencias y sintaxis de Java que puedan ser comprendidas por el compilador.</p> <p>Este fichero de c\u00f3digo fuente ha de tener la extensi\u00f3n <code>.java</code> para que pueda ser reconocido por los IDE (Entornos integrados de desarrollo).</p> <p>As\u00ed, para crear nuestro primer programa Java lo \u00fanico que hemos de hacer es escribir las siguientes l\u00edneas de c\u00f3digo en un fichero de nombre <code>HolaMundo.java</code> (es necesario el nombre <code>HolaMundo</code> como explicaremos m\u00e1s adelante):</p> <pre><code>public class HolaMundo {\n    public static void main(String[] args) {\n        System.out.println(\"Hola mundo.\");\n    }\n}\n</code></pre>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#como-compilar-ejecutar-un-programa","title":"\u00bfC\u00f3mo compilar / ejecutar un programa?","text":""},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#que-significa-compilar","title":"\u00bfQu\u00e9 significa compilar?","text":"<p>Compilar un programa consiste en convertir el c\u00f3digo fuente en c\u00f3digo binario. El c\u00f3digo fuente es el programa tal como nosotros lo hemos escrito en el editor de c\u00f3digo, de manera que es legible por los seres humanos. Por el contrario el c\u00f3digo binario normalmente es \u00fanicamente comprensible por el Sistema Operativo que puede procesarlo y enviarlo al procesador del ordenador para que se ejecuten las instrucciones que escribi\u00f3 el programador.</p> <p>Como podemos ver el c\u00f3digo binario (o simplemente binario) de un programa es dependiente del sistema operativo y el tipo de procesador (arquitectura) de la m\u00e1quina en la que se quiera ejecutar.</p> <p>En Java este proceso es algo diferente. En lugar de compilar para un sistema operativo / arquitectura lo que hace el compilador de Java es crear un binario para ser ejecutado en la m\u00e1quina virtual de java (JVM). Esta m\u00e1quina virtual de java no es m\u00e1s que un programa que entiende el c\u00f3digo binario de Java (Java bytecode).</p> <p>De modo que un programa Java, una vez compilado, podr\u00e1 ser ejecutado por cualquier JVM. Lo que necesitaremos para poder ejecutar un bytecode de Java en cualquier arquitectura es una JVM que corra sobre ella.</p> <p></p>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#entonces-para-ejecutar-un-programa-java-que","title":"Entonces... para ejecutar un programa Java \u00bfQu\u00e9?","text":"<p>Para ejecutar un programa Java hemos de seguir los siguientes pasos:</p> <ol> <li>Compilar a bytecode de Java: <code>javac -verbose HolaMundo.java</code>.</li> <li>Enviarle el bytecode de Java (<code>HolaMundo.class</code>) a la m\u00e1quina virtual: <code>java HolaMundo</code>.</li> </ol> <p>Nota: al ejecutar el segundo paso no se ha de incluir el .class al indicar la clase que queremos ejecutar.</p>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#codificacion-de-texto-y-compilacion","title":"Codificaci\u00f3n de texto y compilaci\u00f3n","text":"<p>Cuando tenemos un fichero de c\u00f3digo fuente podemos verlo como un fichero que contiene texto. Pero en inform\u00e1tica el texto, como cualquier otro contenido: audio, video, im\u00e1genes, gr\u00e1ficos, etc. estar\u00e1 codificado en binario. Y al igual que el audio o el v\u00eddeo hay distintos tipos de codificaci\u00f3n.</p> <p>El programa <code>javac</code>,  compilador de java, por defecto interpreta que los archivos de texto <code>.java</code> que le pasamos est\u00e1n codificados en el formato <code>ASCII</code> por lo que, si tenemos tildes o \"\u00f1\" en nuestro c\u00f3digo este se mostrar\u00e1 incorrectamente (<code>ASCII</code> no soporta tildes ni caracteres distintos de los n\u00famero y el alfabeto ingl\u00e9s) al ejecutarlo. Por ejemplo, si tenemos un archivo (codificado en unicode) con el siguiente c\u00f3digo fuente:</p> <pre><code>public Class MiClase {\n    public static void main(String[] args) {\n        System.out.println(\"Espa\u00f1a es as\u00ed.\");\n    }\n}\n</code></pre> <p>y lo compilamos con: <code>javac .\\MiClase.java</code>.</p> <p>Obtendremos la clase <code>MiClase.class</code>, que al ejecutar con el comando <code>java MiClase</code> mostrar\u00e1 por pantalla <code>Espa\u00c3\u00b1a es as\u00c3\u00ad.</code>.</p> <p>Para corregir esto hemos de indicarle al compilador que nuestro c\u00f3digo fuente est\u00e1 codificado con formato unicode de la siguiente manera: <code>javac -encoding utf8 MiClase.java</code>. Si a continuaci\u00f3n ejecutamos el programa:</p> <pre><code>java MiClase\nEspa\u00f1a es as\u00ed.\n</code></pre>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#clases-jars-classpath-y-otras-cosas-de-meter","title":"Clases, JARs, <code>CLASSPATH</code> y otras cosas de meter","text":"<p>Cuando empecemos a programar usando el modelo de orientaci\u00f3n a objetos nos encontraremos creado librer\u00edas para nuestro proyecto, as\u00ed como utilizando librer\u00edas de terceros. Para que <code>javac</code> y luego <code>java</code> puedan localizar las librer\u00edas que utilizamos (en definitiva los archivos <code>.class</code>) hemos de indic\u00e1rselo y para ello disponemos de dos formas (cada una con sus cosas):</p> <ul> <li>Variable de entorno <code>CLASSPATH</code>. NO RECOMENDABLE.</li> <li>Opciones <code>-cp</code>, <code>-classpath</code> o <code>-class-path</code> (son sin\u00f3nimos) tanto para <code>javac</code> como para <code>java</code>.</li> </ul>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#variable-classpath","title":"Variable <code>CLASSPATH</code>","text":"<p>La variable <code>CLASSPATH</code> contendr\u00e1 una lista de uno o m\u00e1s directorios. Estos directorios son en los que <code>javac</code> y <code>java</code> buscar\u00e1n las clases que indiquemos en las sentencias <code>import</code> de nuestro c\u00f3digo. Com\u00fanmente hemos de indicar el directorio <code>lib</code> de nuestra instalaci\u00f3n de JDK (<code>C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.4.101-hotspot\\lib</code> en nuestro caso), tambi\u00e9n a\u00f1adiremos el directorio actual <code>.</code> para que se puedan encontrar las clases de nuestro directorio. Adem\u00e1s deberemos de indicar el directorio a donde vayamos a guardar las clases de terceros / librer\u00edas que vayamos a utilizar.</p> <p>Si hacemos esto en principio no deber\u00edamos de tener ning\u00fan problema... NING\u00daN PROBLEMA** (JA JA JA JA JA...).</p>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#opcion-cp","title":"Opci\u00f3n <code>-cp</code>","text":"<p>La opci\u00f3n <code>-cp</code> sobrescribe a <code>CLASSPATH</code>. De manera que si usamos <code>-cp</code> el valor que tenga <code>CLASSPATH</code> ser\u00e1 irrelevante. Con esta opci\u00f3n indicamos expl\u00edcitamente los directorios donde se encontrar\u00e1n las clases que usamos en nuestro proyecto.</p> <p>La sintaxis en la siguiente:</p> <ul> <li>Linux: <code>-cp &lt;directorio de clases 1&gt;:&lt;directorio de clases 2&gt;:...</code>.</li> <li>Windows <code>-cp &lt;directorio de clases 1&gt;;&lt;directorio de clases 2&gt;;...</code>.</li> </ul> <p>N\u00f3tese la diferencia en el separador de directorios \":\" en sistemas Linux y \";\" en Windows.</p> <p>Adem\u00e1s de esto es conveniente entrecomillar la lista:</p> <pre><code>javac -cp './lib;.' ./MiClase.java\n</code></pre>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#whiskey-in-the-jars","title":"Whiskey in the JARs","text":"<p>Los archivos <code>.jar</code> consisten fundamentalmente en la estructura de directorios-paquetes de un conjunto de clases de Java (= librer\u00edas). Lo m\u00e1s importante que hemos de tener en cuenta es que, a efectos del CLASSPATH y la opci\u00f3n -cp, un JAR  es un directorio.</p> <p>Repito.</p> <p>UN .jar CUENTA COMO SI FUESE UN DIRECTORIO.</p> <p>Esto implica que si hemos descargado un archivo <code>jar</code> de terceros para usar en nuestro proyecto hemos de realizar alguna de las siguientes acciones:</p> <ul> <li>A\u00f1adirlo a nuestra variable <code>CLASSPATH</code> (<code>CLASSPATH=C:\\libs\\libreria_descargada1.jar;C:\\libs\\libreria_descargada2.jar</code>).</li> <li>Indicarlo expl\u00edcitamente en la opci\u00f3n <code>-cp</code>: <code>-cp 'C:\\libs\\libreria_descargada.jar;.</code>.</li> <li>Descomprimirla dentro de un directorio incluido en <code>CLASSPATH</code> o <code>-cp</code>.</li> <li>O decirle a nuestro EID que lo incluya. LA M\u00c1S RECOMENDABLE.</li> </ul>"},{"location":"Tema%202/T2.0%20-%20Primeros_pasos_java/#comentarios","title":"Comentarios","text":"<p>Cuando escribamos c\u00f3digo en cualquier lenguaje hemos de tener presente que no seremos \u00fanicamente nosotros los que tendremos que entender y posiblemente modificar ese c\u00f3digo. Para ello, cuando estimemos que algo puede ser confuso (para nuestro yo futuro o para otra persona), es conveniente comentar el c\u00f3digo.</p> <p>En Java hay tres tipos de comentarios:</p> <ul> <li>Comentario de una l\u00ednea: Se indica escribiendo <code>//</code> antes de comenzar a escribir el comentario.</li> </ul> <pre><code>int a = 10;\nint b = 10;\nint c = a + b; // Esto no hace falta ni comentarlo.\n</code></pre> <ul> <li>Comentario de varias l\u00edneas: Se indica escribiendo <code>/*</code> al comienzo de las l\u00edneas de comentario y <code>*/</code> al final:</li> </ul> <pre><code>/* Y esto es un ejemplo de como se puede escribir un comentario\nque se extienda varias l\u00edneas. */\nString str = \"Hola mundo\";\nSystem.out.println(str);\n</code></pre> <ul> <li>Comentarios para Javadoc: Los comentarios para Javadoc son similares a los comentarios para varias l\u00edneas pero comienzan con <code>/**</code> en lugar de <code>/*</code>.</li> </ul>"},{"location":"Tema%202/T2.1%20-%20Variables/","title":"Tema 2.1: Variables","text":"<p>Una variable es un nombre que estar\u00e1 enlazado con un espacio de memoria donde se podr\u00e1 almacenar alg\u00fan dato.</p> <p>Para poder utilizar una variable en Java habr\u00e1 de declararla antes.</p>"},{"location":"Tema%202/T2.1%20-%20Variables/#declaracion-de-una-variable","title":"Declaraci\u00f3n de una variable","text":"<p>Para declarar una variable lo primero que hemos de indicar es el tipo de dato de la misma. El tipo de dato determina que tipo de valores podr\u00e1 contener la variable.</p> <p>A continuaci\u00f3n indicaremos el nombre de la variable.</p>"},{"location":"Tema%202/T2.1%20-%20Variables/#limitaciones-en-nombres-de-variables","title":"Limitaciones en nombres de variables","text":"<p>La reglas que rigen el nombrado de las variables son las siguiente:</p> <ul> <li>Los nombres de variables distinguen entre may\u00fasculas y min\u00fasculas (La variable <code>Hola</code> es distinta de <code>hola</code>).</li> <li>Una variable ha de empezar con un car\u00e1cter unicode, el s\u00edmbolo <code>$</code> o el car\u00e1cter subrayado <code>_</code>.</li> <li>La convenci\u00f3n dice que el nombre de una variable ha de empezar con una letra min\u00fascula (y no con <code>$</code> o <code>_</code> aunque est\u00e9 permitido).</li> <li>No se permite el uso de espacios en blanco.</li> <li>Si el nombre elegido para la variable consta de varias palabras (\"c\u00f3digo\" \"libro\" por ejemplo) se pone en may\u00fasculas la primera letra de cada palabra a partir de la primera (\"codigoLibro\").</li> <li>Si la variable almacena una constante, se escribe todo el nombre con MAY\u00daSCULAS y se separar\u00e1n las palabras mediante el car\u00e1cter subrayado <code>_</code> (\"CODIGO_LIBRO\").</li> </ul> <p>Finalmente, y de manera opcional, podremos asignar un valor inicial al la variable utilizando el operador de asignaci\u00f3n <code>=</code>.</p> <pre><code>&lt;tipo de dato&gt; &lt;nombre de la variable&gt; [= valor];\n</code></pre> <pre><code>int x = 1;\nfloat y = 1.5;\nString texto = \"Hola mundo.\";\n</code></pre>"},{"location":"Tema%202/T2.1%20-%20Variables/#variables-inferidas-var","title":"Variables inferidas: <code>var</code>","text":"<p>Desde la versi\u00f3n 10 del JDK tambi\u00e9n se pueden declarar variables utilizando la palabra clave <code>var</code>:</p> <pre><code>var a = 10;\n</code></pre> <p>En este caso el tipo de la variable <code>a</code> de determinar\u00e1 en el momento en que Java vea que se le est\u00e1 asignando el valor 10 (entero). Es decir, la m\u00e1quina virtual infiere el tipo de la variable y se lo asigna.</p> <p>Una vez se le a asignado un tipo la variable <code>a</code> s\u00f3lo podr\u00e1 contener valores de dicho tipo.</p> <p>En nuestro ejemplo el siguiente c\u00f3digo dar\u00eda error de compilaci\u00f3n:</p> <pre><code>var a = 10;\n//...\na = 1.5;\n</code></pre> <p><code>Type mismatch: cannot convert from double to int\"</code>.</p> <p>Ya que en Java los n\u00fameros con cifras decimales se consideran del tipo <code>double</code> (n\u00famero en coma flotante de doble precisi\u00f3n) y <code>a</code> ser\u00e1 una variable de tipo <code>int</code> ya que le asignamos un valor entero.</p>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/","title":"Tema 2.2: Tipos de datos","text":"<p>Java es un lenguaje de tipado est\u00e1tico. Esto quiere decir que hay que indicar siempre el tipo de dato de una variable.</p> <p>Por esto se dice tambi\u00e9n que Java es fuertemente tipado.</p> <p>Un tipo de dato es una declaraci\u00f3n mediante la que se indica el contenido que podr\u00e1 tener una variable.</p>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#consecuencias","title":"Consecuencias","text":"<p>Si intentamos guardar en una variable un dato que no encaja con el que hemos indicado en la declaraci\u00f3n se producir\u00e1 un error de compilaci\u00f3n.</p> <pre><code>int x;\nx = 12.5;\n</code></pre> <pre><code>.\\tarea1\\MiNombre.java:4: error: incompatible types: possible lossy conversion from double to int\n        x = 1.2;\n            ^\n1 error\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#tipos-primitivos","title":"Tipos primitivos","text":"<p>Estos tipos de datos de base tienen como \u00fanica caracter\u00edstica que no son objetos. El resto de elementos del lenguaje Java son objetos.</p> <ul> <li>byte: n\u00fameros enteros que se pueden representar mediante un byte (8 bits). Es decir, los n\u00fameros entre el -128 y el 127 (ambos inclusive).</li> <li>short: n\u00fameros enteros de 16 bits. Los valores enteros entre -32 768 y 32 767.</li> <li>int: similar a los anteriores pero usando 32 bits ($-2^31$)</li> <li>long: lo mismo pero con 64 bits.</li> <li>float: n\u00fameros reales expresados mediante 32 bits.</li> <li>double: n\u00fameros reales representados mediante 64 bits.</li> <li>boolean: dos valore (l\u00f3gicos) posibles: true y false. Utiliza un bit de datos.</li> <li>char*: representa un car\u00e1cter Unicode de 16 bits.</li> </ul>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#nota","title":"Nota","text":"<p>Java toma cualquier dato entero como <code>10.5</code> por defecto como <code>double</code> (aunque pueda ser almacenado sin problemas como <code>float</code>). Lo normal es que siempre se use <code>double</code> cuando trabajemos con n\u00fameros reales.</p>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#y-no-hay-mas-tipos-de-datos","title":"\u00bfY no hay m\u00e1s tipos de datos?","text":"<p>El resto de tipos de datos en Java son objetos.</p> <p>Algunos tipos de datos, aunque sean objetos, tienen comportamientos especiales para facilitar la escritura de c\u00f3digo. Un ejemplo son los tipos String y Array.</p>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#tipo-string","title":"Tipo <code>String</code>","text":"<p>El tipo String se utiliza para almacenar y realizar operaciones sobre cadenas de caracteres.</p> <p>Para crear una variable que haga referencia a una cadena de caracteres escribiremos los siguiente:</p> <pre><code>String str = \"Hola mundo.\";\n</code></pre> <p>Esta es la forma abreviada de escribir el c\u00f3digo. La forma correcta teniendo en cuenta que String es un objeto ser\u00eda:</p> <pre><code>String str = new String(\"Hola mundo.\");\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#tipo-array","title":"Tipo Array","text":"<p>El tipo array (que veremos en detalle m\u00e1s adelante) consiste en una lista de tama\u00f1o fijo de elementos del mismo tipo.</p> <pre><code>// Para definir un array de 10 elementos int:\nint[] enteros = new int[10];\n// Para crearlo con valores iniciales:\nint[] tresEnteros = {1, 2, 3};\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores","title":"Operadores","text":""},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-postfijo-post-indecremento","title":"Operadores postfijo / post-(in/de)cremento","text":"<p>Estos operadores valen para incrementar (<code>++</code>) o decrementar (<code>--</code>) en una unidad el valor de una variable.</p> <p>Tambi\u00e9n se llaman incremento (decremento) diferido.</p> <pre><code>int x = 1;\nx++; // x pasa a valer 2.\nSystem.out.println(x); // Se mostrar\u00e1 el valor 2.\nx--; // x pasa a valer 1.*\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-prefijo-pre-indecremento","title":"Operadores prefijo / pre-(in/de)cremento","text":"<p>Son similares a los anteriores pero con menor prioridad:</p> <pre><code>int x = 1;\n++x; // x pasa a valer 2.\n--x; // x pasa a valer 1.\n</code></pre> <p>La diferencia entre los operadores unarios pre y post incremento / decremento es la siguiente:</p> <ul> <li>pre-incremento/decremento se modifica directamente el valor de la variable.</li> <li>post-incremento/decremento primero se usa el valor actual de la variable y a continuaci\u00f3n se incrementa.</li> </ul> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>// Pre-incremento.\nint x = 0;\nint y = 0;\nint z = ++x + ++y;\n// z tiene el valor 2.\n// x e y tienen el valor 1.\nSystem.out.println(\"z = \" + z);\nSystem.out.println(\"x = \" + z);\nSystem.out.println(\"y = \" + z);\n</code></pre> <pre><code>// Post-incremento.\nint x = 0;\nint y = 0;\nint z = x++ + y++;\n// Primero se usan los valores ACTUALES de x e y para la operaci\u00f3n (suma).\n// por lo que z tomar\u00e1 el valor 0.\n// A continuaci\u00f3n se incrementan.\nSystem.out.println(\"z = \" + z);\nSystem.out.println(\"x = \" + z);\nSystem.out.println(\"y = \" + z);\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos sirven, como su nombre indica, para realizar operaciones aritm\u00e9ticas. La prioridad de ejecuci\u00f3n entre ellos es la com\u00fan entre las calculadores y el uso general:</p> <pre><code>int a = 10; // Operador de asignaci\u00f3n =. Asigna a una variable un valor.\nint b = 20;\nint d = 30;\n\nd = a * b; // Asignamos a c el producto de a por b.\nd = a / b; \nd = a % b; // Operador m\u00f3dulo que guarda en c el RESTO de la division de a entre b.\nd = a + b * c; // Primero multiplicamos b por c y al resultado le a\u00f1adimos a.\nd = a - b * c; // Le restamos a a el producto de b por c.\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-a-nivel-de-bit","title":"Operadores a nivel de bit","text":"<ul> <li><code>&lt;&lt;</code>: Desplaza el n\u00famero a su izquierda tantas posiciones como indique el n\u00famero a su derecha:</li> </ul> <pre><code>int a = 1; // 0001 en binario.\nint b = 3; \nint c = a &lt;&lt; b;\nSystem.out.println(c); // Mostrar\u00e1 el valor 8 (1000)\n</code></pre> <ul> <li><code>&gt;&gt;</code>: Igual que el anterior pero desplazando a la derecha:</li> </ul> <pre><code>int a = 8; // 1000.\nint b = 3;\ninc c = a &gt;&gt; b;\nSystem.out.println(c); // Mostrar\u00e1 1 en pantalla.\n</code></pre> <ul> <li> <p><code>&amp;</code>: And a nivel de bits.</p> </li> <li> <p><code>|</code>: Or a nivel de bits.</p> </li> <li> <p><code>^</code>: Xor a nivel de bits.</p> </li> </ul>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores sirven para comparar dos valores. Devolver\u00e1n true o false dependiendo de si la comparaci\u00f3n es cierta o no.</p> <ul> <li><code>==</code>: El operador igual compara si dos valores son iguales.</li> </ul> <pre><code>int a = 1;\nint b = 2;\nSystem.out.println(a == b); // Mostrar\u00e1 false.\nSystem.out.println(a == b - 1); // Mostrar\u00e1 true.\n</code></pre> <ul> <li><code>!=</code>: El operador distinto devolver\u00e1 cierto cuando los dos valores comparados sean distintos:</li> </ul> <pre><code>int a = 1;\nint b = 2;\nSystem.out.println(a != b); // Mostrar\u00e1 true.\nSystem.out.println(a != b - 1); // Mostrar\u00e1 false.\n</code></pre> <ul> <li><code>&gt;</code> y <code>&gt;=</code>: Los operadores mayor y mayor o igual realizan dicha comparaci\u00f3n:</li> </ul> <pre><code>int a = 0;\nint b = 10;\nint c = 10;\nboolean resultado = a &gt; b; // resultado ser\u00e1 igual a false.\nresultado = b &gt;= c; // resultado ser\u00e1 igual a true.\n</code></pre> <ul> <li><code>&lt;</code> y <code>&lt;=</code>: Son similares a los anteriores.</li> </ul>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores sirven para:</p> <ul> <li>negar (operador <code>!</code>) un valor:</li> </ul> <pre><code>boolean t = true; // Asignamos verdadero a t.\nboolean f = !b; // Asignamos no verdadero (= falso) a f.\nSystem.out.prinln(f); // Mostrar\u00e1 false por pantalla.\n</code></pre> <ul> <li>Hacer la operaci\u00f3n y (and) de dos valores (operador <code>&amp;&amp;</code>):</li> </ul> <pre><code>boolean t = true;\nboolean f = false;\nSystem.out.println(t &amp;&amp; f); // true &amp;&amp; false es igual a false.\nSystem.out.pringln(t &amp;&amp; t); // true &amp;&amp; true es igual a true.\n</code></pre> <ul> <li>Hacer la operaci\u00f3n o (or) de dos valores (operador <code>||</code>):</li> </ul>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operador-ternario","title":"Operador ternario","text":"<p>No es conveniente usarlo ya que vuelve el c\u00f3digo dif\u00edcil de seguir.</p> <p>Tiene tres partes: (condici\u00f3n) ? (resultado si condici\u00f3n true) : (resultado si condici\u00f3n false);</p> <pre><code>int a = 10;\nint b = 20;\nSystem.out.println(a == b ? \"a igual a b\" : \"a distinto de b.\"); // Mostrar\u00e1 \"a distinto de b.\" por pantalla.\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#operador-de-asignacion","title":"Operador de asignaci\u00f3n","text":"<p>S\u00f3lo hay uno <code>=</code> y sirve para asignar un valor a una variable:</p> <pre><code>String a = \"un valor\";\nString b = a;\nboolean c = a == b; // \u00bfCu\u00e1l ser\u00e1 el valor de c?\nb = \"un valor\";\nc = a == b; // \u00bfY ahora?\nb = new String(\"un valor\");\nc = a == b; // \u00bf\u00bfY AHORA??\n</code></pre>"},{"location":"Tema%202/T2.2%20-%20Tipos%20de%20datos/#nota-1","title":"NOTA 1","text":"<p>El operador de asignaci\u00f3n, adem\u00e1s de asignar un valor a una variable, devuelve dicho valor como resultado:</p> <pre><code>int x, y, z;\n\nx = 10;\ny = 20;\n\nint k = (z = x + y);\n\n// Primero se asigna el valor 10 + 20 a z.\n// Despu\u00e9s, el operador = devuelve el valor 30.\n// Finalmente se asigna 30 a k.\n</code></pre>"},{"location":"Tema%202/T2.3%20-%20Tipos_envoltorio/","title":"Tema 2.3: Tipos envoltorio","text":"<p>Vimos en el cap\u00edtulo anterior que en Java existen unos tipos de datos b\u00e1sicos o primitivos (byte, short, int, long, float, double y boolean) que no son objetos. Esto permite que las operaciones con estos tipos sean m\u00e1s \u00e1giles que si tuvi\u00e9semos que operar utilizando clases que los representasen.</p> <p>Una de las recomendaciones para escribir programas Java que sean efectivos (en tiempo y memoria) es evitar la construcci\u00f3n de objetos innecesaria. La existencia de tipos primitivos facilita cumplir esta recomendaci\u00f3n.</p> <p>No obstante sigue siendo necesario disponer de funciones para realizar operaciones con valores de estos tipos de datos, como por ejemplo convertir una cadena de texto a un valor entero o la operaci\u00f3n inversa:</p> <pre><code>String input_num = c.readLine();\nint i = Integer.parseInt(input_num);\n// o el paso inverso:\nString str_int = Integer.toString(i);\n</code></pre> <p>Para centralizar todas estas operaciones se crearon las clases envoltorio (wrapper):</p> <ul> <li><code>Byte</code> para el tipo primitivo <code>byte</code>.</li> <li><code>Short</code> para <code>short</code></li> <li><code>Integer</code> para <code>int</code></li> <li><code>Long</code> para <code>long</code></li> <li><code>Float</code> para <code>float</code></li> <li><code>Double</code> para <code>double</code></li> <li><code>Character</code> para <code>char</code></li> <li><code>Boolean</code> para <code>boolean</code></li> </ul> <p>Las clases envoltorio tambi\u00e9n se pueden usar para crear objetos que representen datos de los tipos a los que envuelven. As\u00ed:</p> <pre><code>Integer diez = new Integer(10);\ndiez.toString();\nbyte_diez = diez.byteValue();\n</code></pre> <p>el c\u00f3digo anterior crea un objeto, <code>diez</code>, de la case <code>Integer</code> que contiene el valor entero 10 y sobre el que se pueden invocar m\u00e9todos como convertirlo a cadena de caracteres o a un tipo <code>byte</code>.</p>"},{"location":"Tema%202/T2.3%20-%20Tipos_envoltorio/#tamano-en-bytes-valores-maximos-y-minimos","title":"Tama\u00f1o en bytes, valores m\u00e1ximos y m\u00ednimos","text":"<p>Los tipos envoltorio, adem\u00e1s de disponer de m\u00e9todos para convertir un texto en el valor representado y viceversa, tambi\u00e9n contienen cierta informaci\u00f3n sobre el tipo de datos que almacenan. As\u00ed, <code>Integer</code> por ejemplo, tiene las constantes:</p> <ul> <li><code>SIZE</code>: Indica el tama\u00f1o en bits del tipo de datos.</li> <li><code>BYTES</code>: El n\u00famero de bytes que ocupa el dato.</li> <li><code>MAX_VALUE</code>: El valor m\u00e1ximo que puede almacenar.</li> <li><code>MIN_VALUE</code>: El menor valor.</li> </ul>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/","title":"Tema 2.4: Cadenas de caracteres","text":"<p>Las cadenas de caracteres se utilizan en los lenguajes de programaci\u00f3n para, b\u00e1sicamente, almacenar texto.</p> <p>La representaci\u00f3n interna de las mismas var\u00eda de lenguaje a lenguaje y, en el caso de Java, se implementan utilizando la case <code>String</code>.</p> <p>La clase <code>String</code> representa secuencias de caracteres. Todos los literales cadena como \"abc\" se implementan mediante instancias de la clase <code>String</code>.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#la-clase-string","title":"La clase <code>String</code>","text":""},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#inmutables","title":"Inmutables","text":"<p>Video sobre la inmutabilidad de las cadenas en Java</p> <p>Los cadenas de tipo <code>String</code> son inmutables. Sus valores no pueden ser modificados despu\u00e9s de su creaci\u00f3n.</p> <p>Gracias a esto, si utilizamos el mismo texto varias veces en nuestro programa, en lugar de crear una cadena nueva la JVM mirar\u00e1 en la lista de palabras usadas si existe un text igual al que queremos utilizar y devolver\u00e1 una referencia al mismo.</p> <p>De este modo si creamos 1000 cadenas con el contenido \"hola mundo\" Java s\u00f3lo guardar\u00e1 este texto una vez en memoria.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#que-quiere-decir-inmutable-exactamente","title":"\u00bfQu\u00e9 quiere decir inmutable exactamente?","text":"<p>Cuando creamos un Objeto String, sus datos no podr\u00e1n ser modificados. En lugar de ello, siempre que modifiquemos una cadena lo que estaremos haciendo en realidad es crear una cadena nueva con los nuevos cambios:</p> <pre><code>String str1 = \"Hola mundo\"; // Creamos un objeto cadena con el contenido \"Hola mundo\".\nString str2 = \"Hola mundo\"; // Creamos otro objeto cadena con el mismo contenido.\nstr1 = str1.toUpperCase();\n\nSystem.out.printf(\"%s.%n\", str1); // Mostrar\u00e1 el texto: \"HOLA MUNDO.\".\nSystem.out.printf(\"%s.%n\", str2); // Mostrar\u00e1 el texto: \"Hola Mundo.\".\n</code></pre>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#impacto-en-la-memoria","title":"Impacto en la memoria","text":"<p>Como dijimos antes Java, en lugar de crear una cadena directamente mira en su lista de palabras a ver si ya existe. Si no existe reserva memoria para ella y la guarda en la lista de palabras por si habr\u00e1 que hacer uso de ella m\u00e1s tarde.</p> <p>Esto significa tambi\u00e9n que si leemos 1000 000 DNIs de una base de datos, aunque solo nos quedemos con el \u00faltimo, todos esos valores ser ir\u00e1n a\u00f1adiendo a la lista de palabras usadas. Lo que podr\u00eda hacer que esta lista (y la memoria que ocupa) fuese creciendo indefinidamente.</p> <p>Adem\u00e1s si nuestro programa fuese a hacer muchos cambios a cadenas de texto (quitarle la letra al DNI pro ejemplo) podr\u00edamos usar mucha memoria ya que cada cambio supondr\u00eda crear una nueva cadena (DNI y DNI sin letra).</p> <p>Para evitar esto Java, adem\u00e1s de la clase <code>String</code> para tratar con cadenas tambi\u00e9n tiene la clase <code>StringBuffer</code> que permite modificar cadenas sin generar nuevas cadenas inmutables en el proceso.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#caracteres-especiales","title":"Caracteres especiales","text":""},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#caracter-de-escape","title":"Car\u00e1cter de escape","text":"<p>El car\u00e1cter \\ se denomina backslash y sirve para escapar caracteres que de otra forma no podr\u00edan escribirse en una cadena.</p> <p>Por ejemplo, si queremos escribir \" dentro de una cadena Java interpretar\u00eda estas comillas como el indicador de fin de cadena. Para evitar eso usaremos el car\u00e1cter de escape:</p> <pre><code>String ejemplo = \"Ella me dijo \\\"no te preocupes\\\"\";\n</code></pre> <p>Lo mismo sucede con \\ y '. Que han de ir precedidos del car\u00e1cter de escape para que se muestren correctamente.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#secuencias-de-escape-comunes","title":"Secuencias de escape comunes","text":"<p>Otros s\u00edmbolos que se escriben utilizando el car\u00e1cter de escape son los siguientes:</p> <ul> <li>\\n Nueve l\u00ednea.</li> <li>\\r Retorno de carro.</li> <li>\\t Tabulaci\u00f3n.</li> <li>\\b Borrar.</li> </ul>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#funciones-de-string","title":"Funciones de <code>String</code>","text":""},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#longitud-de-una-cadena","title":"Longitud de una cadena","text":"<p>El m\u00e9todo <code>length</code> nos devuelve un valor entero que indica cuantos caracteres contiene la cadena:</p> <pre><code>String cadena = \"Hola mundo\";\nint longitud = cadena.length();\n</code></pre>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#pasar-a-mayusculas-minusculas","title":"Pasar a may\u00fasculas / min\u00fasculas","text":"<p>Los m\u00e9todos <code>toUpperCase</code> y <code>toLowerCase</code> nos devolver\u00e1n una cadena similar a la nuestra pero con todos los caracteres en may\u00fasculas o min\u00fasculas.</p> <pre><code>String error = \"ERROR\";\nSystem.out.println(\"Has cometido un \" + error.toUpperCase());\n/*\n   Mostrar\u00e1: \"Has cometido un ERROR\".\n*/\n</code></pre>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#encontrar-una-cadena-dentro-de-otra","title":"Encontrar una cadena dentro de otra","text":"<p>Para comprobar si una cadena aparece dentro de otra cadena podemos usar el m\u00e9todo <code>indexOf</code>. El m\u00e9todo <code>indexOf</code> devuelve la posici\u00f3n (empezando a contar en 0) donde aparece la primera ocurrencia de la cadena buscada y -1 en caso de no encontrar la cadena.</p> <pre><code>String txt = \"La raz\u00f3n de la sinraz\u00f3n...\";\n\nint position = txt.indexOf(\"sinraz\u00f3n\");\n\nSystem.out.printf(\"La palabra sinraz\u00f3n se encuentra el la posici\u00f3n: %d.%n\", position);\n</code></pre> <p>Si lo \u00fanico que queremos es saber si una cadena contiene a otra podremos usar el m\u00e9todo <code>contains</code> que devolver\u00e1 simplemente <code>true</code> o <code>false</code>.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#obtener-un-fragmento-de-la-cadena","title":"Obtener un fragmento de la cadena","text":"<p>Para extraer un fragmento de una cadena podremos emplear el m\u00e9todo <code>subString</code>. \u00c9ste acepta dos valores enteros para indicar d\u00f3nde empezaremos a copiar y hasta donde. <code>subString</code> copia desde la posici\u00f3n inicial (incluy\u00e9ndola) hasta la posici\u00f3n final (sin incluirla). As\u00ed si queremos copiar el texto entre las posiciones 4 y 9 (inclusive) de la cadena \"ornitorrinco\" escribir\u00edamos:</p> <pre><code>String cadena = \"ornitorrinco\";\nString subCadena = cadena.subString(4, 10)\n</code></pre>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#determinar-si-una-cadena-es-vacia","title":"Determinar si una cadena es vac\u00eda","text":"<p>Para determinar si tenemos una cadena vac\u00eda podemos usar el m\u00e9todo <code>isEmpty</code> que devolver\u00e1 <code>true</code> si la longitud de la cadena es 0 y <code>false</code> en caso contrario.</p>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#comparacion-de-cadenas","title":"Comparaci\u00f3n de cadenas","text":"<p>Para comparar dos cadenas tenemos varias opciones.</p> <p>En primer lugar podr\u00edamos usar el operador de comparaci\u00f3n <code>==</code>. Este operador funciona perfectamente cuando comparamos variables que contienen tipos primitivos, pero hemos de recordar que las cadenas (<code>String</code>) no son tipos primitivos si no objetos.</p> <p>El operador <code>==</code>, cuando se aplica a variables que contienen objetos comprueba si los objetos contenidos por las variables son EL MISMO. Ve\u00e1moslo con un ejemplo:</p> <pre><code>// Declaramos una variable cadena:\nString str1 = \"hola\";\nString str2 = \"hola\";\n\n/* \nCuando creamos as\u00ed las cadenas Java no crea dos objetos.\nDetecta que ya tiene un objeto cadena con el texto \"hola\" y se la asigna a la variable str2.\nPor esto veremos que str1 == str2 ser\u00e1 cierto. Son el mismo objeto:\n*/\n\nif (str1 == str2) {\n  System.out.println(\"Los dos objetos son iguales.\"); // Se mostrar\u00e1 este mensaje.\n} else {\n  System.out.println(\"Los dos objetos son distintos.\");\n}\n\n// Ahora bien, si creamos la cadena usando el constructor `String()` s\u00ed se crear\u00e1 un nuevo objeto:\n\nstr2 = new String(\"hola\");\n\nif (str1 == str2) {\n  System.out.println(\"Los dos objetos son iguales.\");\n} else {\n  System.out.println(\"Los dos objetos son distintos.\"); // Esta vez se mostrar\u00e1 este otro.\n}\n</code></pre> <p>Para comparar el contenido de dos cadenas (sin importarnos si son el mismo objeto o no) hemos de usar el m\u00e9todo <code>equals</code>:</p> <pre><code>String str1 = new String(\"hola\");\nString str2 = new String(\"hola\");\n\nif (str1 == str2) {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" son el mismo objeto.\");\n} else if (str1.equals(str2)) {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" NO SON el mismo objeto pero son cadenas iguales.\"); // Se mostrar\u00e1 este texto.\n} else {\n  System.out.println(\"\\\"str1\\\" y \\\"str2\\\" NO SON el mismo objeto NI TIENEN el mismo contenido.\");\n}\n</code></pre>"},{"location":"Tema%202/T2.4%20-%20Cadenas_de_caracteres/#cadenas-con-formato","title":"Cadenas con formato","text":"<p>Hasta este momento estuvimos usando la concatenaci\u00f3n para mostrar cadenas con valores num\u00e9ricos y de otro tipo que hab\u00edamos calculado en nuestros programas:</p> <pre><code>System.out.println(\"Hola \" + nombre + \".\");\n</code></pre> <p>Otra forma de realizar esto es mediante el uso de cadenas con formato:</p> <pre><code>System.out.printf(\"Hola %s.%n\", nombre);\n</code></pre> <p>La forma t\u00edpica de crear cadenas con formato es usando el m\u00e9todo <code>format()</code> de la clase <code>String</code>:</p> <pre><code>String nombre = \"Manuel\";\nint numero = 7;\n\nString str_out = String.format(\"Hola %s tu n\u00famero de la suerte es %d.\", nombre, numero);\nSystem.out.println(str_out);\n</code></pre> <ul> <li><code>%a</code> : Acepta <code>float</code> y genera la representaci\u00f3n hexadecimal del n\u00famero.</li> </ul> <pre><code>System.out.printf(\"%a\", 1.25f);\n//Muestra: 0x1.0p4\n</code></pre> <ul> <li> <p><code>%b</code>: Acepta cualquier tipo y devuelve \"true\" si el argumento es true o no nulo y \"false\" en caso contrario.</p> </li> <li> <p><code>%c</code>: Acepta caracteres unicode y los representa.</p> </li> <li> <p><code>%d</code>: Acepta cualquier valor entero (byte, short, int, long o bigint) y lo representa.</p> </li> <li> <p><code>%e</code>: Acepta un float y lo representa en notaci\u00f3n cient\u00edfica:</p> </li> </ul> <pre><code>System.out.printf(\"%e\", 1.25f);\n// Muestra: 1,250000e+00\n</code></pre> <ul> <li> <p><code>%f</code>: Acepta y representa n\u00fameros float.</p> </li> <li> <p><code>%g</code>: Acepta n\u00fameros reales float y los representa de distintas formas dependiendo de la precisi\u00f3n.</p> </li> <li> <p><code>%h</code>: Acepta cualquier tipo y representa su c\u00f3digo hash (resultado del m\u00e9todo <code>hashCode()</code>).</p> </li> <li> <p><code>%n</code>: No acepta ning\u00fan argumento. Genera una separaci\u00f3n de l\u00edneas compatible con la plataforma en la que estemos programando.</p> </li> <li> <p><code>%o</code>:  Genera la representaci\u00f3n octal de un valor entero.</p> </li> <li> <p><code>%s</code>: Acepta cualquier tipo y lo representa como un cadena de caracteres.</p> </li> <li> <p><code>%t</code>:  Acepta un valor que represente una fecha u hora. La conversi\u00f3n es m\u00e1s compleja como veremos m\u00e1s adelante.</p> </li> <li> <p><code>%x</code>: Representa un valor entero en forma hexadecimal.</p> </li> </ul>"},{"location":"Tema%202/T2.5%20-%20Arrays/","title":"Tema 2.5: Arrays","text":"<p>Un array es una estructura de datos que permite almacenar una secuencia ordenada de elementos. En Java todos los elementos de un array han del ser del mismo tipo y la longitud del mismo ser\u00e1 determinada en el momento de su creaci\u00f3n.</p>"},{"location":"Tema%202/T2.5%20-%20Arrays/#sintaxis","title":"Sintaxis","text":"<p>Para definir una variable de tipo <code>Array</code> hemos de escribir lo siguiente.</p> <pre><code>tipoDeDato[] nombre;\n</code></pre> <p>o bien:</p> <pre><code>tipoDeDato []nombre;\n</code></pre> <p>o bien:</p> <pre><code>tipoDeDato nombre[];\n</code></pre> <p>Para crear un objeto de la clase <code>Array</code> hemos de escribir:</p> <pre><code>arr = new tipoDeDato[tama\u00f1o];\n</code></pre> <p>As\u00ed, si queremos crear un array que pueda contener 100 n\u00fameros enteros escribiremos:</p> <pre><code>int[] enteros = new int[100];\n</code></pre>"},{"location":"Tema%202/T2.5%20-%20Arrays/#manipular-un-array","title":"Manipular un array","text":"<p>Para acceder a cada posici\u00f3n del array lo haremos mediante la siguiente sintaxis:</p> <pre><code>String[] arrStr = {\"adi\u00f3s\", \"mundo\", \"cruel\"};\n\nString cadena = arrStr[0]; // guardamos la cadena \"adi\u00f3s\" en la variable \"cadena\".\n</code></pre> <p>Si queremos asignar un valor a una de las posiciones:</p> <pre><code>arrStr[0] = \"hola\";\n</code></pre>"},{"location":"Tema%202/T2.5%20-%20Arrays/#recorrer-un-array","title":"Recorrer un array","text":"<p>Para recorrer todas las posiciones de un array hemos de usar un bucle.</p>"},{"location":"Tema%202/T2.5%20-%20Arrays/#bucle-for","title":"Bucle <code>for</code>","text":"<p>Tradicionalmente para recorrer un array establec\u00edamos un bucle <code>for</code> y us\u00e1bamos un entero como \u00edndice avanzando desde cero hasta la longitud del array:</p> <pre><code>String[] strArr = new String[100];\n//...\n\nfor (int idx = 0; idx &lt; arr.length; ++idx) {\n    System.out.println(arr[idx]);\n}\n</code></pre>"},{"location":"Tema%202/T2.5%20-%20Arrays/#bucle-for-each","title":"Bucle \"for-each\"","text":"<p>Cuando lo \u00fanico que nos interesa es recorrer todas las posiciones del array podemos usar una versi\u00f3n especial del bucle for dise\u00f1ada especialmente para tal tarea:</p> <pre><code>int[] intArr = new int[100];\n\nfor (int value : arr) {\n    System.out.println(value);\n}\n</code></pre>"},{"location":"Tema%202/T2.5%20-%20Arrays/#arrays-multi-dimensionales","title":"Arrays multi-dimensionales","text":"<p>Un array multidimensional es un array que a su vez est\u00e1 compuesto de arrays:</p> <pre><code>int[][] intArrMulti = {{1, 2, 3}, {4, 5, 6, 7}};\n\nintArrMulti[0][0] = 3;\n</code></pre> <p>Como se puede ver en el ejemplo, el array no tiene porque tener todas las filas de la misma longitud.</p> <p>Para recorrer un array de este tipo usaremos bucles anidados:</p> <pre><code>int[][] intArrMulti = {{1, 2, 3}, {4, 5, 6, 7}};\n\nfor (int idxFil = 0; idxFil &lt; intArrMulti.length; ++idxFil) {\n    for (int idxCol = 0; idxCol &lt; intArrMulti[idxFil].length; ++idxCol) {\n        System.out.printf(\"Fila %d, columna %d = %d.%n\", idxFil, idxCol, intArrMulti[idxFil][idxCol]);\n    }\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/","title":"Tema 2.6: Estructuras de control","text":"<p>En Java hay tres sentencias de control:</p> <ul> <li>Condicionales: Se determina la ejecuci\u00f3n de cierto c\u00f3digo fuente dependiendo de una condici\u00f3n:</li> <li><code>if else</code> / <code>else if</code></li> <li><code>switch</code></li> <li>Repetitiva: Se repetir\u00e1 una secuencia de c\u00f3digo tantas veces como se indique o hasta que se cumpla (o deje de cumplirse) una condici\u00f3n:</li> <li><code>for</code></li> <li><code>while</code></li> <li><code>do ... while</code></li> <li>Salto incondicional: Se utilizan principalmente para saltar o salir de la ejecuci\u00f3n de una iteraci\u00f3n de un bucle:</li> <li><code>break</code>: Interrumpe la ejecuci\u00f3n.</li> <li><code>continue</code>: Salta hasta la siguiente iteraci\u00f3n.</li> </ul> <p>A una estructura de control repetitiva se la llama tambi\u00e9n bucle.</p> <p>Cada una de las veces que se ejecuta el c\u00f3digo de un bucle se dice que se ha producido una iteraci\u00f3n.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#estructuras-condicionales","title":"Estructuras condicionales","text":""},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#if-else-else-if","title":"<code>if else</code> / <code>else if</code>","text":"<p>Esta estructura permitir\u00e1 que se ejecute un bloque de c\u00f3digo u otro dependiendo de la condici\u00f3n.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>if (age &gt;= 18) {\n    // Bloque de c\u00f3digo A.\n    System.out.println(\"Eres mayor de edad.\");\n} else {\n    // Bloque de c\u00f3digo B.\n    System.out.println(\"Eres menor de edad.\");\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#variantes","title":"Variantes","text":"<p>Una variante ser\u00eda omitir la rama del else:</p> <pre><code>if (age &lt; 18) {\n    System.out.println(\"Eres menor.\");\n}\n</code></pre> <p>Otra variante consiste en anidar ifs:</p> <pre><code>if (edad &lt; 12) {\n    System.out.println(\"Eres muy joven para la peli.\");\n} else if (edad &gt;= 12 &amp;&amp; edad &lt; 18) {\n    System.out.println(\"Esta peli es para ti.\");\n} else {\n    System.out.println(\"Eres muy viejo para la peli.\");\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#switch","title":"<code>switch</code>","text":"<p>La instrucci\u00f3n switch se puede realizar mediante if else consecutivos. La idea es que switch sea m\u00e1s legible.</p> <p>La sintaxis de switch es la siguiente:</p> <pre><code>switch (valor_a_comparar) {\n    case valor_de_comparaci\u00f3n_1:\n        // C\u00f3digo a ejecutar si valor_a_comparar == valor_de_comparaci\u00f3n_1.\n        break;\n    case valor_de_comparaci\u00f3n_2:\n        // C\u00f3digo a ejecutar si valor_a_comparar == valor_de_comparaci\u00f3n_2.\n        break;\n    default: // Opcional.\n        // C\u00f3digo a ejecutar en caso de que se haya cumplido ninguna de las igualdades anteriores.\n}\n</code></pre> <p>Un ejemplo del uso de switch ser\u00eda:</p> <pre><code>Console c = System.console();\n\nSystem.out.print(\"Introduzca un n\u00famero entre 1 y 3: \");\nint value = Integer.parseInt(c.readLine());\n\nswitch (value) {\n    case 1: \n        System.out.println(\"El n\u00famero introducido fue uno.\");\n        break;\n    case 2:\n        System.out.println(\"El n\u00famero introducido fue dos.\");\n        break;\n    case 3:\n        System.out.println(\"El n\u00famero introducido fue tres.\");\n        break;\n    default:\n        System.out.println(\"El n\u00famero introducido no estaba entre 1 y 3.\");\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#estructuras-repetitivas-estructuras-iterativas-o-bucles","title":"Estructuras repetitivas (estructuras iterativas o bucles)","text":"<p>Estas estructuras determinan cuantas veces ha de repetirse un bloque de c\u00f3digo. Puede indicarse un n\u00famero fijo de repeticiones, como es el caso del <code>for</code> o establecer una condici\u00f3n para la repetici\u00f3n como es el caso del <code>while</code> y el <code>do while</code>.</p> <p></p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#for","title":"<code>for</code>","text":"<p>El bucle <code>for</code> tiene la siguiente sintaxis:</p> <pre><code>for (&lt;sentencia&gt;; &lt;condici\u00f3n&gt;; &lt;modificaci\u00f3n de la condici\u00f3n&gt;) {\n    // Bloque de c\u00f3digo a repetir\n}\n</code></pre> <p>as\u00ed, un bucle for que muestre los n\u00fameros del 1 al 100 ser\u00eda:</p> <pre><code>for (int i = 1; i &lt;= 100; i += 1) {\n    System.out.println(i);\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#while","title":"<code>while</code>","text":"<p>El bucle <code>while</code> tiene la siguiente sintaxis:</p> <pre><code>while (&lt;condici\u00f3n&gt;) {\n    // Bloque a repetir mientras se cumpla la condici\u00f3n.\n}\n</code></pre> <p>El mismo c\u00f3digo que muestre los n\u00fameros del 1 al 100 con un bucle while ser\u00eda:</p> <pre><code>int i = 1;\nwhile (i &lt;= 100) {\n    System.out.println(i);\n    i = i + 1;\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#do-while","title":"<code>do while</code>","text":"<p>La \u00fanica diferencia con los bucles anteriores es que en este siempre se ejecuta el bloque de c\u00f3digo al menos una vez:</p> <p>Su sintaxis es la siguiente:</p> <pre><code>do {\n    // Bloque a repetir\n} while (&lt;condici\u00f3n&gt;);\n</code></pre> <p>El mismo ejemplo de los casos anteriores con un bucle do while ser\u00eda:</p> <pre><code>int i = 0;\n\ndo {\n    System.out.println(++i);\n} while (i &lt; 100);\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#bucle-for","title":"Bucle <code>for</code>","text":"<p>El bucle for est\u00e1 pensado para repetir un bloque de instrucciones un n\u00famero fijo de veces que conocemos de antemano. Por ejemplo, tantas veces como elementos tenga un array.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#sintaxis","title":"Sintaxis","text":"<pre><code>for ((primera sentencia); (segunda sentencia); (tercera sentencia)) {\n    // Bloque de c\u00f3digo a repetir.\n}\n</code></pre> <p>Cada sentencia ser\u00e1 un bloque de c\u00f3digo con el contenido que se indica a a continuaci\u00f3n.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#primera-sentencia","title":"primera sentencia","text":"<p>Esta sentencia se ejecuta \u00fanicamente una vez antes de iniciar el bucle. Normalmente se declara y se le da valor a una variable que ir\u00e1 modific\u00e1ndose con cada iteraci\u00f3n del bucle.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#condicion-de-continuacion","title":"condici\u00f3n de continuaci\u00f3n","text":"<p>Mientras se cumpla la condici\u00f3n indicada en esta secci\u00f3n el bucle seguir\u00e1 repiti\u00e9ndose. Normalmente es una comparaci\u00f3n respecto a la variable declarada en la primera sentencia.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#segunda-sentencia","title":"segunda sentencia","text":"<p>Esta sentencia se ejecutar\u00e1 cada vez que se ejecute una iteraci\u00f3n del bucle. Normalmente modifica el valor de la variable declarada en la primera sentencia de modo que se acerque cada vez m\u00e1s al fin del bucle (a que la condici\u00f3n de continuaci\u00f3n deje de cumplirse).</p> <p>Un ejemplo con c\u00f3digo real ser\u00eda el siguiente:</p> <pre><code>for (int i = 0; i &lt; 100; i++) {\n    // Mostremos una l\u00ednea de texto por cada iteraci\u00f3n del bucle.\n    System.out.println(\"Iteraci\u00f3n n\u00famero \" + i);\n}\n</code></pre> <ol> <li>En la primera sentencia <code>int i = 0;</code> declaramos y le damos un valor inicial a la variable <code>i</code>.</li> <li>En la segunda sentencia establecemos la condici\u00f3n de terminaci\u00f3n del bucle: <code>i &lt; 100</code>: el bucle se repetir\u00e1 mientras sea cierto que <code>i</code> es menor que <code>100</code>.</li> <li>En la tercera sentencia <code>++i</code> el valor la variable <code>i</code> se incrementa de manera que nos vayamos acercando a la condici\u00f3n de terminaci\u00f3n.</li> </ol>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#sentencias-break-y-continue","title":"Sentencias <code>break</code> y <code>continue</code>","text":"<p>En algunos casos es necesario alterar el normal funcionamiento de un bucle.</p> <p>Imaginemos que normalmente un bucle se ejecutar\u00e1 diez veces pero que deseamos que termine si el usuario introduce un valor que no sea v\u00e1lido. Para forzar la terminaci\u00f3n del bucle, es decir, para romper la repetici\u00f3n usaremos la sentencia <code>break</code>.</p> <p>En otros casos puede que no deseamos terminar el bucle definitivamente pero s\u00ed deseamos saltar el resto del c\u00f3digo y pasar a la siguiente iteraci\u00f3n (o repetici\u00f3n) del bucle. Para ello hemos de usar la sentencia <code>continue</code>.</p>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#break","title":"<code>break</code>","text":"<p>Veamos algunos ejemplos del funcionamiento de la sentencia <code>break</code> de terminaci\u00f3n de un bucle:</p> <p>Si deseamos terminar el bucle si encontramos el valor que no sea v\u00e1lido:</p> <pre><code>do {\n    // Imaginemos que hay un m\u00e9todo que genera un valor.\n    int valor = generaValor();\n\n    // El m\u00e9todo \"esValido\" devolver\u00e1 \"true\" o \"false\" dependiendo de si el valor es o no v\u00e1lido.\n    if (!esValido(valor)) {\n        // Si el valor es no v\u00e1lido salimos fuera del bucle.\n        break;\n    }\n\n    // C\u00f3digo para procesar el valor.\n    // ...\n\n} while (true);\n// C\u00f3digo exterior al bucle.\n// ...\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#continue","title":"<code>continue</code>","text":"<p>Veamos algunos ejemplos del funcionamiento de la sentencia <code>continue</code> de salto a la siguiente iteraci\u00f3n de un bucle:</p> <p>Si quisi\u00e9semos crear un bucle que se saltase las iteraciones m\u00faltiplo de tres podr\u00edamos escribir:</p> <pre><code>for (int i = 0; i &lt; 10; ++i) {\n    if (i % 3 == 0) {\n        continue; // No saltamos todo el c\u00f3digo hasta el principio del siguiente bucle.\n    }\n\n    System.out.println(\"Iteraci\u00f3n n\u00famero \" + i + \".\");\n}\n</code></pre>"},{"location":"Tema%202/T2.6%20-%20Estructuras%20de%20control/#formas-de-terminar-un-bucle","title":"Formas de terminar un bucle","text":"<p>Todo bucle (en general) deber\u00eda de disponer de alg\u00fan mecanismo de terminaci\u00f3n. As\u00ed, los bucles <code>while</code> y <code>do while</code> se repetir\u00edan mientras se cumpla una condici\u00f3n y el bucle <code>for</code> (y el for-each) se repetir\u00edan un n\u00famero predeterminado de veces.</p> <p>No obstante a veces es conveniente terminar un bucle antes de que se alcance la condici\u00f3n de terminaci\u00f3n est\u00e1ndar. Para ello disponemos de varios m\u00e9todos:</p> <ul> <li>Podemos usar la sentencia que acabamos de ver <code>break</code>. Que nos mover\u00e1 a la primera sentencia exterior al bucle.</li> <li>Otra forma de terminar (si estamos dentro de un m\u00e9todo) es retornar el resultado del m\u00e9todo utilizando la sentencia <code>return</code>.</li> <li>Finalmente otra forma de terminar un bucle es terminar la ejecuci\u00f3n del programa mediante la sentencia <code>System.exit(0)</code>.</li> </ul> <p>Un ejemplo de la conveniencia de terminaci\u00f3n anticipada de un bucle es cuando estamos comprobando si un valor se encuentra en un array. Para ello, en principio, hemos de recorrer todo el array comprobando posici\u00f3n a posici\u00f3n (imaginemos un array no ordenado). Pero una vez hayamos encontrado el elemento no necesitamos seguir comprobando el resto de elementos del array. As\u00ed un m\u00e9todo que compruebe si un array contiene un elemento podr\u00eda ser:</p> <pre><code>public static boolean contains(Object[] arr, Object buscado) {\n    for (Object obj : arr) {\n        // Si encontramos dos objetos iguales retornamos true \n        // (el objeto buscado est\u00e1 en el array).\n        if (obj.equals(buscado)) return true;\n    }\n    // Si hemos recorrido todo el array y no hemos encontrado el objeto\n    // buscado retornamos false.\n    return false;\n}\n</code></pre>"},{"location":"Tema%202/T2.7%20-%20Documentacion/","title":"Tema 2.7: Documentaci\u00f3n en Java","text":"<p>Todos los lenguajes de programaci\u00f3n presentan mecanismos para documentar el c\u00f3digo fuente. Podemos decir que hay dos niveles cuando hablamos de documentaci\u00f3n:</p> <ul> <li>Documentaci\u00f3n de una aplicaci\u00f3n web: documentaci\u00f3n que se genera a partir del c\u00f3digo fuente de la aplicaci\u00f3n y que genera un documento que describe el funcionamiento de cada elemento de la aplicaci\u00f3n.</li> <li>Documentaci\u00f3n en el c\u00f3digo fuente: comentarios que se incluyen en el c\u00f3digo fuente.</li> </ul> <p>En Java, la documentaci\u00f3n se realiza mediante comentarios.</p>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#comentarios","title":"Comentarios","text":"<p>Esta es la forma m\u00e1s simple de explicar el funcionamiento de un fragmento de c\u00f3digo. Los comentarios se pueden incluir en cualquier parte del c\u00f3digo fuente y no afectan al funcionamiento del programa. Hay dos tipos de comentarios:</p> <ul> <li>Comentarios de una l\u00ednea: se inician con <code>//</code> y finalizan al final de la l\u00ednea.</li> <li>Comentarios de varias l\u00edneas: se inician con <code>/*</code> y finalizan con <code>*/</code>.</li> </ul> <pre><code>// Comentario de una l\u00ednea:\n// Es conveniente que los comentarios de una l\u00ednea no superen los 80/120\n// caracteres.\n// Si se superan los 80 / 120 caracteres es conveniente dividir el comentario\n// en varias l\u00edneas.\n// Si no se hace es probable que el editor de c\u00f3digo *divida* las l\u00edneas de\n// forma autom\u00e1tica.\n</code></pre> <p>Aunque los comentarios son muy \u00fatiles para dejar recordatorios o explicaciones sobre el c\u00f3digo, no es recomendable abusar de ellos y aplicarlos s\u00f3lo a aquellos fragmentos de c\u00f3digo que lo necesiten (por complejidad o por ser dif\u00edciles de entender).</p> <pre><code>/*\n * Comentario de varias l\u00edneas:\n * Es conveniente que los comentarios de varias l\u00edneas no superen los 80 / 120\n * caracteres.\n * Si se superan los 80 / 120 caracteres es conveniente dividir el comentario\n * en varias l\u00edneas.\n * Si no se hace es probable que el editor de c\u00f3digo *divida* las l\u00edneas de\n * forma autom\u00e1tica.\n */\n</code></pre> <pre><code>// Ejemplos de comentarios:\n// Cuando la l\u00ednea de c\u00f3digo y el comentario son muy cortos, se puede dejar el\n// comentario al final de la l\u00ednea:\n\nint a = 5; // Declaraci\u00f3n de una variable.\n\n// Cuando la l\u00ednea de c\u00f3digo y/o el comentario son muy largos, se puede dejar\n// el comentario en la l\u00ednea anterior (o siguiente):\n\n// Bucle for que recorre un array de enteros:\nfor (int i = 0; i &lt; numeros.length; i++) {\n    System.out.println(numeros[i]);\n}\n</code></pre>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#javadoc","title":"<code>Javadoc</code>","text":"<p>Javadoc es una herramienta que genera la documentaci\u00f3n de una aplicaci\u00f3n Java a partir del c\u00f3digo fuente. Esta herramienta se ejecuta desde la l\u00ednea de comandos (o con la ayuda de un IDE) y genera un documento HTML que describe el funcionamiento de cada interfaz, clase, m\u00e9todos, etc. de la aplicaci\u00f3n.</p> <p>La propia documentaci\u00f3n de Java est\u00e1ndar est\u00e1 generada con Javadoc.</p>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#uso-de-javadoc","title":"Uso de Javadoc","text":"<p>Para usar Javadoc hemos de:</p> <ul> <li>Usar c\u00f3digo fuente que contiene comentarios en el format de Javadoc.</li> <li>Ejecutar la herramienta <code>javadoc</code>.</li> </ul> <p>Por defecto Javadoc genera un documento HTML.</p> <p>Una vez hemos incluido los comentarios Javadoc en nuestro c\u00f3digo fuente, podemos generar la documentaci\u00f3n ejecutando la herramienta <code>javadoc</code> desde la l\u00ednea de comandos.</p>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#sintaxis-del-comando-javadoc","title":"Sintaxis del comando <code>javadoc</code>","text":"<pre><code>javadoc [opciones] [paquetes] [ficheros]\n</code></pre>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#paquetes-y-ficheros","title":"<code>[paquetes]</code> y <code>[ficheros]</code>","text":"<p>Cuando queremos documentar un paquete, debemos indicar el nombre del paquete. Si queremos documentar varios paquetes, debemos separarlos por espacios:</p> <pre><code>javadoc ga.cotarelo.utils ga.cotarelo.ui ga.cotarelo.model\n</code></pre> <p>Si queremos documentar un fichero, debemos indicar el nombre del fichero:</p> <pre><code>javadoc ga.cotarelo.utils.Utils.java\n</code></pre>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#parametros-de-javadoc","title":"Par\u00e1metros de Javadoc","text":"<p>Los principales par\u00e1metros de Javadoc son:</p> <ul> <li>La opci\u00f3n <code>-d docs</code> indica d\u00f3nde se va a generar la documentaci\u00f3n. En este caso, en la carpeta <code>docs</code>.</li> <li>La opci\u00f3n <code>-sourcepath src</code> indica d\u00f3nde se encuentra el c\u00f3digo fuente. En este caso, en la carpeta <code>src</code>.</li> <li>La opci\u00f3n <code>-encoding utf8</code> indica el tipo de codificaci\u00f3n de caracteres que se va a usar. En este caso, <code>utf8</code>.</li> <li>La opcion <code>-locale es_ES</code> indica el idioma que se va a usar. En este caso, <code>es_ES</code> indica que se va a usar el idioma espa\u00f1ol de Espa\u00f1a.</li> </ul>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#comentarios-de-javadoc","title":"Comentarios de Javadoc","text":"<p>Los comentarios de Javadoc se escriben de forma similar a los comentarios de varias l\u00edneas, pero se inician con <code>/**</code> y finalizan con <code>*/</code>. Estos comentarios se pueden incluir en cualquier parte del c\u00f3digo fuente, pero es conveniente que se incluyan en las interfaces, clases, m\u00e9todos, atributos, etc. de la aplicaci\u00f3n.</p> <pre><code>/** \n*\n*/\n</code></pre>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#soporte-para-html-en-los-comentarios","title":"Soporte para HTML en los comentarios","text":"<p>En los comentarios de Javadoc podemos usar c\u00f3digo HTML para dar formato al texto. Por ejemplo, podemos usar etiquetas como <code>&lt;p&gt;</code>, <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>, etc.</p>"},{"location":"Tema%202/T2.7%20-%20Documentacion/#etiquetas-de-javadoc","title":"Etiquetas de Javadoc","text":"<p>A continuaci\u00f3n, veremos una lista de las etiquetas m\u00e1s comunes para generar JavaDoc:</p> Etiqueta Descripci\u00f3n <code>@author</code> Autor de la clase o interfaz. Requerido <code>@version</code> Versi\u00f3n de la clase o interfaz. <code>@param</code> Par\u00e1metro de un m\u00e9todo o constructor. <code>@return</code> Valor de retorno de un m\u00e9todo. <code>@exception</code> Excepci\u00f3n que puede lanzar un m\u00e9todo. <code>@trow</code> Sin\u00f3nimo de <code>@exception</code>. <code>@see</code> Referencia a otra clase, interfaz, m\u00e9todo, etc. <code>@since</code> Versi\u00f3n de Java desde la que se puede usar un m\u00e9todo, clase, etc. <code>@serial</code> Atributo que se serializa. <code>@serialField</code> Atributo que se serializa. <code>@deprecated</code> M\u00e9todo, clase, etc. que est\u00e1 obsoleto."},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/","title":"Tema 2.8: Entrada de datos","text":"<p>Para poder hacer ejercicios necesitamos interactuar con el programa o, al menos, poder indicar con qu\u00e9 datos va a trabajar (datos de entrada).</p> <p>Para ello hemos de ver un par de formas en las que podemos pasar valores a nuestros programas.</p> <p>Estas instrucciones van a ser muy superficiales, simplemente para poder realizar entrada de datos. M\u00e1s adelante las analizaremos en m\u00e1s detalle.</p>"},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/#entrada-por-consola","title":"Entrada por consola","text":""},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/#usando-console","title":"Usando <code>Console</code>","text":"<p>Para leer de la consola (entrada por teclado) primero hemos de acceder a ella. Para hacer esto usaremos la clase <code>Console</code>:</p> <pre><code>import java.io.Console;\n\npublic class InputOutput {\n    public static void main(String[] args) {\n        Console c = System.console(); // Accedemos al objeto Console del sistema.\n        System.out.print(\"Dime tu nombre: \");\n\n        String nombre = c.readLine(); // Quedar\u00e1 esperando a que escribamos un texto y lo guardar\u00e1 en nombre.\n\n        System.out.println(\"\u00a1Hola \" + nombre + \"!\");\n    }\n}\n</code></pre>"},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/#nota-2","title":"NOTA 2","text":"<p>Los datos le\u00eddos con <code>readLine</code> siempre ser\u00e1 cadenas de caracteres. Para poder usarlos como n\u00fameros habr\u00e1 que convertirlos en <code>int</code>, <code>float</code>, etc.</p> <p>Para ello hemos de usar los m\u00e9todos / funciones siguientes:</p> <ul> <li><code>Integer.parseInt()</code>: para convertir una cadena a un valor entero.</li> <li><code>Float.parseFloat()</code>: para obtener un valor.</li> <li><code>Double.parseDouble()</code>: ...</li> </ul> <p>Ve\u00e1moslo en un ejemplo:</p> <pre><code>import java.io.Console;\n\npublic class InputNumbers {\n    public static void main(String[] args) {\n        Console c = System.console(); // Accedemos al objeto Console del sistema.\n\n        // Guaramos lo escrito por teclado en numero.\n        String linea = c.readLine(\"Introduzca un n\u00famero: \"); \n        // Puesto que es una cadena (String) hemos de convertirlo al tipo \n        // que nos interesa.\n        int numero = Integer.parseInt(linea);\n        System.out.println(\"El valor \" + linea + \" + 10 vale \" + (numero + 10) + \".\");\n    }\n}\n</code></pre>"},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/#usando-scanner","title":"Usando <code>Scanner</code>","text":"<p>Scanner es ligeramente distinto a <code>Console</code>.  Es m\u00e1s flexible pues no s\u00f3lo sirve para leer del teclado si no que tambi\u00e9n se puede asociar a:</p> <ul> <li>Una cadena de texto.</li> <li>Un fichero del sistema.</li> <li>La entrada por defecto del programa (teclado).</li> <li>A un socket (conexi\u00f3n a la que se pueden unir otros procesos).</li> </ul> <p>Puesto que es m\u00e1s flexible es algo m\u00e1s complejo de utilizar y no ofrece tantas comodidades como <code>Console</code> para acceder a los datos introducidos por el teclado.</p> <p>NOTA: Hay que tener en cuenta que es necesario cerrar el scanner cuando ya no lo vayamos a volver a utilizar.</p> <p>Veamos un ejemplo de uso:</p> <pre><code>import java.util.Scanner;\n\npublic class PrimerosPasos {\n\n    public static void main(String[] args) {\n        String linea = null;\n\n        // La sentencia try (&lt;recurso&gt;) { // bloque }\n        // asegura que el recurso ser\u00e1 cerrado (liberado) cuando termine el bloque.\n        try (Scanner input = new Scanner(System.in)) {\n            linea = input.nextLine();\n        }\n\n        System.out.println(\"Le\u00eddo el texto: \" + linea + \".\");\n\n        // Si deseamos convertirlo a un valor entero:\n        int value = Integer.parseInt(linea);\n\n        System.out.println(\"El valor le\u00eddo es: \" + value + \".\");\n    }\n}\n</code></pre>"},{"location":"Tema%202/T2.8%20-%20Entrada%20de%20datos/#parametros-argumentos","title":"Par\u00e1metros / Argumentos","text":"<p>Cuando creamos el m\u00e9todo <code>main</code> podemos ver que a continuaci\u00f3n sigue la siguiente secuencia <code>(String[] args)</code>. Esta \u00faltima parte est\u00e1 indicando el que m\u00e9todo <code>main</code> recibe como argumento un array de cadenas (una lista de valores <code>String</code>) .</p> <p>Este m\u00e9todo ser\u00e1 utilizado por la m\u00e1quina virtual de Java para pasar al programa los argumentos que indiquemos por consola en el momento de ejecutarlo.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>public class Argumentos {\n    public static void main(String[] args) {\n        System.out.println(\"El primer argumento fue: \" + args[0]);\n        System.out.println(\"El segundo argumento fue: \" + args[1]);\n        System.out.println(\"El tercer argumento fue: \" + args[2]);\n    }\n}\n</code></pre> <p>Si ahora compilamos e invocamos el programa:</p> <pre><code>javac Argumentos.java\njava Argumentos Adi\u00f3s Mundo Cruel\n</code></pre> <p>El resultado ser\u00e1:</p> <pre><code>El primer argumento fue: Adi\u00f3s\nEl segundo argumento fue: Mundo\nEl tercer argumento fue: Cruel\n</code></pre>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/","title":"Ejercicios Tema 2: Programaci\u00f3n estructurada, arrays y cadenas","text":"<p>Los ejercicios de este tema se centrar\u00e1n en la manipulaci\u00f3n de arrays y cadenas utilizando sus m\u00e9todos as\u00ed como los elementos (bifurcaci\u00f3n condicional y bucles) de la programaci\u00f3n estructurada.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Escribe un programa que pida al usuario dos palabras por consola e indique si son iguales o disntintas.</p> <p>Soluci\u00f3n ejercicio 1.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Tomando como base el c\u00f3digo del ejercicio anterior, haz que el programa nos indique que palabra est\u00e1 antes lexicogr\u00e1ficamente.</p> <p>Soluci\u00f3n ejercicio 2.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Haz ahora que el programa permita introducir hasta 10 palabras y las almacene en un array de cadenas. El usuario podr\u00e1 interrumpir la introducci\u00f3n de cadenas si pulsa ENTER sin escribir nada (cadena vac\u00eda).</p> <p>Una vez terminada la introducci\u00f3n de cadenas muestra al usuario la lista de palabras introducidas.</p> <p>Soluci\u00f3n ejercicio 3.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Modifica el programa anterior para que ordene las palabras introducidas previamente por el usuario. (Pista: <code>java.util.Arrays.sort()</code>).</p> <p>Soluci\u00f3n ejercicio 4.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-5","title":"Ejercicio 5","text":"<p>Haz que el programa ponga el may\u00fasculas la primera letra de cada palabra.</p> <p>Soluci\u00f3n ejercicio 5.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#ejercicio-6","title":"Ejercicio 6","text":"<p>Crea un m\u00e9todo (est\u00e1tico) que reciba un array de palabras como entrada y devuelva una copia del array con las palabras ordenadas.</p>"},{"location":"Tema%202/Ejercicios/T2%20-%20Ejercicios/#extra","title":"EXTRA","text":"<p>Ejercicio opcional.</p> <p>Escribe en  programa que permita al usuario introducir una lista de palabras (sin l\u00edmite predefinido).</p> <p>Una vez haya terminado (cuando inserte una palabra vac\u00eda).</p> <p>Se le mostrar\u00e1 la lista de palabras y se le perdir\u00e1 que la ordene.</p> <p>Para ello se le pedir\u00e1n dos n\u00fameros que indicar\u00e1n al programa las posiciones de dos palabras de la lista que ha de intercambiar.</p> <p>Esto se repetir\u00e1 hasta que la lista est\u00e9 ordenada.</p> <p>El programa ha de:</p> <ul> <li>Comprobar que el usuario introduce palabras simples (sin espacios o may\u00fasculas).</li> <li>Comprobar que los \u00edndices son v\u00e1lidos (el usuario no intenta acceder a \u00edndices fuera del array).</li> <li>Verificar si el array ordenado por el usuario est\u00e1 correctamente ordeando.</li> </ul> <p>Pistas:</p> <ul> <li><code>ArrayList</code>.</li> <li><code>ArrayList.sort(null)</code>.</li> </ul>"},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jquery/","title":"Jquery","text":""},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jquery/#jquery-v351","title":"jQuery v3.5.1","text":""},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.5.1\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n******************************************\n\nThe jQuery JavaScript Library v3.5.1 also includes Sizzle.js\n\nSizzle.js includes the following license:\n\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/sizzle\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n*********************\n</code></pre>"},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jqueryUI/#jquery-ui-v1121","title":"jQuery UI v1.12.1","text":""},{"location":"Tema%202/codigo_fuente/documentacion/docs/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jquery/","title":"Jquery","text":""},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jquery/#jquery-v351","title":"jQuery v3.5.1","text":""},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.5.1\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n******************************************\n\nThe jQuery JavaScript Library v3.5.1 also includes Sizzle.js\n\nSizzle.js includes the following license:\n\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/sizzle\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n*********************\n</code></pre>"},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jqueryUI/#jquery-ui-v1121","title":"jQuery UI v1.12.1","text":""},{"location":"Tema%202/codigo_fuente/documentacion/documentacion/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/","title":"Tema 3: Programaci\u00f3n orientada a objetos","text":""},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#clase","title":"Clase","text":"<p>La funci\u00f3n de las clases es la de definir las caracter\u00edsticas de un conjunto de objetos (los objetos de dicha clase).</p> <p>La clase define la estructura o modelo que se seguir\u00e1 cuando se construyan objetos de dicho tipo (o clase).</p> <p>Define las propiedades (estado o datos) que tendr\u00e1n los objetos de la clase as\u00ed como los procedimientos que se podr\u00e1n invocar sobre el objeto.</p> <p>Adem\u00e1s de ello una clase puede tener tambi\u00e9n datos y procedimientos propios, independientes de la existencia de objetos.</p>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#ejemplo","title":"Ejemplo:","text":"<p>Por ejemplo, si estamos desarrollando una aplicaci\u00f3n para una cl\u00ednica veterinaria, podr\u00edamos definir una clase Animal y entre las propiedades de la clase podr\u00edamos tener: nombre, fecha de nacimiento, patolog\u00eda, historial, etc.</p> <p>Tambi\u00e9n tendr\u00eda sentido tener una clase Propietario para modelar el comportamiento (en lo que a la actividad de la cl\u00ednica se refiere) y una clase Historial para centralizar informaci\u00f3n y operaciones relativas al historial sanitario del animal.</p> <p>Cada vez que creamos (o instanciamos) un objeto hemos de tener en cuenta que pertenece a una clase. Y que las tripas del objeto se describen en la dicha clase.</p> <pre><code>public class Animal {\n    public String nombre; // Propiedad de todo animal.\n    public long fecha_nacimiento;\n    public String patologia;\n    // etc.\n}\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#objeto","title":"Objeto","text":"<p>Un objeto es una instancia de una clase.</p> <p>Las instancias se crean mediante el uso de la instrucci\u00f3n new, seguida del nombre de la clase a la que pertenecer\u00e1 nuestro objeto:</p> <pre><code>Animal chuchi = new Animal();\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#propiedades","title":"Propiedades","text":"<p>Las propiedades son variables ligadas a una clase (variables de clase) o a una instancia de la clase (objeto) (variables de instancia).</p> <pre><code>chuchi.nombre = \"Chuchi\u00f1o\";\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#metodo","title":"M\u00e9todo","text":"<p>Un m\u00e9todo es un programa o algoritmo que, al igual que las propiedades, est\u00e1 ligado a una clase (m\u00e9todos de clase) o a una instancia de la clase (m\u00e9todos de instancia).</p> <pre><code>// En la clase animal definimos un m\u00e9todo para todos los miembros de la clase:\npublic class Animal {\n    public String nombre;\n\n    public void ponerNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String dimeTuNombre() {\n        return this.nombre;\n    }\n}\n</code></pre> <p>Ahora todos los animales tendr\u00e1 los m\u00e9todos <code>ponerNombre</code> y <code>dimeTuNombre</code>.</p> <p>Para invocar un m\u00e9todo hemos de poner primero el objeto (o la clase si es un m\u00e9todo est\u00e1tico) seguido de \".\" y el nombre del m\u00e9todo:</p> <pre><code>// objeto.m\u00e9todo(par\u00e1metros);\nchuchi.ponerNombre(\"Chuchi\u00f1o\")\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#abstraccion-de-datos","title":"Abstracci\u00f3n de datos","text":"<p>Se trata de un patr\u00f3n de dise\u00f1o que implica que los datos (estado interno de un objeto, o clase) no podr\u00e1n ser accedidos directamente, si no que se har\u00e1 mediante una funci\u00f3n (o m\u00e9todo).</p> <p>De esta forma nada externo al objeto tiene que conocer c\u00f3mo est\u00e1 almacenada la informaci\u00f3n del objeto (estado interno).</p> <p>Ser\u00e1 el objeto el que ofrezca m\u00e9todos para informar de su estado interno (getters) o para modificarlo (setters).</p> <pre><code>public class Animal {\n    private String nombre;\n\n    // M\u00e9todo para establecer el valor de nombre: setter.\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // M\u00e9todo para obtener el valor de nombre: getter.\n    public String getNombre() {\n        return this.nombre;\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>Relacionado con el concepto anterior, la encapsulaci\u00f3n evita que el c\u00f3digo exterior al objeto tenga que conocer la estructura interna del objeto.</p> <p>Esta pr\u00e1ctica facilita tambi\u00e9n que se evite el acoplamiento.</p> <p>El hecho de que la clase est\u00e9 desacoplada del resto de clases permite que los cambios internos que hagamos no afecten a ning\u00fan otro elemento externo: otras clases y m\u00e9todos.</p> <p>Esto facilita la refactorizaci\u00f3n, dado que el creador de una clase podr\u00e1 cambiar la representaci\u00f3n interna de los datos del objeto (mientras no cambie los m\u00e9todos p\u00fablicos de la clase).</p>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#visibilidad","title":"Visibilidad","text":"<p>El concepto de visibilidad determina qui\u00e9n y desde d\u00f3nde podr\u00e1 ver (o acceder) a un elemento.</p> <p>La visibilidad en Java se determina anteponiendo a un elemento (clase, campo, m\u00e9todo, etc.) alguna de las siguientes palabras reservadas</p> <ul> <li><code>public</code></li> <li><code>protected</code></li> <li><code>private</code></li> </ul> <p>Adem\u00e1s, en caso de que no se indique ninguna de ellas se aplicar\u00e1 otro tipo de visibilidad (<code>package-protected</code>).</p> <p>La palabra <code>public</code> indica que cualquier elemento, desde cualquier lugar podr\u00e1 acceder al elemento p\u00fablico.</p> <p><code>private</code>, por el contrario, indicar\u00e1 que el elemento ser\u00e1 visible \u00fanicamente desde el interior del elemento donde se ha definido.</p>"},{"location":"Tema%203/T3.0%20-%20Programaci%C3%B3n%20orientada%20a%20objetos/#herencia","title":"Herencia","text":"<p>El concepto de herencia se refiere al mecanismo que se utiliza en programaci\u00f3n orientada a objetos para hacer que una clase (clase hija o sub-clase) herede las caracter\u00edsticas de otra clase (clase padre o super-clase). La clase hija, adem\u00e1s de heredar todas las propiedades de la clase padre podr\u00e1 sobre-escribirlas y a\u00f1adir caracter\u00edsticas nueva.</p> <p>Mediante este mecanismo nos ahorramos la repetici\u00f3n de c\u00f3digo.</p> <p>Un ejemplo de herencia ser\u00eda que las clases <code>Alumno</code> y <code>Profesor</code> heredasen de la clase <code>Persona</code>.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/","title":"Tema 3.1: Anatom\u00eda de una Clase","text":"<p>En este tema veremos los elementos b\u00e1sicos de una clase de Java y que efecto tienen a la hora de crear instancias / objetos de dicha clase.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#creacion-de-una-clase","title":"Creaci\u00f3n de una clase","text":"<p>Para crear una clase seguiremos la siguiente sintaxis:</p> <pre><code>public class MiClase {\n    // C\u00f3digo de la clase.\n}\n</code></pre> <p>Los nombres de las clases empiezan siempre por may\u00fascula y tienen que coincidir con el nombre del fichero donde est\u00e1n guardadas.</p> <p>As\u00ed, el nombre del fichero con el c\u00f3digo fuente de nuestra clase <code>MiClase</code> ha de llamarse <code>MiClase.java</code>.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-o-campos","title":"Propiedades o campos","text":"<p>Las propiedades o campos de una clase son declaraciones de variables que almacenar\u00e1n informaci\u00f3n sobre las caracter\u00edsticas de los objetos de de dicha clase (lo m\u00e1s com\u00fan) o que guardar\u00e1n informaci\u00f3n sobre la propia clase.</p> <p>Las propiedades de instancia (objeto) se pueden definir como el estado interno del objeto. Pueden ser visibles o no desde el exterior (apartado Visibilidad de este tema) y se ir\u00e1n modificando en respuesta a la invocaci\u00f3n de los m\u00e9todos del objeto.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#sintaxis-de-una-propiedad","title":"Sintaxis de una propiedad","text":"<p>La sintaxis para la definici\u00f3n de un campo o propiedad es la siguiente:</p> <pre><code>[visibilidad] [static] [final] tipo nombre;\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-de-instancia","title":"Propiedades de instancia","text":"<p>Para crear una propiedad de instancia simplemente hemos de declarar una variable dentro del bloque de c\u00f3digo de la clase que hayamos definido:</p> <pre><code>public class MiClase {\n    int mi_variable_de_instancia;\n}\n</code></pre> <p>Cuando creemos un objeto de la clase <code>MiClase</code>, \u00e9ste tendr\u00e1 una propiedad de tipo entero con el nombre <code>mi_variable_de_instancia</code>.</p> <p>Para acceder directamente a una propiedad de instancia hemos de escribir el nombre del objeto seguido de <code>.</code> y el nombre de su propiedad:</p> <pre><code>MiClase mi_objeto = new MiClase();\nmi_objeto.mi_variable_de_instancia = 10;\n</code></pre> <p>En general no se recomienda acceder directamente a las variables internas de un objeto. En su lugar se crear\u00e1n m\u00e9todos para leer o modificar las variables internas del mismo.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#propiedades-de-clase","title":"Propiedades de clase","text":"<p>Las propiedades de clase son variables que, en lugar de necesitar de una instancia (objeto) para existir, depender\u00e1n \u00fanicamente de la clase. Para definirlas hemos de preceder la declaraci\u00f3n de la variable de la palabra reservada <code>static</code>:</p> <pre><code>public class MiClase {\n    static int mi_variable_de_clase;\n    int mi_variable_de_instancia;\n}\n</code></pre> <p>Al igual que con las propiedades de instancia, para acceder a la propiedad de una clase hemos de poner el nombre de la clase seguido de <code>.</code> y el nombre de la propiedad:</p> <pre><code>MiClase.mi_variable_de_clase = 10;\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos","title":"M\u00e9todos","text":"<p>Un m\u00e9todo consiste en crear un mini programa al que le daremos nombre, para poder utilizarlo m\u00faltiples veces desde distintos lugares.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#sintaxis-de-un-metodo","title":"Sintaxis de un m\u00e9todo","text":"<pre><code>[visibilidad] [static] [tipo | void] nombre ([par\u00e1metros])\n</code></pre> <p>Donde:</p> <ul> <li>Visibilidad podr\u00e1 ser <code>public</code>, <code>protected</code> o <code>private</code>.</li> <li><code>static</code> es opcional e indica si el m\u00e9todo es de instancia o clase.</li> <li>El tipo ha de indicarse en caso de que el m\u00e9todo devuelva alg\u00fan valor. En caso contrario usaremos <code>void</code> en lugar de tipo.</li> <li>El nombre cumplir\u00e1 una reglas similares al nombre de una variable.</li> <li>Los par\u00e1metros (opcionales) indica qu\u00e9 datos de entrada admitir\u00e1 el m\u00e9todo. Los par\u00e1metros se declaran como cualquier variable e ir\u00e1n separados por <code>,</code>.</li> </ul>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#argumentos-y-parametros","title":"Argumentos y par\u00e1metros","text":"<p>Cuando definimos un m\u00e9todo lo que indicamos (en caso de que haya alguno) son los par\u00e1metros que puede aceptar.</p> <p>Cuando invocamos o llamamos al m\u00e9todo le pasamos los argumentos que requiere.</p> <p>Por lo tanto los argumentos de un m\u00e9todo han de ser compatibles con los par\u00e1metros que hayamos indicado cuando definimos el m\u00e9todo.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#ejemplo","title":"Ejemplo","text":"<pre><code>public class MiClase {\n    public static String metodo1(String str, int x) {\n        return str + x;\n    }\n\n    public static void main(String[] args) {\n        String texto = metodo1(\"N\u00famero\", 3);\n        System.out.println(texto);\n\n        // Si llamamos al m\u00e9todo \"metodo1\" de la siguiente manera:\n        texto = metodo1(\"Error\");\n        // Saltar\u00e1 un error pues no podemos invocar al m\u00e9todo sin pasarle todos los argumentos en el orden correcto.\n        // En este caso una cadena y un valor entero.\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<p>Los m\u00e9todos de instancia son bloques de c\u00f3digo con unas entradas (par\u00e1metros de entrada) y una salidas (valor de retorno).</p> <p>As\u00ed un m\u00e9todo <code>suma</code> podr\u00eda tener como par\u00e1metros de entrada dos variables de tipo entero y como salida un valor tambi\u00e9n de tipo entero:</p> <pre><code>int suma(int x, int y) {\n    // C\u00f3digo del m\u00e9todo.\n}\n</code></pre> <p>Los m\u00e9todos de instancia solo existir\u00e1n cuando se cree un objeto. Para invocarlos hemos de escribir el nombre del objeto seguido de <code>.</code> y el nombre del m\u00e9todo:</p> <p>C\u00f3digo de la clase:</p> <pre><code>public class Figura {\n String nombre;\n public int suma(int x, int y) {\n        int resultado = x + y;\n        return resultado;\n }\n}\n</code></pre> <p>C\u00f3digo donde creamos el objeto:</p> <pre><code>//...\nFigura circulo = new Figura();\nint valor = circulo.suma(5, 3);\n// valor tendr\u00e1 el valor 8.\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Como hemos visto en el ejemplo anterior, para crear un objeto hemos de usar la palabra reservada <code>!#java new</code> seguido del nombre de la clase que queremos instanciar y + <code>()</code>. Dentro de los <code>()</code> introduciremos los argumentos que necesite el constructor de la clase (si es que necesita alguno) como veremos m\u00e1s adelante en el apartado Constructor.</p> <pre><code>class Figura {\n    public String nombre;\n    public int num_lados;\n}\n</code></pre> <p>Creaci\u00f3n de un objeto de la clase / tipo <code>Figura</code>:</p> <pre><code>//...\nFigura circulo = new Figura;\ncirculo.nombre = c\u00edrculo;\ncirculo.num_lados = 1;\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#metodos-de-clase","title":"M\u00e9todos de clase","text":"<p>Los m\u00e9todos de clase, al igual que las propiedades de clase no estar\u00e1n ligados a ning\u00fan objeto por lo que no necesitar\u00e1n que se cree un objeto para existir. Est\u00e1n, por el contrario, ligados directamente a la clase donde se definan. Para invocarlos hemos de escribir el nombre de la clase seguido de <code>.</code> y el nombre del m\u00e9todo.</p> <pre><code>class Aleatorio {\n    public static int enteroAleatorio(int min, int max) {\n        Random r = new Random();\n        return r.nextInt(max - min) + min;\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#constructor","title":"Constructor","text":"<p>El constructor de una clase es un m\u00e9todo especial que sirve para establecer el estado inicial de cada nuevo objeto que creemos de una clase.</p> <p>Es decir, asignar\u00e1 valores a las propiedades de instancia.</p> <p>El constructor de una clase se define como un m\u00e9todo sin valor de retorno (pues lo que crea es evidente) y con el nombre igual al de la clase para la cual se define.</p> <p>Podemos definir varios constructores (con distintos par\u00e1metros) para una misma clase:</p> <pre><code>class MiClase {\n    int m_v_d_i;\n\n    // Primer constructor.\n    public MiClase() {\n        m_v_d_i = 0;\n    }\n\n    public MiClase(int x) {\n        m_v_d_i = x;\n    }\n\n    public static void main(String[] args) {\n        // Creamos un objeto usando el primero constructor.\n        MiClase miObj1 = new MiClase();\n        System.out.println(miObj1.m_v_d_i); // Mostrar\u00e1 el valor 0.\n\n        // Creamos un segundo objeto usando el segundo constructor.\n        MiClase miObj2 = new MiClase(10);\n        System.out.println(miObj2.m_v_d_i); // Mostrar\u00e1 el valor 1.\n    }\n}\n</code></pre> <p>NOTA: Clase sin constructor:</p> <p>Cuando no definimos un constructor para una clase sigue existiendo un constructor. Este es el constructor por defecto de la clase padre: <code>Object</code>.</p>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#destructor","title":"Destructor","text":"<p>En general en Java no tendremos un m\u00e9todo destructor de objetos. Cuando una instancia de una clase ya no sea accesible el recolector de basura se encargar\u00e1 de ella (liberar\u00e1 la memoria que estuviese utilizando).</p> <p>Una clase ser\u00e1 accesible siempre que tenga alguna variable que la referencie.</p> <pre><code>MiClase obj1 = new MiClase(); // la variable obj1 apunta a un objeto de la clase MiClase. Una variable referencia al objeto.\nMiClase obj2 = obj1; // la variable obj2 apunta al mismo objeto. Dos variables referencian al objeto.\nobj1 = null; // la variable obj1 deja de referenciar al objeto. Una variable referencia al objeto.\nobj2 = null; // la variable ojb2 deja de referenciar al objeto. Ninguna variable referencia al objeto.\n/*\nEn este punto el objeto ya no ser\u00eda accesible. No hay forma de referenciarlo. \"Hemos perdido su informaci\u00f3n de contacto\".\nEl objeto podr\u00e1 ser recogido por el recolector de Basura en cualquier momento.\n*/\n</code></pre>"},{"location":"Tema%203/T3.1%20-%20Anatom%C3%ADa%20de%20una%20clase/#visibilidad","title":"Visibilidad","text":"<p>Es hora de que hablemos de los public que aparecen delante de nuestras declaraciones de clases, propiedades y m\u00e9todos.</p> <p>La palabra reservada <code>public</code>, junto con <code>protected</code> y <code>private</code> determinan la visibilidad que tendr\u00e1 la clase, propiedad o m\u00e9todo al que se le apliquen desde fuera de la clase.</p> <ul> <li><code>public</code>: Todo el mundo podr\u00e1 ver la clase/propiedad/m\u00e9todo desde fuera de la clase.</li> <li><code>protected</code>: S\u00f3lo las clases compa\u00f1eras (del mismo paquete) podr\u00e1n ver la clase/propiedad/m\u00e9todo de nuestra clase.</li> <li><code>private</code>: Nadie fuera de la propia clase podr\u00e1 ver la clase/propiedad/m\u00e9todo de esta clase.</li> </ul> <pre><code>public class MiClase {\n public class MiClaseInterna {\n        // Cosas de esta clase.\n    }\n\n    public int propiedad_publica;\n    private int propiedad_privada;\n\n    public void setPrivada(int valor) {\n        this.propiedad_privada = valor;\n    }\n\n    public int getPrivada() {\n        return this.propiedad_privada;\n    }\n\n    public metodoPublico() {\n        System.out.println(\"Aqu\u00ed estoy, de cara al p\u00fablico...\");\n        System.out.println(\"(Pero puedo invocar a m\u00e9todos privados de mi clase\" + metodoPrivado +\")\"):\n    }\n\n    private String metodoPrivado() {\n        return \"Pues aqu\u00ed estoy, siendo privado en mi privacidad.\";\n    }\n\n    public static void main(String[] args) {\n        MiClase miObjeto = new MiClase();\n\n        miObjeto.propiedad_privada = 5; // Esto ser\u00e1 un error.\n        miObjeto.propiedad_publica = 10; // No dar\u00e1 problemas.\n\n        String mensaje_privado = miObjeto.metodoPrivado(); // Dar\u00e1 error.\n        miObjeto.metodoPublico(); // Funcionar\u00e1 correctamente.\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.2%20-%20Visibilidad/","title":"Tema 3.2: Visibilidad","text":"<p>La visibilidad determina qu\u00e9 elementos de una clase se pueden ver desde el exterior.</p> <p>Hay tres palabras reservadas con las que podemos indicar qu\u00e9 visibilidad tendr\u00e1n los elementos de una clase (propiedades y m\u00e9todos).</p> <ul> <li><code>public</code>: Todo el mundo podr\u00e1 verlo.</li> <li><code>protected</code>: S\u00f3lo las clases del mismo paquete podr\u00e1n verlo.</li> <li><code>private</code>: S\u00f3lo la misma clase podr\u00e1 verlo, es decir, ser\u00e1 invisible desde el exterior.</li> </ul>"},{"location":"Tema%203/T3.2%20-%20Visibilidad/#ejemplo","title":"Ejemplo","text":"<p>En primer lugar vamos a definir una clase con tres propiedades y tres m\u00e9todos, cada uno con una visibilidad distinta:</p> <pre><code>public class MiClase {\n    public int propPublica;\n    protected int propProtegida;\n    private int propPrivada;\n\n    public void setAllToZero() {\n        this.propPublica = 0;\n        this.propProtegida = 0;\n        this.propPrivada = 0;\n    }\n\n    protected void setAllToOne() {\n        this.propPublica = 1;\n        this.propProtegida = 1;\n        this.propPrivada = 1;\n    }\n\n    protected void setAllToTwo() {\n        this.propPublica = 2;\n        this.propProtegida = 2;\n        this.propPrivada = 2;\n    }\n}\n</code></pre> <p>Supongamos tambi\u00e9n que esta clase est\u00e1 dentro de la carpeta \"paquete1\", lo que representar\u00e1 que la clase est\u00e1 en el paquete \"paquete1\":</p> <pre><code>package paquete1;\n\npublic class MiClase {\n    // Definimos un conjunto de constantes (modificador \"final\") con distintas\n    // opciones de visibilidad.\n    final int VISIBILIDAD_POR_DEFECTO = 1\n    public final int VISIBLE_POR_TODOS = 10;\n    protected final int VISIBILIDAD_DE_PAQUETE = 100;\n    private final int VISIBLE_POR_MI = 1000;\n\n    // ...\n}\n</code></pre> <p>Crearemos ahora otras dos clases que har\u00e1n uso de la clase <code>MiClase</code>. La primera estar\u00e1 en el mismo paquete y la segunda fuera.</p> <pre><code>package paquete1;\n\npublic class MiClaseHermana {\n    // ...\n    int valor = MiClase.VISIBILIAD\n}\n</code></pre> <pre><code>public class MiClaseExtra\u00f1a {\n    // ...\n}\n</code></pre> <p>Veamos, por \u00faltimo, a qu\u00e9 elementos de <code>MiClase</code> pueden acceder las otras dos clases:</p> <pre><code>\n</code></pre>"},{"location":"Tema%203/T3.2%20-%20Visibilidad/#cuadro-de-visibilidad","title":"Cuadro de visibilidad","text":"<p>El siguiente cuadro muestra la interacci\u00f3n entre los modificadores de visibilidad que se aplican a propiedades y m\u00e9todos de una clase y desde donde se pueden consultar:</p> <p></p>"},{"location":"Tema%203/T3.3%20-%20Herencia/","title":"Tema 3.3: Herencia","text":"<p>La herencia es un mecanismo que permite declarar una nueva clase (subclase) a partir de otra clase ya existente (superclase). Esto permite que todos los elementos de la superclase pasen a estar disponibles en la subclase excepto los constructores.</p> <p>Java s\u00f3lo dispone de herencia simple, por lo que una clase s\u00f3lo puede heredar de una \u00fanica superclase.</p> <p>Cuando una clase hereda (<code>extends</code>) de otra clase se denomina a la heredera: subclase, clase hija o clase derivada. Por su parte a la clase de la que hereda se la llamar\u00e1: superclase, clase padre o clase base.</p> <p>La herencia tiene una cualidad transitiva. Esto quiere decir que si la clase C hereda de la clase B y la clase B hereda de la clase A:</p> <ul> <li>La clase C es subclase de B.</li> <li>La clase B es subclase de A.</li> <li>La clase C es tambi\u00e9n subclase de A.</li> </ul> <p>De este modo siempre podremos hablar de una jerarqu\u00eda de clases.</p> <p>Adem\u00e1s de heredar todo el c\u00f3digo y propiedades de sus superclases (todas las que est\u00e9n por encima en la jerarqu\u00eda), una subclase se considera del mismo tipo que su superclase.</p> <pre><code>// Creamos una clase Alumno.\npublic class Alumno {\n    private int dni;\n    private String nombre;\n\n    public void setDni(int dni) {\n        this.dni = dni;\n    }\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public int getDni() {\n        return dni;\n    }\n\n    public string getNombre() {\n        return nombre;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Mi nombre es %s y mi DNI %d.\");\n    }\n}\n</code></pre> <p>Si creamos ahora una subclase (<code>AlumnoFP</code>) de la clase anterior.</p> <pre><code>public class AlumnoFP extends Alumno {\n    private String modulo;\n\n    public void setModulo(String modulo) {\n        this.modulo = modulo;\n    }\n\n    public String getModulo() {\n        return modulo\n    }\n\n    @Override \n    public String toString() {\n        String string = super.toString();\n\n        return String.format(\"%s%nEstudio el m\u00f3dulo de %s.%n\", string, modulo);\n    }\n}\n</code></pre> <p>Aunque no los hemos definido <code>AlumnoFP</code> dispone de los m\u00e9todos <code>setDni</code> y <code>getDni</code> que hereda de su padre (as\u00ed como todas sus propiedades). Adem\u00e1s de heredar los m\u00e9todos de la clase padre tambi\u00e9n podr\u00e1 a\u00f1adir sus propios m\u00e9todos (como <code>setModulo</code> y <code>getModulo</code>). Y tambi\u00e9n podr\u00e1 sobrescribir m\u00e9todos de sus clases padres (se indica con la etiqueta <code>@Override</code>).</p> <p>Si necesitase acceder a alg\u00fan m\u00e9todo de su clase padre podr\u00eda hacerlo utilizando la referencia <code>super</code>, que le permitir\u00e1 acceder a los m\u00e9todos de su clase padre (directa).</p>"},{"location":"Tema%203/T3.3%20-%20Herencia/#ventajas-de-la-herencia","title":"Ventajas de la herencia","text":"<p>Su principal ventaja es que permite reutilizar c\u00f3digo ya que los m\u00e9todos que hayamos dise\u00f1ado para una clase podr\u00e1n aplicarse autom\u00e1ticamente a todas sus subclases.</p> <p>Otra ventaja es que podremos tratar a toda una jerarqu\u00eda de objetos como si fuesen del mismo tipo (todo heredan de alguna de las clases superiores en la jerarqu\u00eda).</p> <p>Por ejemplo, si dise\u00f1amos un m\u00e9todo que trabaja con objetos de la clase <code>Alumno</code> podremos pasarle objetos que sean de cualquiera de sus subclases <code>AlumnoFP</code> y el m\u00e9todo funcionar\u00e1 perfectamente. En cierto modo es como si el m\u00e9todo aceptase distintos tipos de argumentos.</p>"},{"location":"Tema%203/T3.3%20-%20Herencia/#declaracion-de-herencia","title":"Declaraci\u00f3n de herencia","text":"<p>Para declarar que la clase <code>Raton</code> hereda de la clase <code>Mamifero</code> hemos de usar la siguiente sentencia al declarar la clase <code>Raton</code>:</p> <pre><code>public class Raton extends Mamifero {\n    // C\u00f3digo de la clase rat\u00f3n.\n}\n</code></pre>"},{"location":"Tema%203/T3.3%20-%20Herencia/#asociacion-agregacion-y-composicion-de-clases","title":"Asociaci\u00f3n, agregaci\u00f3n y composici\u00f3n de clases","text":""},{"location":"Tema%203/T3.3%20-%20Herencia/#agregacion","title":"Agregaci\u00f3n","text":"<p>La agregaci\u00f3n puede definirse como una relaci\u00f3n entre dos clases que refleja que la clase A tiene uno o m\u00e1s elementos de la clase B. Se determina que la clase A es due\u00f1a de la clase B porque se puede producir que la clase A contiene alguna referencia (propiedad) a la clase B pero la clase B no puede contener elementos de la clase A. Si no se puede determinar la clase due\u00f1a estar\u00edas hablando de una asociaci\u00f3n de clases.</p> <p>Imaginemos por ejemplo el caso de dos clases Alumno y Modulo. Alumno almacena informaci\u00f3n sobre el alumno y Modulo informaci\u00f3n sobre el contenido del m\u00f3dulo. Puesto que un alumno estar\u00e1 matriculado en varios m\u00f3dulos podemos decir que Alumno es la clase que tiene uno o m\u00e1s elementos de la clase Modulo.</p> <pre><code>public class Alumno {\n    private String nombre;\n    private String apellidos;\n\n    //...\n\n    private Modulo[] modulos = Modulo[10];\n\n    //...\n}\n</code></pre> <pre><code>public class Modulo {\n    private String codigo;\n    private String nombre;\n    private String contenido;\n\n    // ...\n}\n</code></pre>"},{"location":"Tema%203/T3.3%20-%20Herencia/#composicion","title":"Composici\u00f3n","text":"<p>Similar al caso anterior pero cuando la clase B, adem\u00e1s de pertenecer a la clase A no puede existir de manera independiente.</p> <p>Un ejemplo de composici\u00f3n ser\u00eda una cuenta bancaria con respecto a un cliente. No pueden existir cuentas sin propietarios.</p>"},{"location":"Tema%203/T3.3%20-%20Herencia/#constructores-y-herencia","title":"Constructores y herencia","text":"<p>Los constructores se comporta de una forma diferente al resto de los elementos de una clase cuando son heredados por otra.</p> <p>A diferencia de lo que ocurre con el resto de m\u00e9todos y propiedades (que son heredados por la subclase) los constructores no se heredan. Cada subclase tendr\u00e1 sus propios constructores.</p> <p>Aunque no se declare expl\u00edcitamente toda clase tiene un constructor impl\u00edcito, es decir, un constructor por defecto. Si se declara cualquier otro constructor, el constructor por defecto desaparece.</p> <p>Cuando se crea un objeto de una clase no se invoca \u00fanicamente a su constructor, si no que se ejecuta en cadena el de todas las superclases de su jerarqu\u00eda:</p> <ol> <li>Si se invoca al constructor con alg\u00fan argumento, se buscar\u00e1 el m\u00e9todo constructor cuyos par\u00e1metros sean compatibles con dicho argumento. En caso contrario se invocar\u00e1 al constructor por defecto o al que ha creado el programador sin argumentos.</li> <li>Si queremos indicar que se ejecute un constructor concreto de la superclase hemos de invocarlo impl\u00edcitamente usando la sentencia <code>super</code>.</li> </ol>"},{"location":"Tema%203/T3.3%20-%20Herencia/#ejemplo","title":"Ejemplo","text":"<pre><code>public class MiClase {\n    // constructor por defecto. No es necesario si no se incluye ning\u00fan otro constructor.\n    public MiClase() {\n        // Inicializaci\u00f3n del objeto.\n    }\n\n    public MiClase(int x) {\n        // Inicializaci\u00f3n del objeto.\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.3%20-%20Herencia/#acceso-a-propiedades-de-la-superclase","title":"Acceso a propiedades de la superclase","text":"<p>Hay veces que deseamos acceder, desde una subclase, a alguna de las propiedades o m\u00e9todos de su superclase. Para ello podemos hacer uso de la palabra reservada <code>super</code>.</p> <pre><code>public class SuperClase {\n    public int x;\n\n    public SuperClase(int x) {\n        this.x = x;\n    }\n}\n\npublic class SubClase1 extends SuperClase {\n    public int y;\n\n    public SubClase1(int x, int y) {\n        super.x = x;\n        this.y = y;\n    }\n}\n\npublic class SubClase2 extends SuperClase {\n    public int y;\n\n    public SubClase2(int x, int y) {\n        super(x); // Constructor de la superclase.\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.3%20-%20Herencia/#cast","title":"Cast","text":"<p>Hay casos en los que sabemos que un objeto pertenece a una subclase concreta pero est\u00e1 almacenado en una variable declarada como del tipo de alguna de sus superclases. Si queremos convertir o indicar expl\u00edcitamente cual es el tipo del objeto podemos hacerlo utilizando el mecanismo cast:</p> <pre><code>// Object es superclase de todas las clases as\u00ed que la siguiente sentencia ser\u00e1 v\u00e1lida.\nObject cadena = \"hola mundo\"; \n\n// Pero como no est\u00e1 garantiza que cadena sea del tipo String (dijimos que era Object)\n// la siguiente sentencia fallar\u00e1.\nString miCadena = cadena;\n\n// Para que sea posible hemos de indicar expl\u00edcitamente el tipo de la variable cadena.\nString miCadena = (String) cadena;\n\n// Aunque parezca incre\u00edble esto puede dar problemas... por ejemplo cuando \"estamos completamente\n// seguros\" de algo que al fina como que no. Estoy bastante cansado.\n</code></pre>"},{"location":"Tema%203/T3.3%20-%20Herencia/#acceso-a-metodos-de-la-superclase","title":"Acceso a m\u00e9todos de la superclase","text":""},{"location":"Tema%203/T3.3%20-%20Herencia/#sobrescritura-de-metodos","title":"Sobrescritura de m\u00e9todos","text":"<p>Cuando queramos que una subclase tenga su propia versi\u00f3n de un m\u00e9todo de la superclase, podemos sobrescribirlo. Para ello hemos de declarar un m\u00e9todo con el mismo nombre y par\u00e1metros que el m\u00e9todo de la superclase.</p> <pre><code>public class SuperClase {\n    public String nombre;\n\n    // Constructor, m\u00e9todos, etc.\n\n    public void metodo() {\n        System.out.printf(\"Hola %s.%n\", nombre);\n    }\n}\n\n// Creamos una subclase.\n\npublic class SubClase extends SuperClase {\n    public String apellidos;\n\n    // Constructor, m\u00e9todos, etc. \n\n    @Override // Indicamos que sobrescribimos el m\u00e9todo \"metodo\".\n    public void metodo() {\n        System.out.printf(\"Hola %s %s.%n\", nombre, apellidos);\n    }\n\n    // Cuando invoquemos este m\u00e9todo de la subclase no se ejecutar\u00e1 el c\u00f3digo definido\n    // en la superclase si no el que acabamos de escribir.\n}\n</code></pre>"},{"location":"Tema%203/T3.4%20-%20Paquetes/","title":"Tema 3.4: Paquetes","text":"<p>En Java los paquetes son un mecanismo mediante el que podemos agrupar clases, sub-paquetes e interfaces. Como es l\u00f3gico se agrupar\u00e1n en un mismo paquete aquellas clases que tengan alguna relaci\u00f3n entre ellas.</p> <p>Toda clase (e interfaz) pertenece a alg\u00fan paquete. Si no se indica expl\u00edcitamente uno (mediante la sentencia <code>package</code>) se asigna la clase a un paquete por defecto.</p> <p>Los paquetes se usan para:</p> <ul> <li>Facilitar la localizaci\u00f3n de las clases e interfaces.</li> <li>Evitar conflictos de nombres, es decir, podr\u00edan existir dos clases Alumno en dos paquetes distintos (uno perteneciendo al instituto y otro a una academia).</li> <li>Facilitan un control de acceso: <code>protected</code> y el acceso por defecto funcionan a nivel de paquete.</li> </ul> <p>Hemos de tener en cuenta tambi\u00e9n que los paquetes est\u00e1n relacionados con la estructura de directorios. As\u00ed que si una clase est\u00e1 en el paquete <code>org.iescotarelo.dam</code> estar\u00e1 guardada en el directorio <code>org\\iescotarelo\\dam</code>. Idea</p>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#agrupar-clases-en-paquetes","title":"Agrupar clases en paquetes","text":"<p>Para agrupar las clases en paquetes hemos de usar la sentencia <code>package</code>:</p> <pre><code>package org.iescotarelo.dam;\n</code></pre> <p>Adem\u00e1s hemos de tener en cuenta que la clase ha de guardarse en la ruta <code>org\\iescotarelo\\dam</code>.</p>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#paquetes-y-el-classpath-y-el-horror","title":"Paquetes y el CLASSPATH y el horror","text":"<p>La variable de entorno <code>CLASSPATH</code> le indicar\u00e1 a la JVM d\u00f3nde debe buscar los paquetes a los que llamamos o deseamos importar. De este modo, si todos nuestros paquetes est\u00e1n dentro del directorio <code>C:\\FP\\DAM\\Programacion\\Java</code> deber\u00edamos a\u00f1adir dicho directorio a la variable <code>CLASSPATH</code>.</p>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#windows-11","title":"Windows 11","text":"<p>Para modificar las variables de entorno en Windows 11 podemos directamente pulsar en Inicio y buscar \"variables\". Nos aparecer\u00e1 la opci\u00f3n de \"Editar las variables de entorno del sistema\". Pulsamos y veremos la siguiente ventana:</p> <p></p> <p>Pulando en el bot\u00f3n de la parte inferior con la etiqueta <code>Variables de entorno...</code> abriremos la ventana:</p> <p></p> <p>Seleccionamos la variable llamada <code>CLASSPATH</code> y pulsamos editar:</p> <p></p> <p>Si deseamos que se incluyesen las de nuestro proyecto deber\u00edamos a\u00f1adir la ruta a la carpeta ra\u00edz de nuestro c\u00f3digo.</p>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#cosas-a-tener-en-cuenta","title":"Cosas a tener en cuenta","text":"<p>Peque\u00f1os detalles obvios y de escasa importancia que nos pueden amargar una ma\u00f1ana.</p> <ul> <li>La variable global <code>CLASSPATH</code> ha de indicar la ruta a los directorios de classes <code>.class</code> y/o a la ra\u00edz del \u00e1rbol de paquetes.</li> <li>La opci\u00f3n <code>-cp</code> de <code>java</code> y <code>javac</code> substituye el valor de <code>CLASSPATH</code>.</li> <li>Si incluimos <code>.jar</code> en nuestro proyecto estos han de incluirse expl\u00edcitamente en el <code>CLASSPATH</code> o la opci\u00f3n <code>-cp</code>. No llega co indicar su ubicaci\u00f3n.</li> </ul>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#importando-clases-de-paquetes","title":"Importando clases de paquetes","text":"<p>Una vez tenemos nuestras clases organizadas en paquetes podremos incluirlas en nuestros programas y proyectos import\u00e1ndolas.</p> <p>Para importar una o varias clases hemos de usar la sentencia <code>import</code>:</p> <pre><code>import org.iescotarelo.dam.MiClase;\n</code></pre> <p>Si quisi\u00e9semos importar todas las clases de un paquete escribir\u00edamos:</p> <pre><code>import org.iescotarelo.dam.*;\n</code></pre> <p>La sentencia anterior importar\u00eda a nuestro programa todas las clases que se encuentren dentro del paquete <code>org.iescotarelo.dam</code>.</p>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#static-import","title":"Static import","text":"<p>Un tipo especial de import es el import est\u00e1tico. Este import permitir\u00e1 importar a nuestro c\u00f3digo las constantes, propiedades y m\u00e9todos est\u00e1ticos de la clase que indiquemos:</p> <pre><code>package org.iescotarelo.dam.programacion.paquetes;\n\npublic class MiClase {\n    public static final int MI_CONSTANTE = 666;\n\n    public static void saludo(String nombre) {\n        System.out.println(String.format(\"Hola %s.\"));\n    }\n}\n</code></pre> <pre><code>import static org.iescotarelo.dam.programacion.paquetes.MiClase;\n\npublic class MiOtraClase {\n    public static void main {\n        saludo(\"Manuel\");\n    }\n}\n</code></pre>"},{"location":"Tema%203/T3.4%20-%20Paquetes/#estructura-de-directorios","title":"Estructura de directorios","text":"<p>Important points:</p> <p>Every class is part of some package. If no package is specified, the classes in the file goes into a special unnamed package (the same unnamed package for all files). All classes/interfaces in a file are part of the same package. Multiple files can specify the same package name. If package name is specified, the file must be in a subdirectory called name (i.e., the directory name must match the package name). We can access public classes in another (named) package using: package-name.class-name</p> <p>Informaci\u00f3n tomada de GeeksForGeeks.</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios%20-%20Herencia/","title":"Ejercicios tema 3: Herencia","text":""},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/","title":"Ejercicios Tema3: Prog. orientada a objetos","text":""},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Implementa un programa que admita dos argumentos indicando el valor m\u00ednimo y m\u00e1ximo y que genere dos n\u00fameros aleatorios entre dichos valores. Ha de mostrar dichos n\u00fameros por pantalla y tambi\u00e9n el valor del mayor sin usar ninguna sentencia de control. (Pistas <code>Random</code>, <code>Math.max</code>).</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Implementa una clase que represente a un viajero que sea capaz de almacenar informaci\u00f3n sobre: DNI, nombre, apellidos, nacionalidad y direcci\u00f3n.</p> <p>*Souci\u00f3n...</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>A\u00f1ade a la case anterior los m\u00e9todos necesarios para la lectura y escritura de sus campos (propiedades) y establece el nivel de visibilidad adecuado para ellos.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Incluye la clase en un paquete <code>viajero</code> que a su vez est\u00e9 contenido dentro del paquete <code>persona</code>.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#ejercicio-5","title":"Ejercicio 5","text":"<p>Declara un constructor para el viajero que admita como argumentos los valores de todos sus campos.</p> <p>Soluci\u00f3n...</p>"},{"location":"Tema%203/Ejercicios/T3%20-%20Ejercicios/#extra","title":"EXTRA","text":"<p>Opcional. Para aquellos con experiencia previa en programaci\u00f3n que hayan terminado los ejercicios anteriores.</p> <p>Escribe un m\u00e9todo que compruebe que el DNI es v\u00e1lido.</p>"},{"location":"Tema%204/T4.0%20-%20Excepciones/","title":"Tema 4: Excepciones","text":"<p>El mecanismo de excepciones es un sistema que nos permite detectar ciertas situaciones excepcionales que se pueden producir en nuestro programa y definir las acciones a llevar a cabo como respuesta a las mismas.</p> <p>Hasta cierto punto podemos identificar a las excepciones con errores.</p>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#gestion-de-excepciones","title":"Gesti\u00f3n de excepciones","text":"<p>Si sabemos que una secci\u00f3n de nuestro c\u00f3digo corre el riesgo de generar una excepci\u00f3n (si se puede dar una o m\u00e1s condiciones excepcionales) durante su ejecuci\u00f3n, podremos poner a prueba ese segmento y capturar las excepciones que se puedan producir. Esto nos permitir\u00e1, principalmente, evitar que nuestro programa descarrile, podremos tomar medidas para recuperar una situaci\u00f3n estable retomar la ejecuci\u00f3n normal del programa.</p>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#excepccion","title":"Excepcci\u00f3n","text":"<p>Una excepci\u00f3n es un objeto que puede ser lanzado con una sentencia <code>throw</code>:</p> <pre><code>Exception e = new Exception();\n\nthrow e;\n</code></pre>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#sentencia-try-cacth","title":"Sentencia <code>try-cacth</code>","text":"<p>La sentencia <code>try-catch</code> permite acotar un segmento de c\u00f3digo y capturar todas o algunas de la excepciones que se puedan producir dentro de un bloque de c\u00f3digo.</p> <p>La sintaxis de un bloque <code>try-catch</code> es la siguiente:</p> <pre><code>try {\n    // Bloque1\n    // Bloque de c\u00f3digo susceptible de lanzar una excepci\u00f3n.\n} catch (TipoDeExcepcion1 excepci\u00f3n1) {\n    // Bloque2\n    // Bloque de tratamiento de la situaci\u00f3n de excepci\u00f3n.\n    // Para una excepci\u00f3n del TipodDeExcepcion1\n\n} catch (TipoDeExcepcion2 excepci\u00f3n2) {// Opcional.\n    // Bloque3\n    // Bloque de tratamiento de la situaci\u00f3n de excepci\u00f3n.\n    // Para una excepci\u00f3n del TipodDeExcepcion1\n\n} finally { // Opcional. Bloque que se ejecutar\u00eda SIEMPRE.\n    // Bloque4\n    // Bloque de c\u00f3digo que se ejecutar\u00e1 siempre despu\u00e9s del Bloque1.\n}\n</code></pre> <p>N\u00f3tese que en una estructura <code>try-catch</code> pueden definirse varias sentencias <code>catch</code>. Esto nos permite tratar de forma distinta las distintas situaciones excepcionales que se puedan dar en nuestro bloque de c\u00f3digo <code>try</code>.</p>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#excepciones-checked-y-unchecked","title":"Excepciones checked y unchecked","text":"<p>Las excepciones se pueden clasificar en dos tipos:</p> <ul> <li>Excepciones checked: Son aquellas que se pueden prever y que se deben tratar en el c\u00f3digo. El compilador nos obliga a tratarlas mediante un bloque <code>try-catch</code> o mediante una declaraci\u00f3n <code>throws</code> en la firma del m\u00e9todo. Son excepciones que se comprueban en tiempo de compilaci\u00f3n.</li> <li>Excepciones unchecked: Son aquellas que no se pueden prever y que no se deben tratar en el c\u00f3digo. El compilador no nos obliga a tratarlas mediante un bloque <code>try-catch</code> o mediante una declaraci\u00f3n <code>throws</code> en la firma del m\u00e9todo.</li> </ul> <p>El usdo de la cl\u00e1usula <code>throws</code> en la firma de un m\u00e9todo nos permite propagar la excepci\u00f3n a la llamada del m\u00e9todo:</p> <pre><code>public void metodo() throws TipoDeExcepcion1, TipoDeExcepcion2 {\n    // Bloque de c\u00f3digo susceptible de lanzar una excepci\u00f3n.\n}\n</code></pre> <p>Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; RuntimeException (unchecked) Object -&gt; Traceable -&gt; Throwable -&gt; Error (unchecked)</p> <p>Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; IOException Object -&gt; Traceable -&gt; Throwable -&gt; Exception -&gt; en tiempo de compilaci\u00f3n.</p>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#lanzar-excepciones","title":"Lanzar excepciones","text":"<p>Cuando escribamos c\u00f3digo que pueda generar situaciones excepcionales podremos ser nosotros los que decidamos disparar o lanzar la excepci\u00f3n. Para ellos podremos escribir una sentencia <code>throw</code> que lance la excepci\u00f3n de la que nos interese avisar.</p> <p>Para lanzar una excepci\u00f3n hemos de crear un objeto del tipo de excepci\u00f3n que nos interese. Cuando creemos el objeto excepci\u00f3n podremos tambi\u00e9n indicar en un mensaje la cauda de la excepci\u00f3n:</p> <pre><code>import java.util.Random;\n\npublic class Excepciones {\n\n    /*\n     * En el siguiente m\u00e9todo s\u00f3lo admitiremos como par\u00e1metros valores positivos y que cumplan que\n     * min &lt; max.\n     */\n    public static int randomInt(int min, int max) {\n        if (min &lt; 0 || min &gt;= max) {\n            // Si no se cumplen nuestras restricciones lanzamos una excepci\u00f3n.\n            throw new IllegalArgumentException(\n                    String.format(\"min (%d) ha de ser menor que max (%d).\", min, max));\n        }\n        // Si se lanza una excepci\u00f3n se termina la ejecuci\u00f3n del m\u00e9todo por lo que nunca llegar\u00edamos\n        // a esta l\u00ednea de c\u00f3digo.\n\n        Random r = new Random();\n        return r.nextInt(max - min) + min;\n    }\n}\n</code></pre>"},{"location":"Tema%204/T4.0%20-%20Excepciones/#capturar-excepciones","title":"Capturar excepciones","text":"<p>En primer lugar hemos de tener en cuenta que s\u00f3lo hemos de capturar aquellas excepciones que sepamos como resolver. Si no tenemos definida la forma en que vamos lidia con una situaci\u00f3n excepcional no debemos de capturar la excepci\u00f3n que produzca. Lo correcto ser\u00e1 dejar que el programa falle y se termine su ejecuci\u00f3n.</p> <p>Para capturar una excepci\u00f3n usaremos la estructura <code>try-catch</code>. Esta estructura tiene la siguiente sintaxis:</p> <pre><code>try {\n    // Bloque de c\u00f3digo que podr\u00eda lanzar una excepci\u00f3n.\n} catch (Exception e) {// Podremos indicar un tipo m\u00e1s espec\u00edfico de excepci\u00f3n.\n    // Bloque de c\u00f3digo para tratar la excepci\u00f3n\n\n} finally {\n    // Opcional en caso de que deseemos ejecutar alg\u00fan c\u00f3digo siempre\n    // a continuaci\u00f3n del bloque que puede producir la excepci\u00f3n.\n}\n</code></pre> <p>```java import java.util.Random;</p> <p>public class Excepciones {</p> <pre><code>/*\n * En el siguiente m\u00e9todo s\u00f3lo admitiremos como par\u00e1metros valores positivos y que cumplan que\n * min &lt; max.\n */\npublic static int randomInt(int min, int max) {\n    if (min &lt; 0 || min &gt;= max) {\n        // Si no se cumplen nuestras restricciones lanzamos una excepci\u00f3n.\n        throw new IllegalArgumentException(\n                String.format(\"min (%d) ha de ser menor que max (%d).\", min, max));\n    }\n    // Si se lanza una excepci\u00f3n se termina la ejecuci\u00f3n del m\u00e9todo por lo que nunca llegar\u00edamos\n    // a esta l\u00ednea de c\u00f3digo.\n\n    Random r = new Random();\n    return r.nextInt(max - min + 1) + min;\n}\n\npublic static void main(String[] args) {\n    int min = Integer.parseInt(args[0]);\n    int max = Integer.parseInt(args[1]);\n    try {\n        System.out.println(\"Vamos a invocar \\\"randomInt\\\"\");\n        int aleatorio = randomInt(min, max);\n        System.out.println(String.format(\"El n\u00famero generado ha sido %d.\", aleatorio));\n\n    } catch (Exception e) {\n        System.out.println(e); // Podremos mostrar por pantalla el mensaje de la excepci\u00f3n.\n    } finally {// Este condigo se ejecutar\u00e1 EN CUALQUIER CASO.\n        System.out.println(\"the end.\");\n    }\n}\n</code></pre> <p>} \u00b4\u00b4\u00b4</p>"},{"location":"Tema%204/T4.1%20-%20Debugging/","title":"Debugging","text":"<p>TODO: Explicar qu\u00e9 es debugging.</p> <p>TODO: Hacer un v\u00eddeo explicando c\u00f3mo hacer debugging en Visual Studio Code.</p> <p>TODO: Ejercicio para hacer debugging.</p>"},{"location":"Tema%204/T4.2%20-%20Testing/","title":"Tema 4.2: Texting","text":"<p>Gracias a dios este tema ya lo dio Fernando en Contorno de desarrollo.</p>"},{"location":"Tema%204/Ejercicios/T4%20-%20Ejercicios/","title":"Ejercicios tema 4: Excepciones, debugging y testing","text":""},{"location":"Tema%204/Ejercicios/T4%20-%20Ejercicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Utilizando arrays y la clase de utilidades <code>java.util.Arrays</code>...</p> <p>Crea una clase <code>Numeros</code> que:</p> <ul> <li>Pueda almacenar una lista de n\u00fameros enteros.</li> <li>Se pueda consultar el tama\u00f1o de la lista.</li> <li>Se puedan obtener el n\u00famero mayor y el n\u00famero menor de la lista.</li> <li>Se pueda obtener la media de los n\u00fameros de la lista.</li> <li>Se pueda obtener la mediana de los n\u00fameros de la lista.</li> </ul>"},{"location":"Tema%204/Ejercicios/T4%20-%20Ejercicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modifica el programa anterior para que:</p> <ul> <li>Se pueda obtener una versi\u00f3n ordenada de la lista de n\u00fameros.</li> <li>Se pueda obtener una lista con los n\u00fameros pares de la lista original.</li> <li>Se pueda obtener una lista con los n\u00fameros impares de la lista original.</li> </ul>"},{"location":"Tema%204/Ejercicios/T4%20-%20Ejercicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Modifica de nuevo la clase <code>Numeros</code> para que:</p> <ul> <li>Se pueda obtener el n\u00famero de n\u00fameros primos de la lista.</li> <li>Se pueda obtener un array con los n\u00fameros primos de la lista.</li> </ul>"},{"location":"Tema%204/Ejercicios/T4%20-%20Ejercicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Finalmente modifica la clase <code>Numeros</code> para que:</p> <ul> <li>Se pueda insertar un n\u00famero en la lista.</li> <li>En una posici\u00f3n concreta.</li> <li>Por el principio.</li> <li>Por el final.</li> <li>Se pueda elminar un n\u00famero de la lista.</li> <li>De una posici\u00f3n concreta.</li> <li>Por el principio.</li> <li>Por el final.</li> </ul>"},{"location":"Tema%205/T5.0%20-%20Polimorfismo/","title":"Tema 5: Conceptos avanzados de POO","text":"<p>En este tema veremos algunos conceptos m\u00e1s avanzados de la orientaci\u00f3n a objetos como son:</p> <ul> <li>Polimorfismo.</li> <li>Interfaces.</li> <li>Clases abstractas.</li> </ul>"},{"location":"Tema%205/T5.0%20-%20Polimorfismo/#polimorfismo","title":"Polimorfismo","text":"<p>Polimorfismo significa \"muchas formas\". Eso se asocia con la capacidad de distintos lenguajes de programaci\u00f3n de que un elemento tome distintas formas en distintos contextos. En Java el polimorfismo se puede dar de varias formas:</p> <ul> <li>Polimorfismo de clase: O asignaci\u00f3n polimorfa derivada del concepto de herencia.</li> <li>Polimorfismo de m\u00e9todo: O ejecuci\u00f3n polimorfa por la que una clase puede definir varios algoritmos distintos para un mismo m\u00e9todo.</li> </ul>"},{"location":"Tema%205/T5.0%20-%20Polimorfismo/#polimorfismo-de-clase","title":"Polimorfismo de clase","text":"<p>Como hemos visto en el apartado dedicado a la herencia, una subclase es una especificaci\u00f3n de su superclase. Esto permite que podamos asignar objetos de muchas formas distintas (subclases) a una variable de una \u00fanica clase (la superclase). Este concepto se aplica tanto a clases y clases abstractas como a interfaces.</p> <p>Veamos el caso del m\u00e9todo <code>toString</code>. Este m\u00e9todo est\u00e1 implementado en la clase <code>Object</code>. Como <code>Object</code> es superclase de toda otra clase de Java esto significa el que m\u00e9todo estar\u00e1 disponible para todas las clases de Java.</p> <p>Si quisi\u00e9semos crear un m\u00e9todo (como <code>println</code>) que muestre la cadena que represente al objeto podr\u00edamos crearlo con el siguiente c\u00f3digo:</p> <pre><code>public void muestra(Object obj) {\n    System.out.println(obj.toString());\n}\n</code></pre> <p>Si creamos la clase alumno de la siguiente manera:</p> <pre><code>public class Alumno {\n    private String nombre;\n    private String apellidos;\n    private String DNI;\n    private int numero;\n\n    public Alumno(String nombre, String apellidos, String DNI, int numero) {\n        this.nombre = nombre;\n        this.apellidos = apellidos;\n        this.DNI = DNI;\n        this.numero = numero;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Alumno %s, %s con DNI %s y n\u00famero %d.%n\", apellidos, nombre, DNI, numero);\n    }\n}\n</code></pre> <p>Y le pasamos un objeto de la clase <code>Alumno</code> al m\u00e9todo antes creado:</p> <pre><code>Alumno alumno = new Alumno(\"Juan\", \"Sin Miedo\", \"87654321A\");\n\nmuestra(alumno);\n</code></pre> <p>Por un lado el m\u00e9todo aceptar\u00e1 el objeto ya que, adem\u00e1s de la clase <code>Alumno</code> tambi\u00e9n lo es de <code>Object</code> (todas las clases son subclases de <code>Object</code>). Adem\u00e1s, al invocar al m\u00e9todo <code>toString</code> se ejecutar\u00e1 la implementaci\u00f3n del objeto de la clase <code>Alumno</code>.</p>"},{"location":"Tema%205/T5.0%20-%20Polimorfismo/#polimorfismo-de-metodo","title":"Polimorfismo de m\u00e9todo","text":"<p>Este polimorfismo se refiere a la capacidad que tiene una clase de definir distintas implementaciones de un m\u00e9todo dependiendo del tipo de objeto con que se invoque (de sus argumentos). Podr\u00edamos decir que en este caso podr\u00edamos ejecutar la misma acci\u00f3n de distintas formas sobre distintos elementos.</p> <p>Por ejemplo. El m\u00e9todo que escribimos al comienzo de este tema, <code>mostrar</code> funcionar\u00e1 con cualquier objeto pero no con los tipos primitivos: <code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>, etc.</p> <p>Para solucionar esto podremos a\u00f1adir m\u00e1s m\u00e9todos:</p> <p>```java public void muestra(Object obj) {     System.out.println(obj.toString()); }</p> <p>public void muestra(int i) {     System.out.println(Integer.toString(i)); }</p> <p>public void muestra(float f) {     System.out.println(Float.toString(f)); }</p> <p>public void muestra(boolean b) {     System.out.println(Boolean.toString(b)); } ``</p>"},{"location":"Tema%205/T5.1%20-%20Interfaces/","title":"Tema 5.1: Interfaces","text":""},{"location":"Tema%205/T5.1%20-%20Interfaces/#introduccion","title":"Introducci\u00f3n","text":"<p>Las interfaces son un tipo de clase que s\u00f3lo contiene m\u00e9todos y constantes. No puede contener atributos ni constructores. Las interfaces son muy \u00fatiles para definir comportamientos que pueden ser implementados / compartidos por diferentes clases.</p> <p>Un interfaz podr\u00e1 definir:</p> <ul> <li>Constantes: <code>static final PI = 3.1416;</code></li> <li>M\u00e9todos abstractos: <code>public double area();</code></li> <li>M\u00e9todos por defecto: <code>default void metodo() {\\\\cuerpo del m\u00e9todo}</code></li> </ul>"},{"location":"Tema%205/T5.1%20-%20Interfaces/#sintaxis","title":"Sintaxis","text":"<p>La sintaxis de una interfaz es la siguiente:</p> <pre><code>public interface NombreDeLaInterfaz {\n    // Constantes\n    static final int CONSTANTE = 5;\n    //...\n\n    // M\u00e9todos abstractos.\n    void metodo1();\n    int metodo2();\n    default int metodo3() {\n        return 0;\n    }\n    //...\n}\n</code></pre> <p>Los m\u00e9todos declarados en la interfaz anterior se denominan m\u00e9todos abstractos. Estos m\u00e9todos no tienen cuerpo, es decir, no tienen implementaci\u00f3n. La implementaci\u00f3n de estos m\u00e9todos se realiza en las clases que implementan la interfaz.</p> <p>Tambi\u00e9n existe la posibilidad de declarar m\u00e9todos con cuerpo en una interfaz. Estos m\u00e9todos se denominan m\u00e9todos por defecto <code>default</code>. Ya que estos m\u00e9todos se implementan en la interfaz no es necesario que las clases la implementen los sobrescriban (aunque es posible hacerlo).</p> <pre><code>public interface NombreDeLaInterfaz {\n    // Constantes\n    static final int CONSTANTE = 5;\n    //...\n\n    // M\u00e9todos por defecto:\n    default void metodo1() {\n\n    }\n    default int metodo2() {\n        return 0;\n    }\n    //...\n}\n</code></pre> <p>Cuando deseamos indicar que una clase cumple los requisitos de una interfaz, usamos la palabra reservada <code>implements</code>:</p> <pre><code>public class NombreDeLaClase implements NombreDeLaInterfaz {\n    //...\n}\n</code></pre>"},{"location":"Tema%205/T5.1%20-%20Interfaces/#ejemplo","title":"Ejemplo","text":"<pre><code>public interface Superficie {\n    public static final double PI = 3.1416;\n\n    public double area();\n    public double perimetro();\n}\n</code></pre> <p>Cuando creemos la clase que implemente la interfaz, debemos implementar todos los m\u00e9todos de la interfaz:</p> <pre><code>public class Circulo implements Superficie {\n    private double radio;\n\n    public Circulo(double radio) {\n        this.radio = radio;\n    }\n\n    @Override\n    public double area() {\n        return PI * radio * radio;\n    }\n\n    @Override\n    public double perimetro() {\n        return 2 * PI * radio;\n    }\n}\n</code></pre> <p>Una clase puede implementar varias interfaces:</p> <pre><code>public class Circulo extends Figura implements Interfaz1, Interfaz2 {\n    //...\n}\n</code></pre>"},{"location":"Tema%205/T5.1%20-%20Interfaces/#herencia-de-interfaces","title":"Herencia de interfaces","text":"<p>Una interfaz puede heredar de otras interfaces. Para ello usamos la palabra reservada <code>extends</code>:</p> <pre><code>public interface InterfazHija extends InterfazPadre1, InterfazPadre2 {\n    //...\n}\n</code></pre> <p>Como podemos ves las interfaces, a diferencia de una clases, pueden heredar de varias interfaces.</p>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/","title":"Tema 5.2: Clases abstractas","text":"<p>Una clase abstracta es una clase como otra clase cualquier con dos salvedades:</p> <ul> <li>No se se puede instanciar. Es decir, no podemos crear objetos de una clase abstracta.</li> <li>Puede contener m\u00e9todos abstractos. Tiene que tener al menos un m\u00e9todo abstracto.</li> </ul>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/#declaracion-de-una-clase-abstracta","title":"Declaraci\u00f3n de una clase abstracta","text":"<p>Para declarar una clase como abstracta, usamos la palabra reservada <code>abstract</code>:</p> <pre><code>public abstract class NombreDeLaClase {\n    //...\n}\n</code></pre>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Un m\u00e9todo abstracto es un m\u00e9todo en el que \u00fanicamente se declara su firma, pero no su implementaci\u00f3n. Es decir, no se indica c\u00f3mo se va a implementar el m\u00e9todo. La implementaci\u00f3n del m\u00e9todo se realiza en las clases que hereden de la clase abstracta.</p> <p>Para declarar un m\u00e9todo abstracto usaremos, de nuevo, la palabra reservada <code>abstract</code>. La sintaxis es la siguiente:</p> <pre><code>public abstract class NombreDeLaClase {\n    public abstract void metodoAbstracto();\n}\n</code></pre> <p>Tambi\u00e9n es posible declarar m\u00e9todos completos en una clase abstracta. Estos m\u00e9todos se heredar\u00e1n en sus clases hijas como cualquier otro m\u00e9todo de cualquier otra clase.</p> <pre><code>public abstract class NombreDeLaClase {\n    public abstract void metodoAbstracto();\n\n    public void metodoNormal() {\n        //...\n    }\n\n}\n</code></pre>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/#extras","title":"Extras","text":"<p>Curiosidades relacionadas con las clases abstractas.</p>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/#clases-con-constructor-privado","title":"Clases con constructor privado","text":"<p>Otra forma de evitar que una clase pueda ser instanciada es la siguiente:</p> <pre><code>public class ClaseNoInstanciable {\n    private ClaseNoInstanciable() {\n        //...\n    }\n}\n</code></pre> <p>Si hacemos el constructor por defecto privado, no podremos instanciar la clase. Esto es \u00fatil cuando queremos que una clase no pueda ser instanciada, pero no queremos que sea abstracta.</p> <p>Adem\u00e1s de que la clase no pueda ser instanciada tambi\u00e9n logramos que no se puedan crear subclases de esta clase. Esto se debe a que toda subclase de una clase llama impl\u00edcitamente al constructor de la superclase. Si el \u00fanico constructor de la superclase es el constructor por defecto y, adem\u00e1s, este es privado, ninguna subclase podr\u00e1 ser instanciada.</p>"},{"location":"Tema%205/T5.2%20-%20Clases%20abstractas/#clases-finales","title":"Clases finales","text":"<p>Si lo que no queremos es que se puedan crear subclases de una clase podremos declarar esta como <code>final</code>. De esta forma, no se podr\u00e1 heredar de esta clase.</p> <pre><code>public final class ClaseNoHeredable {\n    //...\n}\n</code></pre> <p>Lo que no est\u00e1 permitido es crear una clase no instanciable <code>abstract</code> y que adem\u00e1s sea <code>final</code>. Esto no tiene sentido, ya que una clase <code>final</code> no puede ser heredada, por lo que no tiene sentido que sea <code>abstract</code>.</p> <p>Aunque este comportamiento S\u00cd tiene sentido si queremos tener una clase que unicamente contenga m\u00e9todos est\u00e1ticos (como es el caso de la clase <code>Arrays</code> o <code>Math</code>). En este caso, la clase s\u00ed que puede ser instanciada, pero no se puede heredar de ella. Esto es lo que vimos en el apartado anterior \"Clases con constructor privado\" (<code>Arrays</code> y <code>Math</code> son dos ejemplos).</p>"},{"location":"Tema%205/T5.3%20-%20Recursividad/","title":"Tema 5.3: Recursividad","text":"<p>El concepto de recursividad, aunque no est\u00e1 ligado en absoluto a la POO es lo suficientemente importante como para dedicarle este espacio.</p> <p>La recursividad est\u00e1 ligada al concepto de funci\u00f3n (m\u00e9todo en Java) y la programaci\u00f3n funcional. Diremos que una funci\u00f3n (o m\u00e9todo) es recursiva cuando la funci\u00f3n se llama a s\u00ed misma. El ejemplo cl\u00e1sico de funci\u00f3n recursiva es la funci\u00f3n que describe la serie de Fibonacci.</p> <p>Funci\u00f3n de Fibonacci:</p> <ul> <li>Fibonacci de 0: fib(0) = 0.</li> <li>Fibonacci de 1: fib(1) = 1.</li> <li>Fibonacci de 1: fib(2) = 1.</li> <li>Fibonacci de 1: fib(3) = fib(1) + fib(2).</li> <li>Fibonacci de 1: fib(4) = fib(2) + fib(3).</li> <li>...</li> <li>Fibonacci de 1: fib(n) = fib(n - 2) + fib(n - 1).</li> </ul> <p>Si implementamos una clase con la funci\u00f3n de Fibonacci en Java har\u00edamos lo siguiente:</p> <pre><code>public static int fibonacci(int x) {\n    if (x == 0) return 0;\n    if (x == 1) return 1;\n    if (x == 2) return 2;\n\n    return fibonacci(x - 1) + fibonacci(x - 2);\n}\n</code></pre>"},{"location":"Tema%205/T5.3%20-%20Recursividad/#elementos-de-una-funcion-recursiva","title":"Elementos de una funci\u00f3n recursiva","text":""},{"location":"Tema%205/T5.3%20-%20Recursividad/#lamada-recursiva","title":"Lamada recursiva","text":"<p>La llamada recursiva es simplemente la invocaci\u00f3n de la misma funci\u00f3n en la que nos encontramos desde ella misma. Dentro de una funci\u00f3n puede haber una o m\u00e1s llamadas a ella misma (como en el caso de Fibonacci).</p>"},{"location":"Tema%205/T5.3%20-%20Recursividad/#caso-base-salida-de-la-recursion","title":"Caso base / salida de la recursi\u00f3n","text":"<p>El caso base es aquel que no nos lleva a una llamada recursiva si no que devuelve directamente el resultado. En el ejemplo de Fibonacci, <code>fibonacci(0)</code>, <code>fibonacci(1)</code> y <code>fibonacci(2)</code> so los tres casos base.</p> <p>Si una funci\u00f3n recursiva no tuviese caso base nunca se romper\u00eda la cadena de llamadas recurivas y no econtrar\u00edamos, en cierto modo, ante el mismo caso de un bucle sin fin.</p>"},{"location":"Tema%205/T5.3%20-%20Recursividad/#eficiencia","title":"Eficiencia","text":"<p>Aunque hay casos como el de la funci\u00f3n de Fibonacci donde la soluci\u00f3n recursiva es la m\u00e1s natural, muchas veces sucede que esta soluci\u00f3n es muy ineficiente. Esto se debe principalmente a que en una funci\u00f3n recursiva se producen muchas llamadas consecutivas a una funci\u00f3n sin que haya terminado la funci\u00f3n en que nos encontramos y al impacto que esto tiene en la pila de llamadas.</p>"},{"location":"Tema%205/T5.3%20-%20Recursividad/#pila-de-llamadas-stack","title":"Pila de llamadas / stack","text":"<p>Cuando invocamos una funci\u00f3n hemos de preservar el estado en que se encuentra nuestro programa hasta ese momento. A continuaci\u00f3n pasaremos el control a la funci\u00f3n y, cuando esta termine, tomaremos el valor devuelto, desempaquetaremos el estado previamente guardado de nuestro programa y continuaremos con su ejecuci\u00f3n.</p> <p>Si desde dentro de una funci\u00f3n llamamos a otra funci\u00f3n ser\u00e1 necesario, al igual que en el caso anterior, guardar su estado de ejecuci\u00f3n (variables locales, punto de ejecuci\u00f3n, etc.) hasta que la funci\u00f3n llamada finalice y le devuelva el control. De este modo si encadenamos llamadas a una funci\u00f3n sin que esta termine iremos apilando funciones y su estado continuamente. Dependiendo del n\u00famero de llamadas recursivas que se produzca esto podr\u00e1 tener un fuerte impacto tanto en la memoria como en el tiempo de ejecuci\u00f3n (ya que empaquetar y guardar el estado tiene un coste de CPU).</p> <p>Es por este motivo que las soluciones recursivas tienen mala fama y por el que se han desarrollado t\u00e9cnicas para transformar una soluci\u00f3n recursiva en otra iterativa.</p>"},{"location":"Tema%205/T5.3%20-%20Recursividad/#recursividad-de-cola","title":"Recursividad de cola","text":"<p>En el apartado anterior hablamos de la penalizaci\u00f3n en eficiencia de las funciones recursivas. Este no es el caso siempre, hay un subconjunto de funciones recursivas que (en los lenguajes actuales) no tienen penalizaci\u00f3n alguna. Estas son las que tienen recursividad de cola.</p> <p>La recursividad de cola se produce cuando la llamada recursiva es la \u00faltima instrucci\u00f3n de la funci\u00f3n. En este caso no es necesario guardar nada del estado interno de la funci\u00f3n que realiza la llamada ya que su resultado depende \u00fanicamente de los datos que se le hayan pasado a la nueva funci\u00f3n en la llamada.</p> <pre><code>// Como hacer un bucle con una funci\u00f3n recursiva\npublic static int recursiva(int i, int x) {\n    if (x == 0) return null;\n    System.out.println(String.format(\"Iteraci\u00f3n %d del bucle.\", i));\n    recursiva(i + 1; x - 1);\n}\n</code></pre> <p>Esta optimizaci\u00f3n se denomina TCO (Tail Call Optimization). I aparentemente Java no la tiene.</p>"},{"location":"Tema%205/Ejercicios/T5%20-%20Ejericicios/","title":"Tema 5: Ejercicios","text":""},{"location":"Tema%205/Ejercicios/T5%20-%20Ejericicios/#ejercicio-1","title":"Ejercicio 1","text":"<p>Codifica la jerarqu\u00eda ser vivo, animal y vegetal, creando las estructuras que consideres necesario para almacenar de cada elemento, como m\u00ednimo, nombre cient\u00edfico y nombre com\u00fan. Para los animales almacenaremos peso y altura. Paralos vegetales \u00fanicamente altura. Cada ser vivo se alimentar\u00e1 de una manera diferente, por lo que deber\u00e1 reflejar este aspecto de alguna forma.</p>"},{"location":"Tema%205/Ejercicios/T5%20-%20Ejericicios/#ejercicio-2","title":"Ejercicio 2","text":"<p>Implementa el escenario propuesto en la figura y a\u00f1ade las declaraciones de los getters y setters para cada uno de los campos, as\u00ed como constructores parametrizados a cada una de las clases.</p> <p></p>"},{"location":"Tema%205/Ejercicios/T5%20-%20Ejericicios/#ejercicio-3","title":"Ejercicio 3","text":"<p>Si se desea manejar informaci\u00f3n sobre, \u00fanicamente, las figuras geom\u00e9tricas punto, recta y circunferencia, \u00bfqu\u00e9 tipo de relaci\u00f3n establecer\u00eda entre ellas? Justifica tu respuesta.</p> <p>Codifica la soluci\u00f3n que hayas propuesto junto con un programa que muestre  un men\u00fa que permita crear los tres objetos de las clases indicadas y mostrar la informaci\u00f3n de los mismos.</p>"},{"location":"Tema%205/Ejercicios/T5%20-%20Ejericicios/#ejercicio-4","title":"Ejercicio 4","text":"<p>Haz una clase llamada <code>Persona</code> que siga las siguientes condiciones:</p> <p>Sus atributos son: </p> <ul> <li>nombre</li> <li>edad</li> <li>DNI</li> <li>sexo (H hombre, M mujer)</li> <li>peso</li> <li>altura</li> </ul> <p>No queremos que se accedan directamente a ellos. Si quieres a\u00f1adir alg\u00fan atributo puedes hacerlo.</p> <p>Todos los atributos menos el DNI ser\u00e1n valores por defecto seg\u00fan su tipo (0 n\u00fameros, cadena vac\u00eda para String, etc.). Sexo sera hombre por defecto, (usa una constante para representar el sexo).</p> <p>Se implantaran varios constructores:</p> <ul> <li>Un constructor por defecto.</li> <li>Un constructor\u00a0con el nombre, edad y sexo, el resto por defecto.</li> <li>Un constructor\u00a0con todos los atributos como par\u00e1metro.</li> </ul> <p>Los m\u00e9todos que se implementaran son:</p> <ul> <li><code>calcularIMC()</code>: calculara si la persona esta en su peso ideal (peso en kg/(altura^2  en m)), si esta f\u00f3rmula devuelve un valor menor que 20, la funci\u00f3n devuelve un -1, si devuelve un n\u00famero entre 20 y 25 (incluidos), significa que esta por debajo de su peso ideal\u00a0la funci\u00f3n devuelve un 0  y si devuelve un valor mayor que 25 significa que tiene sobrepeso, la funci\u00f3n devuelve un 1. Te recomiendo que uses constantes para devolver estos valores.</li> <li><code>esMayorDeEdad()</code>: indica si es mayor de edad, devuelve un booleano.</li> <li><code>comprobarSexo(char sexo)</code>: comprueba que el sexo introducido es correcto. Si no es correcto, sera H. No sera visible al exterior.</li> <li><code>generaDNI()</code>: genera un n\u00famero aleatorio de 8 cifras, genera a partir de este su n\u00famero su letra correspondiente. Este m\u00e9todo sera invocado cuando se construya el objeto. Puedes dividir el m\u00e9todo para que te sea m\u00e1s f\u00e1cil. No ser\u00e1 visible al exterior.</li> <li><code>toString()</code>: devuelve una cadena respresentado las propiedades del objeto.</li> <li>M\u00e9todos set de cada par\u00e1metro, excepto de DNI.</li> </ul> <p>Ahora, crea una clase ejecutable que haga lo siguiente:</p> <ul> <li>Pide por teclado el nombre, la edad, sexo, peso y altura.</li> <li>Crea 3 objetos de la clase anterior, el primer objeto obtendr\u00e1 las anteriores variables pedidas por teclado, el segundo objeto obtendr\u00e1 todos los anteriores menos el peso y la altura y el \u00faltimo por defecto, para este \u00faltimo utiliza los m\u00e9todos set para darle a los atributos un valor.</li> <li>Para cada objeto, deber\u00e1 comprobar si esta en su peso ideal, tiene sobrepeso o por debajo de su peso ideal con un mensaje.</li> <li>Indicar para cada objeto si es mayor de edad.</li> <li>Por \u00faltimo, mostrar la informaci\u00f3n de cada objeto.</li> </ul> <p>Puedes usar m\u00e9todos en la clase ejecutable, para que os sea mas f\u00e1cil.</p>"},{"location":"Tema%206/T6.0%20-%20Proyectos/","title":"Proyectos","text":"<p>Cuando desarrollamos una aplicaci\u00f3n en Java (o cualquier otro lenguaje) lo normal no es empezar a escribir c\u00f3digo. Para tener el c\u00f3digo organizado, hacer un seguimiento de las librer\u00edas que utilizamos y compartir las tareas de desarrollo con otras personas lo normal es crear un proyecto.</p> <p>Los EID de Java incluyen las herramientas necesarias apara organizar nuestro c\u00f3digo en proyectos.</p> <p>Adem\u00e1s de disponer de dichas herramientas hay otras independientes del EID que nos facilitan el mantenimiento de nuestro proyectos.</p> <p>Dos de ellas son Maven y Graddle.</p>"},{"location":"Tema%206/T6.0%20-%20Proyectos/#maven","title":"Maven","text":"<p>TODO: Pendiente de hacerlo. Algo se hizo ya en Contornos.</p>"},{"location":"Tema%206/T6.1%20-%20Maven/","title":"Tema 6.1: Maven","text":"<p>Hago lo que puedo. Esto esta pendiente de hacerse.</p>"},{"location":"Tema%207/Tema%207.0%20-%20Introduccion/","title":"Tema 7: Introducci\u00f3n a estructuras de datos avanzadas","text":"<p>Adem\u00e1s de los arrays que hemos estado viendo hasta el momento Java nos ofrece una serie de estructuras de datos m\u00e1s avanzadas que nos permiten almacenar y manipular conjuntos de datos de una forma m\u00e1s eficiente. Estas estructuras se pueden agrupar en tres grandes grupos:</p> <ul> <li>Listas: Una lista es una colecci\u00f3n de elementos ordenados. Los elementos de una lista pueden ser accedidos mediante un \u00edndice que indica su posici\u00f3n en la lista. Las listas pueden contener elementos duplicados y permiten la inserci\u00f3n (y borrado) de elementos en cualquier posici\u00f3n dentro de la lista. Un ejemplo de listas son las clases <code>ArrayList</code> y <code>LinkedList</code>.</li> <li>Conjuntos: Un conjunto es una colecci\u00f3n de elementos no ordenados. Los elementos de un conjunto no pueden repetirse. Un ejemplo de conjuntos son las clases <code>HashSet</code> y <code>TreeSet</code>.</li> <li>Mapas: Un mapa es una colecci\u00f3n de elementos no ordenados. Los elementos de un mapa se almacenan en pares de clave-valor. Estos pares clave-valor no pueden repetirse. Un ejemplo de mapas son las clases <code>HashMap</code> y <code>TreeMap</code>.</li> </ul> <p>Es importante tener en cuenta que las estructuras de datos avanzadas no son m\u00e1s que una forma de almacenar y manipular datos. Por lo tanto, no se puede decir que una estructura de datos es mejor que otra. Depender\u00e1 de las necesidades de cada aplicaci\u00f3n y de la forma en la que se vayan a utilizar los datos.</p> <p>Todas estas estructuras se basan en la implementaci\u00f3n de distintos interfaces que definen los m\u00e9todos que deben implementar. Por este motivo recomiendo que se repase el apartado del tema 5 sobre interfaces.</p> <p>Adem\u00e1s del uso de interfaces estas estructuras se basan en la utilizaci\u00f3n del mecanismo de gen\u00e9ricos que permite definir clases y m\u00e9todos que pueden trabajar con cualquier tipo de datos. En el siguiente apartado pasaremos a explicar su funcionamiento.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/","title":"Tema 7.1: Gen\u00e9ricos","text":""},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#introduccion","title":"Introducci\u00f3n","text":"<p>\u00bfPara qu\u00e9 sirven los gen\u00e9ricos?</p> <p>Los gen\u00e9ricos nos permiten crear clases y m\u00e9todos que pueden trabajar con cualquier tipo de dato, sin necesidad de especificar el tipo de dato concreto en el momento de definir las clases. Debido a que no se especifica el tipo exacto en la fase de dise\u00f1o de la clase podemos decir que usa un tipo gen\u00e9rico y de ah\u00ed su nombre.</p> <p>En el momento en que creemos objetos de una clase que use gen\u00e9ricos s\u00ed hemos de concretar con qu\u00e9 tipo de datos va a trabajar.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#ejemplo-practico","title":"Ejemplo pr\u00e1ctico","text":"<p>Ve\u00e1moslo con un ejemplo:</p> <p>Imaginemos que queremos que una clase almacenen un valor <code>Integer</code> y pueda imprimirlo:</p> <pre><code>public class AlmacenEntero {\n    private Integer valor;\n    public AlmacenEntero(Integer valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Esta clase s\u00f3lo puede almacenar e imprimir valores <code>Integer</code>, pero si queremos una clase que tenga la misma funcionalidad que pueda almacenar valores <code>Double</code> o <code>Float</code>, tendremos que crear una nueva clase (virtualmente id\u00e9ntica) para cada tipo de dato nuevo que queramos tratar:</p> <pre><code>public class AlmacenDoble {\n    private Double valor;\n    public AlmacenDoble(Double valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Para evitar tener que repetir una y otra vez el mismo c\u00f3digo en cada clase podemos utilizar los gen\u00e9ricos. Esto permitir\u00e1 crear una clase que pueda almacenar cualquier tipo de dato y que pueda imprimirlo. Indicaremos el tipo concreto en el momento de usar la clase (de crear un objeto). El c\u00f3digo de la clase ser\u00eda de esta forma gen\u00e9rico. Valdr\u00eda para cualquier tipo de dato.</p> <p>En el siguiente ejemplo de c\u00f3digo usamos <code>T</code> para indicar un tipo cualquiera que especificaremos en otro momento. No es necesario usar la letra T pero una vez la indiquemos hemos de mantener la consistencia y emplear la misma letra para indicar el tipo gen\u00e9rico:</p> <pre><code>public class Almacen&lt;T&gt; {\n    private T valor;\n    public Almacena(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>A la hora de utilizarlo debemos indicar el tipo de dato concreto que queremos almacenar. Por ejemplo, si queremos almacenar un <code>Integer</code>:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Almacen&lt;Integer&gt; almacen = new Almacen&lt;&gt;(5);\n        almacen.imprimir();\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#sintaxis-de-los-genericos","title":"Sintaxis de los gen\u00e9ricos","text":"<p>Como acabamos de ver en el ejemplo la sintaxis de los gen\u00e9ricos es muy sencilla.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#declaracion-de-la-clase","title":"Declaraci\u00f3n de la clase","text":"<p>En el momento de declarar una clase que use gen\u00e9ricos primero escribiremos el c\u00f3digo de declaraci\u00f3n de la misma como siempre:</p> <pre><code>public class MiClase {\n    //...\n}\n</code></pre> <p>A continuaci\u00f3n indicaremos entre los s\u00edmbolos <code>&lt;</code> y <code>&gt;</code> una palabra (generalmente la letra T) que indica el tipo gen\u00e9rico:</p> <pre><code>public class MiClase&lt;T&gt; {\n    //... \n}\n</code></pre> <p>Si fuese necesario se podr\u00e1n indicar varios gen\u00e9ricos:</p> <pre><code>public class MiClase&lt;T, E&gt; {\n    //...\n}\n</code></pre> <p>Despu\u00e9s de indicar el c\u00f3digo (T, E, etc.) del tipo gen\u00e9rico que se va a utilizar en la clase podremos utilizar este c\u00f3digo como indicador de tipo de las variables y m\u00e9todos:</p> <pre><code>public class MiClase&lt;T, E&gt; {\n    private ArrayList&lt;T&gt; datos;\n\n    public E resultado(T dato) {\n        // ...\n    }\n}\n</code></pre> <p>Cuando, al usar la clase gen\u00e9rica, indiquemos el tipo concreto que queremos usar se substituir\u00e1 <code>T</code> en el c\u00f3digo de la clase por dicho tipo concreto.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#uso-de-la-clase","title":"Uso de la clase","text":"<p>Cuando necesitemos crear una instancia de nuestra clase hemos de concretar con qu\u00e9 dato va a trabajar:</p> <pre><code>MiClase&lt;Integer, String&gt; mc = new MiClase&lt;Integer, String&gt;();\n</code></pre> <p>Puesto que es redundante repetir el tipo de dato Java permite omitirlo para mayor comodidad:</p> <pre><code>MiClase&lt;String&gt; mc = new MiClase&lt;&gt;();\n</code></pre> <p>Esto har\u00e1 que Java transforme el c\u00f3digo del la clase gen\u00e9rica en el siguiente antes de crear la instancia: (Es una forma de verlo, no digo que haga esto literalmente).</p> <pre><code>public class MiClase {\n    private ArrayList&lt;Integer&gt; datos;\n\n    public String resultado(Integer dato) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#tipos-de-datos-genericos","title":"Tipos de datos gen\u00e9ricos","text":"<p>El tipo dato que indicamos al crear la clase gen\u00e9rica puede ser cualquier tipo de dato, incluyendo clases, interfaces, etc. pero no puede ser un tipo primitivo.</p> <pre><code>// El siguiente c\u00f3digo no ser\u00eda v\u00e1lido:\nMiClase&lt;int&gt; mc = new MiClase&lt;&gt;();\n// Tendr\u00edamos que utilizar la clase envoltorio Integer:\nMiClase&lt;Integer&gt; mc = new MiClase&lt;&gt;();\n</code></pre> <p>N\u00f3tese tambi\u00e9n que, si trabajamos con tipos primitivos (<code>int</code>, <code>float</code>, <code>boolean</code>, etc.) no es necesario convertir expl\u00edcitamente \u00e9ste a su tipo envoltorio (<code>Integer</code>, <code>Float</code>, <code>Boolean</code>, etc.) ya que Java lo hace autom\u00e1ticamente.</p> <pre><code>ArrayList&lt;Integer&gt; listaInt = new ArrayList&lt;&gt;();\n\nlistaInt.add(5); // Esto es v\u00e1lido\nlistaInt.add\n(Integer.valueOf(6)); // Esto tambi\u00e9n es v\u00e1lido pero m\u00e1s complicado e innecesario.\n</code></pre>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#genericos-limitados","title":"Gen\u00e9ricos limitados","text":"<p>Tambi\u00e9n es posible limitar o restringir las caracter\u00edsticas del tipo de datos gen\u00e9rico que vamos a usar.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#limitar-superclase","title":"Limitar superclase","text":"<p>Por ejemplo, si queremos usar un tipo gen\u00e9rico pero que sea de un tipo dado (por ejemplo <code>Persona</code>) lo podemos indicar como:</p> <pre><code>public class Almacen&lt;T extends Persona&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Una vez hecho esto una variable de tipo <code>T</code> tendr\u00e1 acceso a todos los m\u00e9todos de <code>Persona</code> y, cuando se cree una instancia de <code>Almacen</code> se tendr\u00e1 que indicar un tipo que herede de <code>Persona</code>.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#limitar-interfaz","title":"Limitar interfaz","text":"<p>Del mismo modo que podemos limitar cual ha de ser la superclase del tipo de nuestro gen\u00e9rico tambi\u00e9n podemos hacer lo mismo con respecto a un interfaz:</p> <pre><code>public class Almacen&lt;T extends Comparable&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>N\u00f3tese que hemos de utilizar extends tanto para indicar la superclase como el interfaz que implementa y no implements (que ser\u00eda lo l\u00f3gico).</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#limitar-superclase-e-interfaces","title":"Limitar superclase e interfaces","text":"<p>Podemos combinar la limitaci\u00f3n de superclase con la indicaci\u00f3n de que ha de implementar uno o m\u00e1s interfaces. Para ello hemos de indicar primero siempre la superclase y a continuaci\u00f3n todos los interfaces que deseemos separados por &amp;:</p> <pre><code>public class Almacen&lt;T extends Persona &amp; Comparable &amp; Serializable&gt; {\n    private T valor;\n    public Almacen(T valor) {\n        this.valor = valor;\n    }\n    public void imprimir() {\n        System.out.println(valor);\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#metodos-genericos","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Los m\u00e9todos tambi\u00e9n pueden ser gen\u00e9ricos. Para ello, simplemente indicamos el tipo de dato gen\u00e9rico entre <code>&lt;</code> y <code>&gt;</code> despu\u00e9s del tipo de retorno del m\u00e9todo.</p> <pre><code>public class Printer {\n    public static &lt;T&gt; void print(T valor) {\n        System.out.println(valor);\n    }\n}\n</code></pre> <p>Si queremos que el m\u00e9todo admita m\u00e1s de un gen\u00e9rico:</p> <pre><code>public class GenericMethod {\n    public static &lt;T, U&gt; void print(T valor1, U valor2) {\n        System.out.println(valor1);\n        System.out.println(valor2);\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#como-usarlos","title":"\u00bfC\u00f3mo usarlos?","text":"<p>Se usan como cualquier otro m\u00e9todo sin que haya que tener en cuenta que son gen\u00e9ricos. Si se incumple alguna de las restricciones en la invocaci\u00f3n el compilador nos indicar\u00e1 cu\u00e1l es el problema.</p>"},{"location":"Tema%207/Tema%207.1%20-%20Genericos/#comodines-wildcards","title":"Comodines (wildcards)","text":"<p>Hay casos en los que deseamos indicar que un m\u00e9todo que estamos escribiendo admite un tipo gen\u00e9rico con cualquier tipo de datos. Veamos un ejemplo:</p> <pre><code>public class MiClase {\n    //...\n    // Este c\u00f3digo no es correcto, es s\u00f3lo ilustrativo.\n    public static void imprime(List&lt;DeLoQueSea&gt; lista) {\n        //...\n    }\n}\n</code></pre> <p>Nuestro m\u00e9todo <code>imprime</code> estar\u00e1 dise\u00f1ado de manera que pueda imprimir una lista independientemente de lo que contenga. Para indicar esto en la sintaxis de gen\u00e9ricos hemos de escribir un comod\u00edn (<code>?</code>) como tipo de la lista:</p> <pre><code>public class MiClase {\n    //...\n    // Este c\u00f3digo no es correcto, es s\u00f3lo ilustrativo.\n    public static void imprime(List&lt;?&gt; lista) {\n        //...\n    }\n\n    public static void main(String[] args) {\n        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        al.add(1);\n        al.add(2);\n        al.add(3);\n\n        imprime(list); // No dar\u00eda problemas.\n\n        LinkedList&lt;String&gt; llist = new LinkedList&lt;&gt;();\n        ll.add(\"1\");\n        ll.add(\"2\");\n        ll.add(\"3\");\n\n        imprime(llist); // No dar\u00eda problemas.\n\n\n        int[] intArr = {1, 2, 3};\n        imprime(intArr); // Dar\u00eda error.\n    }\n</code></pre>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/","title":"Tema 7.2: <code>Collections</code>","text":"<p>Para hablar de las estructura de datos avanzadas de Java hemos de tener claros varios conceptos.</p> <p>Necesitamos entender en qu\u00e9 consiste el interfaz <code>Iterable</code> y, para ello, hemos de tener claro el concepto de interface.</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#interfaces-en-java","title":"Interfaces en Java","text":"<p>Para entender el funcionamiento de las colecciones en java hemos de tener claro el funcionamiento de los interfaces (ya que <code>Collection</code> es un interfaz que implementan todas las estructura de datos de java).</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#funcion-de-un-interfaz","title":"Funci\u00f3n de un interfaz","text":"<p>Un interfaz define total o parcialmente una serie de m\u00e9todos. Los m\u00e9todos son, conceptualmente, la forma en que podemos interactuar con un objeto. De este modo podemos decir que cada interfaz define una forma de interactuar con un objeto. El objeto implementa los m\u00e9todos necesarios para realizar dicha interacci\u00f3n.</p> <p>Estas interacciones en la pr\u00e1ctica se concretan en una funcionalidad. Es decir, los m\u00e9todos que se definen en el interfaz permiten que los objetos que lo implementen sean capaces de realizar una serie de operaciones.</p> <p>Por ejemplo, los objetos cuya clase implemente el interfaz iterable podr\u00e1n ser iterados empleando el bucle <code>for-each</code>. Los objetos cuya clase implemente el interfaz Comparable podr\u00e1n ser ordenados usando las funciones de ordenaci\u00f3n. etc.</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#interfaces-y-clases-de-las-colecciones","title":"Interfaces y clases de las colecciones","text":"<p>La jerarqu\u00eda de interfaces y clases que veremos en este tema es el siguiente:</p> <p></p> <p>En primer lugar vemos que todos los elementos que vamos a ver son iterables ya que todos heredan de Collection y \u00e9ste a su vez de Iterable.</p> <p>List, Set y Queue son sub-interfaces de Collection as\u00ed que tendr\u00e1n todas las capacidades de una colecci\u00f3n y adem\u00e1s cada una de ellas a\u00f1adir\u00e1n cualidades propias (las listas tendr\u00e1n asignadas posiciones a sus elementos, etc.)</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#el-interfaz-iterable","title":"El interfaz <code>Iterable</code>","text":"<p>Este interfaz se utiliza para indicar que un objeto puede ser recorrido, o lo que es lo mismo, se puede iterar sobre \u00e9l. Las clases que implementan el interfaz <code>Iterable</code> han de implementar un m\u00e9todo (<code>iterator()</code>) que permita obtener un objeto <code>Iterator</code> que, a su vez, ha de permitir determinar si hemos llegado al final de la lista (<code>hasNext()</code>) y obtener un elemento de la lista y avanzar al siguiente (<code>next()</code>).</p> <p>El interfaz <code>Iterable</code> utiliza gen\u00e9ricos de modo que el iterador podr\u00e1 aplicarse sobre cualquier tipo de dato (clase) que deseemos.</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#el-interfaz-iterator","title":"El interfaz <code>Iterator</code>","text":"<p>Como acabamos de ver el interfaz <code>Iterable</code> exige que se implemente un m\u00e9todo (<code>iterator()</code>) que devuelva un objeto <code>Iterator</code>. Este objeto <code>Iterator</code> es el que se encarga de recorrer la lista y de devolver los elementos de la misma.</p> <p>Al igual que el interfaz <code>Iterable</code>, el interfaz <code>Iterator</code> utiliza gen\u00e9ricos de modo que el iterador podr\u00e1 aplicarse sobre cualquier tipo de dato que deseemos. El tipo de dato que se utilice en el interfaz <code>Iterator</code> ha de ser el mismo que se utilice en el interfaz <code>Iterable</code>.</p> <p>Por \u00faltimo <code>Iterator</code> exige que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>hasNext()</code>: Devuelve <code>true</code> si quedan elementos por recorrer y <code>false</code> en caso contrario.</li> <li><code>next()</code>: Devuelve el siguiente elemento de la lista y avanza el iterador al siguiente elemento.</li> </ul> <p>De este modo podemos recorrer una lista usando un bucle while:</p> <pre><code>// Creemos primero un iterable como por ejemplo una lista de cadenas:\nLista&lt;String&gt; lista = new ArrayList&lt;String&gt;();\nlista.add(\"Hola\");\nlista.add(\"Mundo\");\nlista.add(\"!\");\n\n// Ahora podremos acceder a su iterador:\nIterator&lt;String&gt; iterador = lista.iterator();\n\n// Y recorrerla usando un bucle while:\nwhile (iterador.hasNext()) {\n    System.out.println(iterador.next());\n}\n\n// o usando un bucle for:\nfor (Iterator&lt;String&gt; iterador = lista.iterator(); iterador.hasNext(); ) {\n    System.out.println(iterador.next());\n}\n\n// o usando un bucle for-each (lo m\u00e1s sencillo en el caso de un iterable):\nfor (String elemento : lista) {\n    System.out.println(elemento);\n}\n</code></pre> <p>Puesto que el iterador estar\u00e1 muy ligado a la colecci\u00f3n que estamos recorriendo, es habitual que se implemente como una clase interna de la colecci\u00f3n.</p>"},{"location":"Tema%207/Tema%207.2%20-%20Collections/#el-interfaz-collection","title":"El interfaz <code>Collection</code>","text":"<p><code>Collection</code> hereda del interfaz <code>Iterable</code>. Esto implica que toda clase que implemente <code>Collection</code> tambi\u00e9n ha de implementar los m\u00e9todos que exige el interfaz <code>Iterable</code> (<code>iterator()</code>) y, a su vez, hemos de crear una clase que implemente el interfaz <code>Iterator</code> que funcione para nuestra colecci\u00f3n.</p> <p>Adem\u00e1s del m\u00e9todo anterior, <code>Collection</code>, tambi\u00e9n exige que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>size()</code>: Indicar\u00e1 el n\u00famero de elementos que contiene la colecci\u00f3n.</li> <li><code>isEmpty()</code>: Indicar\u00e1 si la colecci\u00f3n est\u00e1 o no vac\u00eda.</li> <li><code>contains(Object o)</code>: Permite determinar si el objeto <code>o</code> se encuentra dentro de la colecci\u00f3n.</li> <li><code>containsAll(Collection c)</code>: Determina si una colecci\u00f3n contiene todos los elementos de la colecci\u00f3n <code>c</code>. </li> <li><code>add(Object o)</code>: A\u00f1ade un elemento nuevo <code>o</code> a la colecci\u00f3n  (opcional).</li> <li><code>addAll(Collection c)</code>: Igual al anterior pero para una colecci\u00f3n de elementos  (opcional).</li> <li><code>remove(Object o)</code>: Elimina un objeto <code>o</code> de la colecci\u00f3n  (opcional).</li> <li><code>removeAll(Collection c)</code>: Igual al anterior pero para una colecci\u00f3n de elementos  (opcional).</li> <li><code>clear()</code>: Elimina todos los elementos de la colecci\u00f3n (opcional).</li> <li><code>retainAll(Collection c)</code>: Mantendr\u00e1 en la colecci\u00f3n \u00fanicamente los elementos que tambi\u00e9n se encuentran en la colecci\u00f3n <code>c</code> (intersecci\u00f3n)  (opcional).</li> <li><code>toArray()</code>: Devolver\u00e1 un array conteniendo todos los elementos e la colecci\u00f3n.</li> <li><code>toArray(T[] a)</code>:  Devolver\u00e1 un array conteniendo todos los elementos de la colecci\u00f3n; el tipo del array devuelto ha de ser el mismo del del array indicado <code>T</code>.</li> </ul> <p>En una colecci\u00f3n no hay posiciones. S\u00f3lo podremos a\u00f1adir o eliminar elementos pero no podremos ni insertar un valor en una posici\u00f3n ni obtener el contenido de una posici\u00f3n. Podr\u00edamos decir que una <code>Collection</code> es ignorante respecto a \u00edndice de sus elementos.</p>"},{"location":"Tema%207/Tema%207.3%20-%20Listas/","title":"Tema 7.3: Listas","text":""},{"location":"Tema%207/Tema%207.3%20-%20Listas/#list","title":"<code>List</code>","text":"<p>El interfaz <code>List</code> indica que una colecci\u00f3n de elementos se encuentra agrupado en forma de lista (existe un orden en el almacenamiento). En una lista podremos acceder a cada elemento indicando su \u00edndice o posici\u00f3n dentro de la lista (empezando a contar en cero).</p> <p>A diferencia de un conjunto, una lista admite elementos duplicados.</p> <p>Adem\u00e1s de los m\u00e9todos requeridos por el interfaz <code>Collection</code>, el interfaz <code>List</code> requiere que se implementen los siguientes m\u00e9todos:</p> <ul> <li><code>T get(int index)</code>: Nos devolver\u00e1 el elemento (de tipo T :arrow_right: gen\u00e9ricos) que se encuentra en la posici\u00f3n <code>index</code> de la lista (la primera posici\u00f3n de la lista ser\u00e1 0).</li> <li><code>T set(int index, T element)</code>: Coloca el valor <code>element</code> en la posici\u00f3n <code>index</code> de la lista y devuelve el elemento que se encontraba antes en dicha posici\u00f3n.</li> <li><code>void add(int index, T element)</code>: A\u00f1ade o inserta el elemento <code>element</code> en la posici\u00f3n <code>index</code> de la lista.</li> <li><code>T remove(int index)</code>: Elimina el elemento que se encuentra en la posici\u00f3n <code>index</code> de la lista y lo devuelve como resultado.</li> <li><code>int indexOf(Object o)</code>: Devuelve la posici\u00f3n de la primera aparici\u00f3n del elemento <code>o</code> de la lista.</li> <li><code>int lastIndexOf(Object o)</code>: Devuelve la posici\u00f3n d</li> <li>e la \u00faltima aparici\u00f3n del elemento <code>o</code> en la lista.</li> <li><code>ListIterator&lt;T&gt; listIterator()</code>: Devuelve un tipo especial de iterador <code>ListIterator</code>.</li> <li><code>ListIterator&lt;T&gt; listIterator(int index)</code>: Devuelve un tipo especial de iterador <code>ListIterator</code> apuntando a la posici\u00f3n <code>index</code> de la lista.</li> <li><code>List&lt;T&gt; subList(int fromIndex, int toIndex)</code>: Devuelve una lista conteniendo los elementos desde la posici\u00f3n <code>fromIndex</code> (incluy\u00e9ndola) hasta la posici\u00f3n <code>toIndex</code> (excluy\u00e9ndola).</li> </ul>"},{"location":"Tema%207/Tema%207.3%20-%20Listas/#arraylist","title":"<code>ArrayList</code>","text":"<p>La clase <code>ArrayList</code> implementa una lista de elementos que internamente se almacenan en un array. Esta clase es muy eficiente para acceder a sus elementos de ya que se puede acceder a ellos indicando su posici\u00f3n (\u00edndice) y no es necesario recorrer la lista para encontrarlos (pues estamos trabajando por debajo con un array).</p> <p>A diferencia de un array, el tama\u00f1o de un <code>ArrayList</code> puede crecer o decrecer din\u00e1micamente. Los elementos de un <code>ArrayList</code> pueden ser de cualquier tipo (gen\u00e9ricos).</p> <p>Puesto que un <code>ArrayList</code> guarda internamente los datos en un array tendr\u00e1 problemas cuando al crecer de tama\u00f1o. Si va creciendo llegar\u00e1 un momento en que se quede sin espacio en el array interno. Para poder almacenar m\u00e1s valores cuando ya est\u00e9 lleno se ver\u00e1 obligado a crear un array con m\u00e1s espacio libre y copiar los valores del array viejo al nuevo. Esta operaci\u00f3n llevar\u00e1 bastante tiempo.</p>"},{"location":"Tema%207/Tema%207.3%20-%20Listas/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<pre><code>ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();\n\nlista.add(\"Hola\");\nlista.add(\"Mundo\");\nlista.add(\"Cruel\");\nlista.add(\"!\");\n\n// Para mostrar el contenido de la lista podemos usar un bucle for-each:\nfor (String s : lista) {\n    System.out.println(s);\n}\n\n// O directamente el m\u00e9todo toString() de la lista:\nSystem.out.println(lista);\n\n// Podemos acceder a los elementos de la lista indicando su posici\u00f3n:\nfor (int i = 0; i &lt; lista.size(); i++) {\n    System.out.printf(\"Elemento n\u00famero %d: %s.%n\", i, lista.get(i));\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.3%20-%20Listas/#linkedlist","title":"<code>LinkedList</code>","text":"<p>El funcionamiento de una <code>LinkedList</code> es similar al de un <code>ArrayList</code> pero internamente no se almacenan los elementos en un array sino en una lista enlazada. Esto hace que la inserci\u00f3n y eliminaci\u00f3n de elementos sea m\u00e1s eficiente que en un <code>ArrayList</code> pero el acceso a un elemento concreto es, en general, m\u00e1s lento.</p> <p>Si necesitamos guardar una lista de datos que no va a cambiar mucho a lo largo del tiempo pero a la que vamos a acceder con frecuencia, es mejor usar un <code>ArrayList</code>. Si, por el contrario, vamos a modificar la lista con m\u00e1s frecuencia de la que vamos a acceder a ella es mejor usar un <code>LinkedList</code>.</p>"},{"location":"Tema%207/Tema%207.3%20-%20Listas/#arraylist-vs-linkedlist","title":"<code>ArrayList</code> vs <code>LinkedList</code>","text":"<p>Resumiendo, el acceso a una posici\u00f3n es instant\u00e1nea en un <code>ArrayList</code> pero depender\u00e1 de la posici\u00f3n en un <code>LinkedList</code>. La inserci\u00f3n y eliminaci\u00f3n de elementos es lenta (algunas veces habr\u00e1 que cambia rel tama\u00f1o) en un <code>ArrayList</code> pero instant\u00e1nea en un <code>LinkedList</code>.</p>"},{"location":"Tema%207/Tema%207.4%20-%20Colas/","title":"Tema 7.4: Colas, interfaz <code>Queue</code>","text":"<p>Las colas de Java funcionan como las colas en el mundo real. Los elementos se a\u00f1aden al final de la cola y se extraen del principio: primero en entrar, primero en salir (FIFO: First In, First Out).</p> <p>Las clases que implementen esta interfaz emular\u00e1n el comportamiento de una cola utilizando los siguientes m\u00e9todos:</p> <ul> <li><code>boolean add(E e)</code>: A\u00f1ade el elemento <code>e</code> al final de la cola. Devuelve <code>true</code> si se ha podido a\u00f1adir y lanzar\u00e1 una excepci\u00f3n <code>IllegalStateException</code> si no hay espacio disponible.</li> <li><code>boolean offer(E e)</code>: Inserta el elemento <code>e</code> al final de la cola. Devuelve <code>true</code> si se ha podido a\u00f1adir y <code>false</code> si no hay espacio disponible.</li> <li><code>E element()</code>: Devuelve el primer elemento de la cola. Lanzar\u00e1 una excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda. Sin eliminar el elemento de la cola.</li> <li><code>E peek()</code>: Devuelve el primer elemento de la cola. Devuelve <code>null</code> si la cola est\u00e1 vac\u00eda. Sin eliminar el elemento de la cola.</li> <li><code>E poll()</code>: Devuelve el primer elemento de la cola. Devuelve <code>null</code> si la cola est\u00e1 vac\u00eda. Eliminando el elemento de la cola.</li> <li><code>E remove()</code>: Devuelve el primer elemento de la cola. Lanzar\u00e1 una excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda. Eliminando el elemento de la cola.</li> </ul> <p>Como podemos ver hay dos m\u00e9todos para cada operaci\u00f3n, uno de ellos lanza una excepci\u00f3n si no se puede realizar la operaci\u00f3n y el otro devuelve un valor especial para indicar que no se ha podido realizar la operaci\u00f3n:</p> <ul> <li>Inserci\u00f3n de un elemento al final de la cola: <code>add</code> lanza una excepci\u00f3n (<code>IllegalStateException</code>) si no hay espacio libre (colas con l\u00edmite de tama\u00f1o) y <code>offer</code> devolver\u00e1 falso si no pudo insertar.</li> <li>Leer el elemento cabeza de la cola sin sacarlo: <code>element</code> lanza una excepci\u00f3n (<code>NoSuchElementoException</code>) si la cola est\u00e1 vac\u00eda y <code>peek</code> devuelve <code>null</code> si la cola est\u00e1 vac\u00eda.</li> <li>Extraer el elemento cabeza de la cola: <code>remove</code> lanza una excepci\u00f3n (<code>NoSuchElementException</code>) si la cola est\u00e1 vac\u00eda y <code>poll</code> devuelve <code>null</code> si la cola est\u00e1 vac\u00eda.</li> </ul>"},{"location":"Tema%207/Tema%207.4%20-%20Colas/#priorityqueue","title":"<code>PriorityQueue</code>","text":"<p>La clase <code>PriorityQueue</code> implementa el interfaz <code>Queue</code>. Adem\u00e1s los elementos de la cola se ordenan seg\u00fan su prioridad, que se define mediante un objeto <code>Comparator</code> que se pasa al constructor de la cola. Si no se pasa ning\u00fan <code>Comparator</code> se usar\u00e1 el orden natural de los elementos.</p> <p>Esto no significa que los elementos se ordenen autom\u00e1ticamente cuando se a\u00f1aden a la cola. Los elementos se obtendr\u00e1n ordenados cuando se extraigan de la cola.</p>"},{"location":"Tema%207/Tema%207.4%20-%20Colas/#comparadores","title":"Comparadores","text":"<p>Un comparador ser\u00e1 un objeto que implemente la interfaz <code>Comparator</code>. \u00c9sta exige que se implemente el m\u00e9todo <code>compare</code> que recibe dos objetos y devuelve un entero que indica si el primer objeto es menor (menor que 0), igual (0) o mayor que el segundo (mayor que 0).</p> <pre><code>public class ComparadorInverso implements Comparator&lt;Integer&gt; {\n    @Override\n    public int compare(Integer i1, Integer i2) {\n        return i2 - i1;\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main() {\n        PriorityQueue&lt;Integer&gt; cola = new PriorityQueue&lt;&gt;(new ComparadorInverso());\n        cola.add(1);\n        cola.add(2);\n        cola.add(3);\n        cola.add(4);\n        cola.add(5);\n        cola.add(6);\n        cola.add(7);\n        cola.add(8);\n        cola.add(9);\n        cola.add(10);\n        while (!cola.isEmpty()) {\n            System.out.println(cola.poll());\n        }\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.4%20-%20Colas/#interfaz-comparator","title":"Interfaz <code>Comparator</code>","text":"<p>Este interfaz le concede a un objeto la capacidad de establecer un orden sobre un tipo de objetos. Para ello, el objeto debe implementar el m\u00e9todo <code>compare</code> que recibe dos objetos del tipo que se quiere ordenar y devuelve un entero que indica si el primer objeto es menor (menor que 0), igual (0) o mayor que el segundo (mayor que 0).</p> <pre><code>// Si queremos establecer una cola de prioridad para personas en las que se priorice la edad de menor a mayor:\npublic class MiComparador implements Comparator&lt;Persona&gt; {\n    @Override\n    public int compare(Persona p1, Persona p2) {\n        return p1.getEdad() - p2.getEdad();\n    }\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.5%20-%20Conjuntos/","title":"Tema 7.5: Conjuntos","text":"<p>L</p>"},{"location":"Tema%207/Tema%207.5%20-%20Conjuntos/#interfaz-set","title":"Interfaz <code>Set</code>","text":"<p>Los conjuntos de Java funcionan como los conjuntos en matem\u00e1ticas. Los elementos que contiene son \u00fanicos y no se pueden repetir. Adem\u00e1s, no tienen un orden determinado.</p> <p>Las clases que implementen esta interfaz emular\u00e1n el comportamiento de un conjunto utilizando los siguientes m\u00e9todos:</p> <ul> <li><code>boolean add(E e)</code>: A\u00f1ade el elemento <code>e</code> al conjunto. Devuelve <code>true</code> si se ha podido a\u00f1adir y <code>false</code> si el elemento ya estaba en el conjunto.</li> <li></li> </ul>"},{"location":"Tema%207/Tema%207.5%20-%20Conjuntos/#hashset","title":"<code>HashSet</code>","text":""},{"location":"Tema%207/Tema%207.5%20-%20Conjuntos/#treeset","title":"<code>TreeSet</code>","text":""},{"location":"Tema%207/Tema%207.6%20-%20Mapas/","title":"Tema 7.5: Mapas","text":"<p>Los mapas son estructuras de datos de Java que almacenan dos valores por cada entrada. Un de los valores funcionar\u00e1 como una clave a partir de la cual se podr\u00e1 obtener el valor con el que est\u00e1 emparejado. As\u00ed, diremos que un mapa se compone de pares clave - valor.</p> <p>En un mapa nunca podr\u00e1n existir dos claves iguales.</p> <p>Los mapas, al igual que todas las dem\u00e1s estructuras de datos (salvo los arrays) son gen\u00e9ricos, por lo que habr\u00e1 que indicar el tipo tanto de la clave como del valor.</p>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#definicion-de-un-mapa","title":"Definici\u00f3n de un mapa","text":"<p>La sintaxis para definir un mapa es la siguiente:</p> <pre><code>Map&lt;String, Alumno&gt; mapaAlumnos = new HashMap&lt;&gt;();\n</code></pre> <p>Para instar elementos en el mapa deberemos de usar el m\u00e9todo <code>put</code> pas\u00e1ndole el par clave - valor:</p> <pre><code>mapaAlumnos.put(\"primero\", new Alumno(\"\u00c1ngel\", \"32124F\", \"16-07-2005\"));\n</code></pre> <p>Y para extraer elementos (en nuestro ejemplo de tipo <code>Alumno</code>) usaremos <code>get</code> pas\u00e1ndolo la clave.</p> <pre><code>Alumno alumno = mapaAlumnos.get(\"primero\");\n</code></pre>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#tipos-de-mapas","title":"Tipos de mapas","text":"<p>En Java existen tres tipos de mapas ya implementados:</p> <ul> <li><code>HashMap</code></li> <li><code>TreeMap</code></li> <li><code>LinkedHashMap</code></li> </ul> <p>Las diferencias existentes entre ellos son respecto a c\u00f3mo almacenan los datos internamente y, como consecuencia de ello, la velocidad con que se pueden realizar las operaciones de inserci\u00f3n y extracci\u00f3n de datos.</p>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#hashmap","title":"<code>HashMap</code>","text":"<p>Almacena los elementos en una tabla hash y es el m\u00e1s r\u00e1pido. Como consecuencia de su m\u00e9todo de almacenamiento no se puede saber a priori con qu\u00e9 orden se iterar\u00eda sobre los datos. Es decir, un <code>HashMap</code> no garantiza ning\u00fan orden en sus elementos cuando es recorrido.</p>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#treemap","title":"<code>TreeMap</code>","text":"<p>Un <code>TreeMap</code> emplea una estructura de \u00e1rbol binario. Esto permite que el <code>TreeMap</code> ofrezca una complejidad logar\u00edtmica (log(n)) bastante eficiente para las operaciones <code>containsKey</code>, <code>get</code>, <code>put</code> and <code>remove</code>.</p> <p>Los elementos se encontrar\u00e1n ordenados con respecto a la clave. Se le puede pasar un <code>Comparator</code> para establecer un orden respecto a la clave.</p>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#linkedhashmap","title":"<code>LinkedHashMap</code>","text":"<p>Un <code>LinkedHashMap</code> almacena los datos de la misma forma que un <code>HashMap</code> pero guarda adem\u00e1s informaci\u00f3n sobre el orden en que fueron insertados. De este modo, al iterar sobre un <code>LinkedHashMap</code> \u00e9ste se recorrer\u00e1 en el orden en que fueron introducidas sus entradas. Es decir, un <code>LinkedHashMap</code> garantiza que sus elementos se recorrer\u00e1n en el orden en que fueron insertados.</p>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#como-recorrer-un-mapa","title":"Como recorrer un mapa","text":"<p>Existen varias formas de recorrer un mapa dependiendo de la funci\u00f3n que usemos para obtener su contenido en forma de <code>Iterable</code>:</p> <ul> <li><code>entrySet()</code>: Nos devolver\u00e1 el contenido de un mapa en forma de un conjunto de las entradas (pares clave - valor) del mapa.</li> <li><code>keySet()</code>: Nos devolver\u00e1 a su vez un conjunto con las claves del mapa.</li> <li><code>values()</code>: De manera similar a las anteriores, nos devolver\u00e1 un conjunto con los valores del mapa.</li> </ul>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#bucle-for-mejorado","title":"Bucle <code>for</code> mejorado","text":"<p>Este bucle podremos utilizarlo tanto con <code>entrySet()</code>:</p> <pre><code>for (Entry&lt;String, Alumno&gt; entrada : mapa.entrySet()) {\n    System.out.println(entrada.getKey() + \" -&gt; \" + entrada.getValue());\n}\n</code></pre> <p>como con <code>keySet()</code>:</p> <pre><code>for (String clave : mapa.keySet()) {\n    System.out.println(clave + \" -&gt; \" + mapa.get(clave));\n}\n</code></pre> <p>o directamente con <code>values()</code>:</p> <pre><code>for (Alumno valor : mapa.values()) {\n    System.out.println(valor);\n}\n</code></pre>"},{"location":"Tema%207/Tema%207.6%20-%20Mapas/#metodo-foreach","title":"M\u00e9todo <code>forEach()</code>","text":"<p>Los mapas, as\u00ed como todas las clases que implementan <code>Collection</code>, disponen de un m\u00e9todo denominado <code>forEach()</code>. Este m\u00e9todo acepta una funci\u00f3n lambda con dos par\u00e1metros como entrada. El primer par\u00e1metro de la lambda ser\u00e1 la clave y el segundo su valor asociado. Esta funci\u00f3n lambda se aplicar\u00e1 a cada entrada del mapa.</p> <pre><code>mapa.forEach((k, v) -&gt; System.out.println(k + \" -&gt; \" + v));\n</code></pre>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/","title":"Tema 7.7: EXTRA El tiempo, The_Times, en Java: <code>Date</code>, <code>Calendar</code> y <code>java.time</code>","text":"<p>En todos los lenguajes de programaci\u00f3n existe la necesidad de almacenar valores que representen el tiempo. Es necesario saber, por ejemplo, cuando fue la \u00faltima vez que se accedi\u00f3 o modific\u00f3 un fichero, en qu\u00e9 fecha se realiz\u00f3 la \u00faltima actualizaci\u00f3n o en qu\u00e9 momento se estableci\u00f3 una conexi\u00f3n con un servidor.</p> <p>La tarea de llevar cuenta de en que momento se produjo un evento se complica a\u00fan m\u00e1s cuando tenemos que tener en cuenta los distintos usos horarios. A\u00fan m\u00e1s si tenemos que tener en cuenta que distintas  culturas (como China, Jap\u00f3n) tienen distintos calendarios.</p> <p>Java intenta resolver este problema mediante las clases <code>Date</code> y <code>Calendar</code>.</p>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#date","title":"<code>Date</code>","text":"<p>Este es el sistema antiguo y pr\u00e1cticamente obsoleto de almacenar fechas y horas.</p> <p>En Java (al igual que otros muchos lenguajes) se mide el tiempo contando los milisegundos (segundos, microsegundos o nanosegundos en otros sistemas) que han transcurrido desde el a\u00f1o cero de la inform\u00e1tica o tiempo de Unix (oo:oo:oo del 1 de enero de 1970).</p> <p>Para crear un objeto <code>Date</code> escribiremos el siguiente c\u00f3digo:</p> <pre><code>Date d = new Date();\n</code></pre> <p>de esta forma creamos el objeto <code>d</code> con la fecha y hora del instante en que se haya ejecutado la sentencia.</p> <p>Si queremos obtener el n\u00famero de milisegundos desde el 1 de enero de 1970 almacenado en <code>d</code> simplemente tendremos que mostrar:</p> <pre><code>System.out.println(\"Milisegundos desde el origen de tiempo: \" + d.getTime());\n</code></pre> <p>Pero para obtener el d\u00eda, mes y a\u00f1o lo tenemos complicado...</p>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#calendar-al-rescate","title":"<code>Calendar</code> al rescate","text":"<p>Trabajar con <code>Date</code> para obtener los valores del a\u00f1o, d\u00eda del mes, de la semana, etc. es bastante complicado. Para facilitar el trabajo se cre\u00f3 la clase <code>Calendar</code>. <code>Calendar</code> es una actualizaci\u00f3n <code>Date</code> pero que no lo substituye. Funciona en tandem con <code>Date</code>.</p> <p>Por ejemplo, para crear un <code>Calendar</code> que represente la fecha y hora actual escribiremos:</p> <pre><code>Calendar c = Calendar.getInstance();\n</code></pre> <p>Si queremos obtener a\u00f1o, mes y d\u00eda de un objeto <code>Date</code>:</p> <pre><code>Date d = new Date();\nCalendar c = Calendar.getInstance();\nc.setTime(d);\nint year = c.get(Calendar.YEAR);\nint month = c.get(Calendar.MONTH);\n/...\n</code></pre>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#paquete-javatime","title":"Paquete <code>java.time</code>","text":"<p>En cualquier caso parece que <code>Calendar</code> no fue una soluci\u00f3n definitiva si no m\u00e1s bien un parche y finalmente se desarroll\u00f3 el paquete <code>java.time</code> con las clases <code>LocalDate</code> y  <code>LocalDateTime</code> para facilitar el tratamiento del tiempo.</p>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#localdate","title":"<code>LocalDate</code>","text":"<p>Para almacenar el momento actual usaremos el m\u00e9todo <code>now()</code>:</p> <pre><code>LocalDate hoy = LocalDate.now();\n</code></pre> <p>Y para obtener a\u00f1o, mes y d\u00eda:</p> <pre><code>int a\u00f1o = hoy.getYear();\nint mes = hoy.getMonth();\nint diaMes = hoy.getDayOfMonth();\nint diaSemana = hoy.getDayOfWeek();\n</code></pre>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#localdatetime","title":"<code>LocalDateTime</code>","text":"<p>Almacena dos valores:</p> <ul> <li>El numero de segundos transcurridos desde la medianoche del 1 de enero de 1970.</li> <li>El n\u00famero de nanosegundos transcurridos dentro del segundo en que nos encontramos.</li> </ul>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#formato-de-las-fechas","title":"Formato de las fechas","text":"<p>Para dar formato a las fechas se usar\u00e1 la clase <code>DateTimeFormatter</code>:</p> <pre><code>LocalDateTime ahora = LocalDateTime.now();\nDateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;\nString ahoraString = ahora.format(formatter);\n\nSystem.out.println(\"La fecha de hoy es: \" + ahoraString);\n</code></pre> <p>Tambi\u00e9n podremos crear un formateador a nuestra medida usando patrones:</p> <pre><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy hh:mm:ss\");\nString ahoraString = ahora.format(formatter);\n\nSystem.out.println(\"La fecha de hoy es: \" + ahoraString);\n</code></pre>"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#formatos-predefinidos","title":"Formatos predefinidos","text":"Formatter Description Example ofLocalizedDate(dateStyle) Formatter with date style from the locale '2011-12-03' ofLocalizedTime(timeStyle) Formatter with time style from the locale '10:15:30' ofLocalizedDateTime(dateTimeStyle) Formatter with a style for date and time from the locale '3 Jun 2008 11:05:30' ofLocalizedDateTime(dateStyle,timeStyle) Formatter with date and time styles from the locale '3 Jun 2008 11:05' BASIC_ISO_DATE Basic ISO date '20111203' ISO_LOCAL_DATE ISO Local Date '2011-12-03' ISO_OFFSET_DATE ISO Date with offset '2011-12-03+01:00' ISO_DATE ISO Date with or without offset '2011-12-03+01:00'; '2011-12-03' ISO_LOCAL_TIME Time without offset '10:15:30' ISO_OFFSET_TIME Time with offset '10:15:30+01:00' ISO_TIME Time with or without offset '10:15:30+01:00'; '10:15:30' ISO_LOCAL_DATE_TIME ISO Local Date and Time '2011-12-03T10:15:30' ISO_OFFSET_DATE_TIME Date Time with Offset 2011-12-03T10:15:30+01:00' ISO_ZONED_DATE_TIME Zoned Date Time '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_DATE_TIME Date and time with ZoneId '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_ORDINAL_DATE Year and day of year '2012-337' ISO_WEEK_DATE Year and Week '2012-W48-6' ISO_INSTANT Date and Time of an Instant '2011-12-03T10:15:30Z' RFC_1123_DATE_TIME RFC 1123 / RFC 822 'Tue, 3 Jun 2008 11:05:30 GMT'"},{"location":"Tema%207/Tema%207.7%20-%20Extra%20-%20El%20tiempo/#formatos-construidos","title":"Formatos construidos","text":"<p>Los s\u00edmbolos para construir formatos son (entre otros):</p> S\u00edmbolo Significado Representaci\u00f3n Ejemplo G era texto AD; Anno Domini; A u a\u00f1o a\u00f1o 2004; 04 y a\u00f1o de la era a\u00f1o 2004; 04 D d\u00eda del a\u00f1o n\u00famero 189 M/L mes del a\u00f1o n\u00famero / texto 7; 07; Jul; July; J d d\u00eda del mes n\u00famero 10 E d\u00eda de la semana texto Tue; Tuesday; T a am-pm texto PM h hora 1-12 n\u00famero 12 k hora formato 1-24 n\u00famerop 15 <pre><code>  Symbol  Meaning                     Presentation      Examples\n  ------  -------                     ------------      -------\n   G       era                         text              AD; Anno Domini; A\n   u       year                        year              2004; 04\n   y       year-of-era                 year              2004; 04\n   D       day-of-year                 number            189\n   M/L     month-of-year               number/text       7; 07; Jul; July; J\n   d       day-of-month                number            10\n\n   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter\n   Y       week-based-year             year              1996; 96\n   w       week-of-week-based-year     number            27\n   W       week-of-month               number            4\n   E       day-of-week                 text              Tue; Tuesday; T\n   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T\n   F       week-of-month               number            3\n\n   a       am-pm-of-day                text              PM\n   h       clock-hour-of-am-pm (1-12)  number            12\n   K       hour-of-am-pm (0-11)        number            0\n   k       clock-hour-of-am-pm (1-24)  number            0\n\n   H       hour-of-day (0-23)          number            0\n   m       minute-of-hour              number            30\n   s       second-of-minute            number            55\n   S       fraction-of-second          fraction          978\n   A       milli-of-day                number            1234\n   n       nano-of-second              number            987654321\n   N       nano-of-day                 number            1234000000\n</code></pre>"},{"location":"Tema%207/Tema%207.8%20-%20EXTRA%20-%20Lambdas/","title":"Tema 7.8 - Extra: Lambdas en Java","text":"<p>Las lambda (equivalentes a m\u00e9todos en Java) son funciones que se pueden pasar directamente como par\u00e1metro a un m\u00e9todo.</p> <p>Para poder utilizar una lambda (o expresi\u00f3n lambda) como par\u00e1metro hemos de declarar el argumento del m\u00e9todo como un interfaz que s\u00f3lo tenga un m\u00e9todo requerido.</p> <p>As\u00ed, podr\u00edamos decir que el mecanismo de uso de las lambda consta de tres partes:</p> <ul> <li>El interfaz que define c\u00f3mo ha de ser la lambda.</li> <li>El m\u00e9todo que acepta como par\u00e1metro una variable del tipo del interfaz.</li> <li>Y la expresi\u00f3n lambda propiamente dicha.</li> </ul> <p>Ve\u00e1moslo con un ejemplo:</p> <p>Imaginemos que tenemos una clase <code>Alumno</code> y deseamos ordenar objetos de dicha clase. Existe una interfaz en Java que nos permite definir formas de comparar objetos <code>Comparator</code>. Esta interfaz s\u00f3lo define como obligatorio el m\u00e9todo <code>compare</code> que admite dos argumentos.</p> <p>Si creamos un par de m\u00e9todos para obtener el primero y \u00faltimo alumno de una lista seg\u00fan alg\u00fan criterio podr\u00edamos hacer lo siguiente:</p> <pre><code>public static Alumno primero(List&lt;Alumno&gt; l, Comparator&lt;Alumno&gt; c) {\n    Alumno m = l.get(0);\n\n    for (Alumno a : l) {\n        if (c.compare(a, m) &lt; 0) {\n            m = a;\n        }\n    }\n\n    return m\n}\n\npublic static Alumno ultimo(List&lt;Alumno&gt; l, Comparator&lt;Alumno&gt; c) {\n    Alumno m = l.get(0);\n\n    for (Alumno a : l) {\n        if (c.compare(a, m) &gt; 0) {\n            m = a;\n        }\n    }\n\n    return m\n}\n</code></pre> <p>Dependiendo del comparador que le pasemos a los m\u00e9todos <code>primero</code> y <code>ultimo</code> devolver\u00e1n el alumno con menor (mayor) edad, menor (mayor) nota, etc.</p> <p>En lugar de crear una clase que implemente <code>Comparator</code> y a continuaci\u00f3n crear una instancia de la misma y pas\u00e1rsela al m\u00e9todo <code>menor</code>, lo que podremos hacer es pasar una expresi\u00f3n lambda:</p> <pre><code>// Para obtener el alumno con menor edad:\nAlumno menor = primero(alumnos, (a1, a2) -&gt; a1.edad() - a2.edad());\n\n// Para obtener el alumno con mejor nota:\nAlumno mejor = ultimo(alumnos, (a1, a2) -&gt; a1.nota() - a2.nota());\n</code></pre> <p>Si a1 tiene menor edad (nota) que a2 el resultado ser\u00e1 negativo (lo que indica que a1 es menor que a2). Si el resultado es cero significa que la edad de a1 y la de a2 son la misma y si el resultado es positivo significar\u00e1 que la edad (nota) de a2 ser\u00e1 mayor que la de a1.</p>"},{"location":"Tema%207/Tema%207.8%20-%20EXTRA%20-%20Lambdas/#asignar-lambdas-a-variables","title":"Asignar lambdas a variables","text":"<p>Es posible asignar expresiones lambda a variable si las declaramos usando la interfaz <code>Function</code>:</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; suma = (x, y) -&gt; x + y;\n</code></pre> <p>De esta forma asignamos una funci\u00f3n lambda a una variable. Si a continuaci\u00f3n queremos invocar dicha funci\u00f3n a partir de la variable hemos de llamar al m\u00e9todo <code>apply</code>:</p> <pre><code>int x = 10;\nint y = 20;\nint z = suma.apply(x, y);\nSystem.out.printf(\"z = %d.%n\", z); // Mostrar\u00e1 el valor 30 por consola.\n</code></pre> <p>Para funciones que s\u00f3lo admiten un par\u00e1metros podremos usar el interfaz <code>Function</code> que es gen\u00e9rico y requiere que indiquemos el tipo de la entrada y la salida:</p> <pre><code>Function&lt;String, Integer&gt; intToStr = i -&gt; Integer.parseInt(i);\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/","title":"Tema 8: Entrada y salida a ficheros","text":""},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escribir-texto-a-un-fichero","title":"Escribir texto a un fichero","text":"<p>Para escribir datos en un fichero lo primero que hemos de crear es un objeto de la clase <code>FileWriter</code>:</p> <pre><code>FileWriter fb = new FileWriter(\"fichero.txt\");\n</code></pre> <p>Ahora, para escribir en este objeto, que hace referencia a un fichero, hemos de usar un <code>BufferedWriter</code>. Un <code>BufferedWriter</code> ser\u00e1 un objeto que puede escribir en muchos sitios distintos por lo que hemos de indicarle que ba a trabajar sobre nuestro fichero:</p> <pre><code>FileWriter file = new FileWriter(\"fichero.txt\");\n\nBufferedWriter writer = new BufferedWriter(file);\n</code></pre> <p>A continuaci\u00f3n hemos de invocar al m\u00e9todo <code>write</code> del <code>BufferedWriter</code>:</p> <pre><code>FileWriter file = new FileWriter(\"fichero.txt\");\n\nBufferedWriter writer = new BufferedWriter(file);\n\nwriter.write(\"Hola mundo cruel\");\n</code></pre> <p>Finalmente, y ya que se traga de un buffer ((para m\u00e1s informaci\u00f3n sobre buffers)) hemos de cerrar  <code>BufferedWriter</code> para que los datos escritos, almacenados temporalmente en el buffer se pasen al archivo en disco.</p> <p>Pero si intentas escribir este c\u00f3digo en un IDE se mostrar\u00e1 un error: <code>Unhandled exception type IOException</code>. Esto se debe a que la creaci\u00f3n de un <code>FileWriter</code> puede lanzar una excepci\u00f3n de entrada salida (<code>IOException</code>).</p> <p>Para solventar este error podremos o bien indicar que el m\u00e9todo donde nos encontramos puede lanzar esta excepci\u00f3n (y pasar la patata caliente a otro):</p> <pre><code>public void miMetodo(String nombreFichero, String texto) throws IOException {\n    FileWriter file = new FileWriter(nombreFichero);\n\n    BufferedWriter writer = new BufferedWriter(file);\n\n    writer.write(texto);\n}\n</code></pre> <p>O bien rodear el c\u00f3digo con una estructura try-catch:</p> <pre><code>public void miMetodo(String fichero, String texto) {\n\n    try {\n        FileWriter file = new FileWriter(fichero);\n\n        BufferedWriter writer = new BufferedWriter(file);\n\n        writer.write(texto);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre> <p>Puesto que cuando creamos nuestro fichero para escribir no indicamos una ruta completa el fichero se crear\u00e1 en el directorio ra\u00edz de nuestro proyecto.</p> <p>Una cosa que no hemos de olvidar es que estos objetos est\u00e1n asociados a un recurso del sistema (el fichero que hemos abierto para escritura). De modo que este recurso estar\u00e1 ocupado mientras no indiquemos lo contrario. Para evitar que el recurso est\u00e9 ocupado indefinidamente hemos de liberarlo usando el m\u00e9todo <code>close()</code> cuando hayamos terminado de trabajar con \u00e9l. Adem\u00e1s, en este caso concreto, no se escribir\u00e1 nada en el fichero hasta que cerremos el recurso asociado:</p> <pre><code>public void miMetodo(String fichero, String texto) {\n\n    try {\n        FileWriter file = new FileWriter(fichero);\n\n        BufferedWriter writer = new BufferedWriter(file);\n\n        writer.write(texto);\n\n        writer.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#leer-texto-de-un-fichero","title":"Leer texto de un fichero","text":"<p>El proceso de lectura de un fichero es muy similar al de escritura.</p> <p>Primero hemos de crear un <code>BufferedReader</code> asociado al fichero que queremos leer:</p> <pre><code>public String leeFichero(String nombreFichero) {\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(nombreFichero));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre> <p>Para leer una l\u00ednea del fichero llamaremos al m\u00e9todo <code>readLine()</code> del objeto <code>BufferedReader</code>. Este m\u00e9todo devolver\u00e1 la siguiente linea del fichero o <code>null</code> si ya se ha llegado al final y no hay nada que leer:</p> <pre><code>public String leeFichero(String nombreFichero) {\n    String lineaLeida = null;\n    String textoLeido = null;\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(nombreFichero));\n\n        do {\n            lineaLeida = reader.readLine();\n            if (lineaLeida != null) textoSalida += lineaLeida + \"\\n\";\n\n        } while (lineaLeida != null);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return textoLeido;\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#sentencia-try-con-recursos","title":"Sentencia Try-con-recursos","text":"<p>Para evitar tener que cerrar expl\u00edcitamente los recursos que abrimos podemos usar una variante de try-catch pero de la siguiente forma:</p> <pre><code>try (FileReader fr = new FileReader(fileName); BufferedWriter writer = new BufferedWriter(fr)) {\n    // C\u00f3digo que utiliza el writer.\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>Esta sentencia asegura que tanto el <code>FileReader</code> como el <code>BufferedWriter</code> se cerrar\u00e1n cuando salgamos del bloque de c\u00f3digo d\u00f3nde se usan.</p> <p>Esto previene tanto que nos olvidemos de liberar un recurso como que la instrucci\u00f3n <code>close()</code> quedase sin ejecutarse en caso de que el programa fallase antes.</p>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#anadir-texto-a-un-fichero","title":"A\u00f1adir texto a un fichero","text":"<p>Si ejecutamos el c\u00f3digo de escritura de la secci\u00f3n anterior podremos comprobar que se sobrescribe el contenido del fichero. Si queremos a\u00f1adir texto sin sobrescribir hemos de usar un constructor distinto de <code>FileWriter</code>:</p> <pre><code>try (FileWriter fr = new FileWriter(fileName, true); BufferedWriter writer = new BufferedWriter(fr)) {\n    // Ahora a\u00f1adimos texto al fichero.\n    writer.write(txt);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>El constructor <code>FileWriter(String fileName, boolean append)</code> abrir\u00e1 el fichero para a\u00f1adir contenido si <code>append</code> es <code>true</code>.</p>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escritura-de-datos-bytes","title":"Escritura de datos / bytes","text":"<p>Lo que hemos visto hasta ahora fueron formas de escribir texto a ficheros. Es posible que en lugar de texto lo que necesitemos es leer o escribir datos en binario (como ser\u00eda el caso de un fichero de imagen, v\u00eddeo o audio). Para leer y escribir binario a un fichero hemos de utilizar los objetos <code>FileInputStream</code> y <code>FileOutputStream</code> respectivamente.</p>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#escritura-binaria-a-un-fichero","title":"Escritura binaria a un fichero","text":"<p>Para crear un <code>FileOutputStream</code> hemos de indicar el nombre del fichero (la ruta en realidad) y a\u00f1adir <code>true</code> si queremos indicar que deseamos a\u00f1adir datos al fichero en lugar de sobrescribirlo.</p> <pre><code>// Sobrescribir el fichero:\nOutputStream out = new FileOutputStream(fileName);\n</code></pre> <pre><code>// A\u00f1adir datos al fichero:\nOutputStream out = new FileOutputStream(fileName, true);\n</code></pre> <p>Para escribir datos podremos usar distintos m\u00e9todos pero el m\u00e1s sencillo ser\u00e1 <code>write</code> al que le pasaremos tres argumentos:</p> <ol> <li>El array de bytes que deseamos escribir.</li> <li>El n\u00famero de bytes del array que deseamos saltarnos (en nuestro caso 0).</li> <li>El n\u00famero de bytes del array que deseamos escribir (en nuestro caso la longitud del array).</li> </ol> <pre><code>// Creamos un array de bytes:\nbyte[] data = new byte[4092]; // Capacidad para 4 KiB de datos por ejemplo.\n\n// C\u00f3digo donde meter\u00edamos los datos en el array.\n// Supongamos que 128 bytes.\nint bytesStored = 128;\n\nOutputStream out = new FileOutputStream(fileName);\n\n// data es un byte[].\nout.write(data, 0, bytesStored);\n</code></pre> <p>Un <code>OutputStream</code> es un recurso que ha de ser cerrado despu\u00e9s de su uso por lo que deber\u00edamos usar <code>try</code>:</p> <pre><code>public void writeBinaryDataToFile(String fileName, byte[] data) {\n    try (OutputStream out = new FileOutputStream(fileName)) {\n        out.write(data, 0, data.length);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.0%20-%20Lectura%20y%20escritura%20a%20disco/#lectura-binaria-de-un-fichero","title":"Lectura binaria de un fichero","text":"<p>Este caso es muy similar al anterior pero hemos de indicar cuantos bytes vamos a intentar leer. Como ahora especificamos cu\u00e1nto leer podr\u00edamos encontrarnos con tres casos:</p> <ul> <li>Disponer de los bytes que dese\u00e1bamos leer.</li> <li>Que quede menos que leer que lo que hemos indicado.</li> <li>No tener nada que leer (fichero vaci\u00f3).</li> </ul> <p>Por este motivo el m\u00e9todo <code>read</code> de <code>InputStream</code> puede devolver dos valores:</p> <ul> <li><code>-1</code>: en caso de que no haya podido leer (ya hab\u00edamos alcanzado fin de fichero, fichero est\u00e1 vac\u00edo, etc.).</li> <li>Un valor entero: El n\u00famero de bytes le\u00eddos.</li> </ul> <p>Por lo tanto si deseamos leer el contenido total de un fichero a memoria usaremos el m\u00e9todo <code>readAllBytes</code> pero hemos de tener en cuenta que es posible que el fichero no quepa en memoria.</p> <pre><code>public byte[] readAllFromFile(Sting fileName) {\n    byte[] fileData = null;\n    try (InputStream input = new FileInputStream(fileName)) {\n        fileData = input.readAllBytes();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return fileData;\n}\n</code></pre> <p>Para leer el fichero en bloques de un tama\u00f1o determinado mientras haya algo que leer escribir\u00edamos:</p> <pre><code>public static final int BUFFER_SIZE = 4096; // 4 KiB.\n\n// m\u00e1s c\u00f3digo...\n\nbyte[] buffer = new byte[BUFFER_SIZE];\n\n// ...\n\nwhile ((bytesRead = input.read(buffer, 0, BUFFER_SIZE)) != -1) {\n    // Hacer cosas con los datos le\u00eddos, bytesRead bytes guardados en buffer.\n}\n</code></pre> <p>Explicaci\u00f3n:</p> <p>Cuando escribimos la instrucci\u00f3n <code>bytesRead = input.read(buffer, 0, BUFFER_SIZE)</code> entre par\u00e9ntesis lo que pasa el lo siguiente:</p> <ol> <li>Se intenta realizar la lectura invocando el m\u00e9todo <code>read(...)</code>.</li> <li>Se asigna el resultado de <code>read(...)</code> (-1 o el n\u00famero de bytes le\u00eddos) a la variable <code>bytesRead</code>.</li> <li>Se retorna el valor asignado.</li> </ol> <p>En el siguiente ejemplo:</p> <pre><code>int x, y, z;\nx = 10;\ny = 20;\n\nif ((z = x + y) &lt; 100) {\n    System.out.printf(\"%d + %d &lt; 100.%n\", x, y);\n} else {\n    System.out.printf(\"%d + %d &gt;= 100.%n\", x, y);\n}\nSystem.out.printf(\"%d + %d = d.%n\", x, y, z);\n</code></pre> <p>El valor de la suma de x y y (30) se asignar\u00e1 a z y a continuaci\u00f3n se comparar\u00e1 dicho valor con 100.</p>"},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/","title":"Tema 8.1: Serializables","text":""},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/#objetos-pojo-plain-old-java-object","title":"Objetos P.O.J.O. (Plain Old Java Object)","text":"<p>Un POJO es cualquier clase definida en Java que cumpla estas tres condiciones:</p> <ol> <li>No puede extender ninguna otra clase.</li> <li>No puede implementar ning\u00fan interfaz.</li> <li>No puede usar anotaciones externas.</li> </ol> <p>Veamos un ejemplo:</p> <p>La siguiente clase ser\u00e1 un POJO.</p> <pre><code>public class Gato {\n    String nombre;\n    LocalDate fechaNacimiento;\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/#objetos-javabean","title":"Objetos JavaBean","text":"<p>Un objeto JavaBean debe cumplir las siguientes condiciones:</p> <ol> <li>Ha de disponer de un constructor sin argumentos.</li> <li>Todas sus propiedades han de ser privadas.</li> <li>Tendr\u00e1 getters y setters p\u00fablicos.</li> <li>Ser\u00e1 serializable.</li> </ol> <p>Veamos un ejemplo:</p> <p>Convirtamos la clase <code>Gato</code> a un JavaBean:</p> <pre><code>public class Gato implements Serializable {\n    private String nombre;\n    private LocalDate fechaNacimiento;\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return fechaNacimiento\n    }\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/#serializable","title":"Serializable","text":"<p>Que una clase sea serializable quiere decir que dicha clase se puede escribir y leer de una base de datos o un fichero.</p> <p>Para que una clase sera serializable ha de implementar el interfaz <code>Serializable</code>.</p> <pre><code>public class Alumno implements Serializable {\n    // ...\n}\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/#guardar-objetos-en-ficheros","title":"Guardar objetos en ficheros","text":"<p>Los objetos serializables pueden ser escritos en ficheros y, obviamente, recuperados ley\u00e9ndolos del fichero.</p>"},{"location":"Tema%208/Tema%20-%208.1%20-%20Serializables/#escritura-de-objeto-a-fichero","title":"Escritura de objeto a fichero","text":"<p>Para escribir un objeto a un fichero hemos de utilizar un <code>ObjectOutputStream</code>. Esto objeto necesitar\u00e1 a su vez que le pasemos alg\u00fan lugar a d\u00f3nde enviar el objeto. En el caso de escritura a un fichero usaremos un <code>FileOutputStream</code>.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>Gato gatito = new Gato();\ngatito.setNombre(\"Michi\");\ngatito.setFechaNacimiento(new LocalDate())\n</code></pre>"},{"location":"Tema%208/Tema%20-%208.2%20-%20Acceso%20al%20sistema%20de%20ficheros/","title":"Tema 8.2: Acceso al sistema de ficheros","text":"<p>TODO: Ver el contenido de un directorio, trabajar con _path_s, etc.</p>"},{"location":"Tema%209/Tema%20-%209.0%20-%20Introduccion%20a%20C-sharp/","title":"Tema 9.0: Introducci\u00f3n a C Sharp","text":""},{"location":"Tema%209/Tema%20-%209.0%20-%20Introduccion%20a%20C-sharp/#instalacion-de-visual-studio","title":"Instalaci\u00f3n de Visual Studio","text":"<p>Existen varias opciones para instalar Visual Studio y tambi\u00e9n varias versiones del mismo. Para nosotros ser\u00e1 suficiente Visual Studio Community.</p> <p>Como opci\u00f3n de instalaci\u00f3n realizaremos una offline ya que as\u00ed evitaremos tener que descargar Visual Studio y los componentes necesarios para cada instalaci\u00f3n.</p> <p>Los pasos a seguir para realizar esta instalaci\u00f3n (Visual Studio Community + Herramientas de desarrollo en C# para consola) son los siguientes:</p> <ol> <li>Descargar el bootstrapper para Visual Studio Community vs_community.exe</li> <li>Apuntar los identificador de los componentes que deseemos instalar (listados en esta p\u00e1gina). En nuestro caso ser\u00e1 suficiente con: .Net desktop development con ID <code>Microsoft.VisualStudio.Workload.ManagedDesktop</code>.</li> <li>Seleccionar el directorio donde descargaremos los archivos de Visual Studio Community y sus componentes mediante la opci\u00f3n <code>--layout c:\\mi_dir_VSC</code>.</li> <li>Hemos de indicar tambi\u00e9n el lenguaje que deseemos <code>--lang es-ES</code> por ejemplo (lenguajes v\u00e1lidos aqu\u00ed).</li> <li>Finalmente es importante indicar que instale los componentes opcionales con <code>--includeOptional</code></li> </ol> <p>As\u00ed, par instalar la versi\u00f3n Community de Visual Studio con el componente para desarrollo .NET en consola (incluir\u00e1 los lenguajes C#, Visual Basic, and F#) hemos de ejecutar el siguiente comando (en el directorio donde hayamos descargado <code>vs_community.exe</code>):</p> <pre><code>vs_community.exe --offline --layout D:\\VS_Community_Offline --add Microsoft.VisualStudio.Workload.ManagedDesktop --includeOptional --lang es-ES\n</code></pre> <p>Una vez finalice de descargar los ficheros entraremos en el directorio elegido (<code>D:\\VS_Community_Offline</code> en el ejemplo) y ejecutaremos el comando:</p> <pre><code>vs_community.exe --noweb --add Microsoft.VisualStudio.Workload.ManagedDesktop --includeOptional\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.0%20-%20Introduccion%20a%20C-sharp/#que-es-c-sharp","title":"\u00bfQu\u00e9 es C Sharp?","text":"<p>Este lenguaje de programaci\u00f3n fue dise\u00f1ado en el a\u00f1o 2000 por Anders Hejlsberg (Microsoft). Se trata de un lenguaje de alto nivel y prop\u00f3sito general con soporte para m\u00faltiples paradigmas de programaci\u00f3n como: tipado est\u00e1tico, tipado fuerte, \u00e1mbito l\u00e9xico, imperativo, declarativo, funcional, gen\u00e9rico, orientado a objetos (basado en clases) y orientado a componentes.</p> <p>El est\u00e1ndar ECMA lista como objetivos de dise\u00f1o para C# los siguientes: (copiado de la Wikipedia)</p> <ul> <li>Su intenci\u00f3n es ser un lenguaje de programaci\u00f3n simple, moderno, de prop\u00f3sito general y orientado a objetos.</li> <li>El lenguaje deber\u00e1 de incluir comprobaci\u00f3n de tipado fuerte, comprobaci\u00f3n de los l\u00edmites de los array, detectar el uso de variables no inicilizadas y recolecci\u00f3n de basura autom\u00e1tica.</li> <li>La robustez del software, durabilidad y la productividad del programador ser\u00e1n aspectos importantes.</li> <li>El lenguaje est\u00e1 pensado para desarrollo de componentes software en entornos distribuidos.</li> <li>La portabilidad es muy importante para el c\u00f3digo fuente y los programadores, especialmente los familiarizados con C y C++.</li> <li>El soporte para internacionalizaci\u00f3n es muy importante.</li> <li>Aunque la intenci\u00f3n es que las aplicaciones escritas en C# sean econ\u00f3micas en cuanto al uso de memoria y CPU, el lenguaje no ha sido dise\u00f1ado para competir directamente en rendimiento y tama\u00f1o con C o ensamblador.</li> </ul>"},{"location":"Tema%209/Tema%20-%209.0%20-%20Introduccion%20a%20C-sharp/#la-sintaxis-de-c-sharp","title":"La sintaxis de C Sharp","text":"<p>Los elementos fundamentales de la sintaxis de C#  es similar a la de otros lenguajes estilo C como C, C++ y Java:</p> <ul> <li>Se usan <code>;</code> para indicar el fin de una instrucci\u00f3n.</li> <li>Las <code>{}</code> se usan para agrupar instrucciones.</li> <li>Las instrucciones se agrupan generalmente en m\u00e9todos (funciones), los m\u00e9todos en clases y las clases en namespaces (paquetes).</li> <li>Los valores se asignan a variables mediante el s\u00edmbolo <code>=</code> y se comparan con <code>==</code>.</li> <li>Los <code>[]</code> se usan con arrays, tanto para declararlos como para acceder a sus posiciones.</li> <li>...</li> </ul>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/","title":"Tema 9.1: Elementos b\u00e1sicos de C Sharp","text":"<p>En este tema veremos los elementos b\u00e1sicos del lenguaje: variables, operadores y estructuras de control.</p> <p>Haremos esto mediante comparaciones con el lenguaje Java siempre que sea posible.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#creacion-y-ejecucion-de-una-aplicacion","title":"Creaci\u00f3n y ejecuci\u00f3n de una aplicaci\u00f3n","text":"<p>Veremos antes como crear, ejecutar y compilar una aplicaci\u00f3n de C#.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#creacion-de-un-proyecto","title":"Creaci\u00f3n de un proyecto","text":"<p>Para crear un proyecto o aplicaci\u00f3n C# ha de usarse la aplicaci\u00f3n <code>dotnet</code> con la opci\u00f3n <code>new</code> y alguna de las plantillas disponibles. Para ver un listado de todas las plantillas se puede usar el comando <code>dotnet new list</code>.</p> <p>Para crear una aplicaci\u00f3n b\u00e1sica de consola usaremos el comando <code>dotnet new console</code>.</p> <p>Tambi\u00e9n es interesante usar la opci\u00f3n <code>-o</code> para indicar el directorio dentro del que queremos crear nuestra aplicaci\u00f3n. Si no se indica se realizar\u00e1 en el directorio actual.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#ejecucion-de-un-proyecto","title":"Ejecuci\u00f3n de un proyecto","text":"<p>Para ejecutar la aplicaci\u00f3n C# se usar\u00e1 la opci\u00f3n <code>run</code> del comando <code>dotnet</code> dentro del directorio de la aplicaci\u00f3n:</p> <pre><code>dotnet run\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#compilacion-del-proyecto","title":"Compilaci\u00f3n del proyecto","text":"<p>A diferencia de Java en C# se puede generar un archivo ejecutable (<code>.exe</code>) a partir del c\u00f3digo fuente de la aplicaci\u00f3n.</p> <p>Para ello usaremos el comando <code>dotnet build</code>. Este comando compilar\u00e1 el c\u00f3digo fuente de la aplicaci\u00f3n y dar\u00e1 como resultado un archivo ejecutable Windows (<code>.exe</code>).</p> <p>El resultado de la compilaci\u00f3n se guardar\u00e1 en el directorio <code>bin</code> (binarios) del proyecto.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#variables","title":"Variables","text":"<p>Las principales diferencias entre las variables de C# y Java es que en el primero las variables primitivas podr\u00e1n pasarse por valor o por referencia. La segunda diferencia es que en lugar de disponer de tipos envoltorio, como Java, para trabajar con variables sencillas (los tipos primitivos de Java) se utiliza un nuevo tipo de datos <code>struct</code> para realizar una funci\u00f3n similar. Los tipos primitivos de C# ser\u00e1n todos <code>struct</code>s, una especie de clases limitadas con valores y m\u00e9todos.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#situacion-en-java","title":"Situaci\u00f3n en Java","text":"<p>En Java tenemos dos tipos de datos o variables: variables primitivas (int, short, long, double, float, boolean, byte y char) y clases.</p> <p>Los tipos primitivos son variables que se pasan por valor. Esto quiere decir que cuando le pasamos una variable int como argumento a un m\u00e9todo, este no puede modificarla. Ve\u00e1moslo con un ejemplo:</p> <pre><code>public class Main {\n    public static void metodoValor(int x, int y, int z) {\n        z = x + y;\n        System.out.printf(\"(m\u00e9todo:) x = %d, y = %d. y z = %d.%n\", x, y, z);\n    }\n\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 10;\n        int z = 0;\n\n        System.out.printf(\"x = %d, y = %d y z = %d.%n\", x, y, z);\n\n        metodoValor(x, y, z);\n\n        System.out.printf(\"x = %d, y = %d y z = %d.%n\", x, y, z);\n    }\n}\n</code></pre> <p>La ejecuci\u00f3n del c\u00f3digo anterior devolver\u00e1 la siguiente salida:</p> <pre><code>x = 5, y = 10 y z = 0.\n(m\u00e9todo:) x = 5, y = 10. y z = 15.\nx = 5, y = 10 y z = 0.\n</code></pre> <p>Como podemos observar la variable <code>z</code> toma el valor de la suma dentro del m\u00e9todo pero su valor en el exterior no se ve modificado.</p> <p>Esto se debe a que las variables que se pasan por valor \u00fanicamente transmiten una copia de su valor al m\u00e9todo y no una referencia a la variable.</p> <p>Una variable de tipo array es, por el contrario una variables que se pasa por referencia. Esto es, se pasa la referencia a la variable y puede ser alterada:</p> <pre><code>import java.util.Arrays;\n\npublic class Main {\n\n    public static void metodoReferencia(int[] arr) {\n        arr[0] = 0;\n        arr[1] = 0;\n        arr[2] = 0;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3};\n\n        System.out.printf(\"Antes: s = %s.%n\", Arrays.toString(arr));\n\n        metodoReferencia(arr);\n\n        System.out.printf(\"Despu\u00e9s: s = %s.%n\", Arrays.toString(arr));\n    }\n}\n</code></pre> <p>La salida de la ejecuci\u00f3n de este c\u00f3digo es:</p> <pre><code>s = [1, 2, 3].\ns = [0, 0, 0].\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#situacion-en-c-sharp","title":"Situaci\u00f3n en C Sharp","text":"<p>Las variables en C# pueden ser tambi\u00e9n por valor y por referencia. Las variables tipo <code>struct</code> en C# son por defecto por valor (similares a los tipos primitivos de Java) mientras que las clases son, igual que en Java, por referencia.</p> <p>Pero las <code>struct</code> no son tan b\u00e1sicas como los tipos primitivos si no que se acercan m\u00e1s a las clases. Las <code>struct</code> almacenan valores y m\u00e9todos al igual que las clases. Pueden definirse como clases muy sencillas con un comportamiento especial.</p> <p>Tambi\u00e9n, a diferencia de Java, en C# podremos crear nuestras propias <code>struct</code>s.</p> <p>Ejemplos de <code>struct</code> predefinidas del lenguaje son: shot, int, long, float, double, decimal, bool, char.</p> <p>Si se las pasamos a un m\u00e9todo como argumentos tendremos el mismo comportamiento que en Java:</p> <pre><code>static void metodoValor(int x, int y, int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\nint z = 0;\n\nmetodoValor(x, y, z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre> <p>La ejecuci\u00f3n de este c\u00f3digo dar\u00e1 como resultado:</p> <pre><code>En el m\u00e9todo: x = 5, y = 10 y z = 15\nFuera del m\u00e9todo: x = 5, y = 10 y z = 0\n</code></pre> <p>En C#, a diferencia de Java, existe la opci\u00f3n de pasar estas variables por referencia como veremos en le siguiente apartado.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#variables-por-referencia","title":"Variables por referencia","text":"<p>Para pasar las variable primitivas por referencia hemos de usar las palabras reservadas <code>ref</code> o <code>out</code>. Veamos un ejemplo:</p> <pre><code>static void metodoReferencia(int x, int y, ref int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\nint z = 0;\n\nmetodoReferencia(x, y, ref z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre> <p>Ahora la salida del programa ser\u00e1:</p> <pre><code>En el m\u00e9todo: x = 5, y = 10 y z = 15\nFuera del m\u00e9todo: x = 5, y = 10 y z = 15\n</code></pre> <p>La otra opci\u00f3n con <code>out</code> se similar. Con esta opci\u00f3n no se exige que se le de un valor inicial a la variable que guardar\u00e1 la salida:</p> <pre><code>static void metodoReferencia(int x, int y, out int z) {\n    z = x + y;\n    System.Console.WriteLine($\"En el m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n}\n\nint x = 5;\nint y = 10;\nint z; // No hace falta inicializar z cuando es \"out\".\n\nmetodoReferencia(x, y, out z);\nSystem.Console.WriteLine($\"Fuera del m\u00e9todo: x = {x}, y = {y} y z = {z}\");\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#operadores","title":"Operadores","text":"<p>No aprecio diferencia en los operadores respecto a Java.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#estructuras-de-control","title":"Estructuras de control","text":"<p>Las estructuras de control son similares a las de Java con diferencias menores.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#if-else","title":"<code>if-else</code>","text":"<p>Esta estructura no tiene ninguna diferencia en funcionamiento o sintaxis a Java.</p>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#switch","title":"<code>switch</code>","text":""},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#for","title":"<code>for</code>","text":"<p>Esta estructura presenta alguna diferencia. En la secci\u00f3n inicial y final se pueden incluir m\u00e1s instrucciones de las de inicializaci\u00f3n e incremento:</p> <pre><code>int i, j; // Importante declaraci\u00f3n externa.\nfor (System.Console.WriteLine(\"Secci\u00f3n de inicializaci\u00f3n.\"), i = 0, j = 10; i &lt; j; ++i, --j, System.Console.WriteLine($\"Secci\u00f3n de incremento i = {i} y j = {j}.\")) {\n    System.Console.WriteLine($\"Dentro del bucle iteraci\u00f3n {i}.\");\n}\n</code></pre> <pre><code>Secci\u00f3n de inicializaci\u00f3n.\nDentro del bucle iteraci\u00f3n 0.\nSecci\u00f3n de incremento i = 1 y j = 9.\nDentro del bucle iteraci\u00f3n 1.\nSecci\u00f3n de incremento i = 2 y j = 8.\nDentro del bucle iteraci\u00f3n 2.\nSecci\u00f3n de incremento i = 3 y j = 7.\nDentro del bucle iteraci\u00f3n 3.\nSecci\u00f3n de incremento i = 4 y j = 6.\nDentro del bucle iteraci\u00f3n 4.\nSecci\u00f3n de incremento i = 5 y j = 5.\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#for-each","title":"<code>for-each</code>","text":"<p>Las diferencias en el bucle <code>for-each</code> son tambi\u00e9n (al menos externamente) muy peque\u00f1as:</p> <pre><code>List&lt;int&gt; listInt = new List&lt;int&gt;();\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#while","title":"<code>while</code>","text":""},{"location":"Tema%209/Tema%20-%209.1%20-%20Elementos%20b%C3%A1sicos%20de%20C-Sharp/#do-while","title":"<code>do-while</code>","text":""},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/","title":"Tema 9.2: Estructuras de datos","text":"<p>En este tema veremos de manera resumida las estructuras m\u00e1s comunes que se utilizan en C#.</p> <p>Empezaremos por las m\u00e1s sencillas como son arrays y tuplas, y continuaremos con las que hacen uso de gen\u00e9ricos como lista, pila, cola y diccionario.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#arrays","title":"Arrays","text":"<p>Los arrays en C# son id\u00e9nticos a los de Java.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#declaracion-de-un-array","title":"Declaraci\u00f3n de un array","text":"<p>Al igual que en Java se declaran indicando:</p> <pre><code>// tipo seguido de [ y ] y el nombre de la variable.\nint[] arrayDeEnteros;\n\n// Opcionalmente se puede crear el array don un tama\u00f1o.\nint[] arrayDe5Enteros = new int[5];\n\n// O tambi\u00e9n se pueden asignar directamente valores.\nint[] arrayConValores = {1, 2, 3};\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#acceso-a-sus-elementos","title":"Acceso a sus elementos","text":"<p>Para acceder a un elemento concreto del array indicaremos al lado de la variable, entre corchetes, la posici\u00f3n o \u00edndice del elemento. Recordemos que el primer elemento tendr\u00e1 \u00edndice 0:</p> <pre><code>int[] intArr = {1, 2, 3};\nint[1] = int[1] * 10;\n// Ahora el array ser\u00e1 [1, 20, 3]\n</code></pre> <p>Para recorrer los elementos de un array se emplear\u00e1 la estructura <code>foreach</code>:</p> <pre><code>foreach (int i in intArr) {\n    //...\n}\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#longitud-de-un-array","title":"Longitud de un array","text":"<p>Para ver la longitud de un array hemos de acceder a la propiedad <code>Length</code> o <code>LongLength</code>.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#funciones-de-arrays-y-colecciones-en-general","title":"Funciones de arrays (y colecciones en general)","text":"<p>Hay tres funciones que se suele aplicar sobre las estructura tipo colecci\u00f3n como son los arrays o las listas. Estas funciones son generalmente conocidas como map, reduce y filter:</p> <ol> <li>Map: Permite transformar una lista aplicando una funci\u00f3n a cada uno de sus elementos.</li> <li>Reduce: Permite... permite hacerle de todo a los elementos de una lista.</li> <li>Filter: Como su nombre indica permite filtrar los elementos de una lista aplicando una condici\u00f3n (en forma de funci\u00f3n).</li> </ol> <p>Map se denominar\u00e1 <code>Select</code> en C#, reduce ser\u00e1 <code>Aggregate</code> y filter pasar\u00e1 a denominarse <code>Where</code>.</p> <p>Veamos un ejemplo con cada una.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#map-select","title":"Map / <code>Select</code>","text":"<p>Escribamos una funci\u00f3n que eleve al cuadrado todos los elementos de un array de enteros:</p> <pre><code>int[] intArr = {1, 2, 3};\nintArr = intArr.Select(elem =&gt; elem * elem).ToArray&lt;int&gt;();\n\n// Ahora los valores de intArr ser\u00e1n [1, 4, 9].\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#reduce-aggregate","title":"Reduce / <code>Aggregate</code>","text":"<p>Esta es quiz\u00e1 una de las funciones m\u00e1s complicadas de entender de las que se pueden aplicar a listas de elementos. Esta funci\u00f3n permite procesar una lista iterando elemento a elemento y a la vez calculando algo paso a paso.</p> <p>Para poder realizar este c\u00e1lculo es necesario que una variable acumulador se pueda ir pasando a la funci\u00f3n que se aplicar\u00e1 a cada elemento de la lista de elementos.</p> <pre><code>int[] intArr = {1, 2, 3};\n\nint total = intArr.Aggregate((acc, e) =&gt; acc += e);\n</code></pre> <p>El c\u00f3digo anterior aplica la funci\u00f3n lambda <code>(acc, e) =&gt; acc + e</code> a cada elemento de la lista teniendo en cuenta que:</p> <ol> <li>El par\u00e1metro <code>e</code> ir\u00e1 tomando el valor de cada elemento del array (Enumerable) (1, 2 y 3 sucesivamente en nuestro ejemplo).</li> <li>El par\u00e1metro <code>acc</code> es, por defecto, del mismo tipo que el contenido del Enumerable sobre el que se ejecuta.</li> <li>El valor inicial de <code>acc</code> ser\u00e1 0, cadena vac\u00eda, etc. si no se le indica un valor expl\u00edcitamente.</li> <li>El valor de <code>acc</code> para cada elemento despu\u00e9s del primero ser\u00e1 el resultado de la funci\u00f3n lambda.</li> </ol> <p>As\u00ed, en nuestro ejemplo:</p> <ol> <li>Primera invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(0, 1)</code> y retornar\u00eda <code>0 + 1</code>, es decir, <code>1</code>.</li> <li>Segunda invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(1, 2)</code> y retornar\u00eda <code>1 + 2</code>, <code>3</code>.</li> <li>Tercera invocaci\u00f3n: la funci\u00f3n se invocar\u00eda con los argumentos <code>(3, 3)</code> y retornar\u00eda <code>3 + 3</code>, <code>6</code>.</li> </ol> <p>Para darle un valor inicial distinto de <code>0</code> al acumulador le pasaremos un argumento m\u00e1s a <code>Aggregate</code>:</p> <pre><code>int[] intArr = {1, 2, 3};\n\nint total = intArr.Aggregate(100, (acc, e) =&gt; acc += e);\n</code></pre> <p>Ahora el primer valor de <code>acc</code> ser\u00e1 <code>100</code> y el resultado final <code>106</code>.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#filter-where","title":"Filter / <code>Where</code>","text":"<p>El m\u00e9todo <code>Where</code> de los objetos que implementan <code>IEnumerable</code> (con es el caso de <code>Array</code> o <code>List</code>) permite seleccionar algunos elementos del enumerable en funci\u00f3n del resultado (verdadero o falso) que devuelva una funci\u00f3n lambda que se le pasa al m\u00e9todo.</p> <p>Ve\u00e1moslo con un ejemplo:</p> <pre><code>int[] intArr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\nintArr.Where(e =&gt; e % 2 == 0).ToList().ForEach(e =&gt; System.Console.WriteLine(e));\n</code></pre> <p>El c\u00f3digo anterior mostrar\u00e1 por consola el texto:</p> <pre><code>2\n4\n6\n8\n10\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#tuplas","title":"Tuplas","text":"<p>Una tupla es un tipo de datos similar a un array o a una lista pero pensados para tama\u00f1os m\u00e1s peque\u00f1os.</p> <p>Una tupla puede contener distintos tipos de datos.</p> <p>Una tupa puede asignar un nombre a cada uno de sus elementos.</p> <p>Una tupla es parecida a un mapa de Java.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#definicion-de-una-variable","title":"Definici\u00f3n de una variable","text":"<p>Para declarar una variable tupla hemos de indicar el tipo de sus datos dentro de par\u00e9ntesis:</p> <pre><code>(int, string, string) miTupla = (1, \"uno\", \"one\");\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#acceso-a-los-elementos","title":"Acceso a los elementos","text":"<p>Para acceder a los elementos de la tupla usaremos la palabra <code>ItemX</code> donde <code>X</code> tomar\u00e1 los valores 1, 2, ... para referirse al primer, segundo, etc. elemento de la misma.</p> <pre><code>(int, string, string) miTupla = (1, \"uno\", \"one\");\n\nConsole.WriteLine(miTupla.Item1 == 1);\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#nombrando-elementos","title":"Nombrando elementos","text":"<p>Para evitar tener que utilizar <code>Item1</code>, <code>Item2</code>, etc. que tienen muy poco significado podemos darles nombres a los elementos de la tupla:</p> <pre><code>(Value: int, Spanish: string, English: string) = (1, \"uno\", \"one\");\n\nConsole.WriteLine($\"valor: {miTupla.Value}, espa\u00f1ol: {miTupla.Spanish} e ingl\u00e9s: {miTupla.English}.\");\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#genericos","title":"Gen\u00e9ricos","text":"<p>La forma de trabajar con gen\u00e9ricos en C# es b\u00e1sicamente id\u00e9ntica a Java.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#declaracion-de-genericos","title":"Declaraci\u00f3n de gen\u00e9ricos","text":"<pre><code>class ContenedorGenerico&lt;T&gt;\n{\n    private T[] array;\n    private int count;\n\n    public ContenedorGenerico(int size)\n    {\n        array = new T[size];\n        count = 0;\n    }\n\n    public void Add(T element)\n    {\n        if (count &lt; array.Length)\n        {\n            array[count] = element;\n            count++;\n        }\n    }\n\n    public T Get(int index)\n    {\n        if (index &lt; count)\n        {\n            return array[index];\n        }\n        else\n        {\n            throw new IndexOutOfRangeException();\n        }\n    }\n\n    public void Set(int index, T element)\n    {\n        if (index &lt; count)\n        {\n            array[index] = element;\n        }\n        else\n        {\n            throw new IndexOutOfRangeException();\n        }\n    }\n\n    public int Count\n    {\n        get\n        {\n            return count;\n        }\n    }\n\n    public T this[int index]\n    {\n        get\n        {\n            return Get(index);\n        }\n        set\n        {\n            Set(index, value);\n        }\n    }\n}\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#listas","title":"Listas","text":"<p>De nuevo las listas de C# son muy similares a las listas de Java, aunque en C# s\u00f3lo hay un tipo de lista <code>List</code> en lugar de <code>ArrayList</code> y <code>LinkedList</code> de Java.</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#declarar-una-lista","title":"Declarar una lista","text":"<p>Para declarar una lista en C# hemos de indicar el tipo de dato que va a contener la lista como con cualquier otra clase gen\u00e9rica:</p> <pre><code>List&lt;string&gt; listaCadenas = new List&lt;String&gt;();\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#declarar-e-inicializar","title":"Declarar e inicializar","text":"<p>Tambi\u00e9n es posible declarar una lista y al mismo tiempo darle unos valores iniciales:</p> <pre><code>List&lt;int&gt; listaEnteros = new List&lt;int&gt;() {1, 2, 3, 4, 5};\n</code></pre>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#anadir-elementos","title":"A\u00f1adir elementos","text":"<p>Para a\u00f1adir elementos (al final de la lista) usaremos el m\u00e9todo <code>Add</code>:</p> <pre><code>List&lt;int&gt; listaEnteros = new List&lt;int&gt;() {1, 2, 3, 4, 5};\n\nlistaEnteros.Add(6);\n\nlistaEnteros.ForEach(e =&gt; Console.Write(e + \", \"));\n\n// 1, 2, 3, 4, 5, 6, \n</code></pre> <p>Y en caso de que deseemos insertar el valor en una posici\u00f3n determinada usaremos el m\u00e9todo <code>Insert</code>:</p> <p>```c# List listaEnteros = new List() {1, 2, 3, 4, 5}; <p>listaEnteros.Insert(2, 3);</p> <p>for (int e in listaEnteros) {     Console.Write(e + \", \"); }</p> <p>// 1, 2, 3, 3, 4, 5</p>"},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#pilas","title":"Pilas","text":""},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#colas","title":"Colas","text":""},{"location":"Tema%209/Tema%20-%209.2%20-%20Estructuras%20de%20datos%20de%20C-Sharp/#mapas","title":"Mapas","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/","title":"Tema 9.3: Clases","text":"<p>Una clase, lo primero que ha de tener, es clase.</p>"},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#namespaces","title":"Namespaces","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#declaracion-de-una-clase","title":"Declaraci\u00f3n de una clase","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#variables-de-clase-y-de-instancia","title":"Variables de clase y de instancia","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#propiedades","title":"Propiedades","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#escritura-lectura-y-lectura-y-escritura","title":"Escritura, lectura y lectura y escritura","text":""},{"location":"Tema%209/Tema%20-%209.3%20-%20Clases/#metodos","title":"M\u00e9todos","text":""},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/","title":"Tema 11: Introducci\u00f3n a las clases en Python","text":""},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#clase-como-tipo","title":"Clase como tipo","text":"<p>TODO: Usar type para ver ejemplos de los tipos de clases y objetos / variables.</p>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#declaracion-de-una-clase","title":"Declaraci\u00f3n de una clase","text":"<pre><code>class MiClase:\n    # C\u00f3digo de la clase.\n</code></pre>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#creacion-de-una-instancia-u-objeto","title":"Creaci\u00f3n de una instancia u objeto","text":"<pre><code>mi_objeto = MiClase()\n</code></pre>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#propiedades-de-la-clase","title":"Propiedades de la clase","text":"<p>Las propiedades de la clase son variables que se declaran justo despu\u00e9s de la declaraci\u00f3n con el nombre de la clase.</p> <pre><code>class MiClase:\n    mi_variable = 0\n</code></pre> <p>Para acceder a una propiedad de la clase podremos:</p> <ul> <li>Indicar el nombre de la clase que la contiene seguido de punto y el nombre de la variable: <code>MiClase.mi_variable</code>.</li> <li>Indicar el nombre de un objeto de la clase seguido de punto y el nombre de la variable.</li> </ul>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#propiedades-privadas-u-ocultas","title":"Propiedades privadas u ocultas","text":"<p>Para ocultar una propiedad y de este modo hacerla privada hemos de precederla por <code>__</code>:</p> <pre><code>class MiClase:\n    mi_variable = 0\n    __variable_oculta = 10\n</code></pre> <p>Si intentamos acceder a esta variable como:</p> <pre><code>MiClase.__variable_oculta = 100\n</code></pre>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#por-que-privada-u-oculta","title":"\u00bfPor qu\u00e9 privada u oculta?","text":"<p>A diferencia de otros lenguajes de programaci\u00f3n como Java que realmente ocultan sus atributos privados, los atributos privados de una clase de Python siguen siendo accesibles.</p> <p>Para acceder a una variable privada Cosa que NO DEBEMOS HACER hemos de escribir lo siguiente:</p> <pre><code>[nombre de la clase / objeto]._[nombre de la clase]__[nombre de la variable]\n</code></pre> <p>Obtendremos un error <code>AttributeError</code></p>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#el-metodo-constructor","title":"El m\u00e9todo Constructor","text":"<p>Cuando declaremos un m\u00e9todo perteneciente a una clase siempre hemos de declarar un primer atributo que hace referencia al objeto. Este argumento, aunque puede llevar cualquier nombre, por convenio se nombra como <code>self</code></p> <pre><code>class MiClase:\n    def __init__(self):\n        pass\n</code></pre>"},{"location":"Tema%20Extra/Tema%2011.0%20-%20Introduccion/#variables-de-instancia-u-objeto","title":"Variables de instancia u objeto","text":"<p>Para declarar una variable propia del objeto hemos de hacerlo dentro del constructor:</p> <pre><code>class Punto:\n    instancias = 0\n\n    def __init__(self, x: float, y: float) -&gt; None:\n        self.x = x\n        self.y = y\n        instancias += 1\n</code></pre>"}]}